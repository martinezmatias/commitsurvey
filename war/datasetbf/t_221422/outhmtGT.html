<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_Server_1.227.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek - Copyright (C) 2000-2002 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.net.*;<br/>
import java.io.*;<br/>
import java.util.*;<br/>
<br/>
import megamek.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.common.options.*;<br/>
import megamek.server.commands.*;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server<br/>
implements Runnable {<br/>
    //    public final static String  LEGAL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-";<br/>
    public final static String  DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;<br/>
    <br/>
    // server setup<br/>
    private String              password;<br/>
    private ServerSocket        serverSocket;<br/>
    private ServerLog           log = new ServerLog();<br/>
    private String              motd;<br/>
    <br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
    <br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
    <br/>
    private Game                game = new Game();<br/>
    <br/>
    private MapSettings         mapSettings = new MapSettings();<br/>
    <br/>
    // list of turns and whose turn it is<br/>
    private int                 roundCounter = 0;<br/>
    private Vector              turns = new Vector();<br/>
    private int                 turnIndex = 0;<br/>
    private int                 turnInfMoved = 0;<br/>
    private int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = -1;<br/>
    <br/>
    // stuff for the current turn<br/>
    private Vector              attacks = new Vector();<br/>
    private Vector              pendingCharges = new Vector();<br/>
    private Vector              pilotRolls = new Vector();<br/>
    <br/>
    private StringBuffer        roundReport = new StringBuffer();<br/>
    private StringBuffer        phaseReport = new StringBuffer();<br/>
    <br/>
    private boolean             forceVictory = false;<br/>
    <br/>
    // commands<br/>
    private Hashtable           commandsHash = new Hashtable();<br/>
    <br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
    <br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     */<br/>
    public Server(String password, int port) {<br/>
        this.password = password.length() &gt; 0 ? password : null;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port " + port);<br/>
        }<br/>
        <br/>
        motd = createMotd();<br/>
        <br/>
        game.getOptions().initialize();<br/>
        <br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
        <br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
        System.out.println("s: address = " + serverSocket.getInetAddress().getHostAddress() + " port = " + serverSocket.getLocalPort());<br/>
        try {<br/>
            System.out.println("s: address = " + InetAddress.getByName("127.0.0.1").getHostAddress());<br/>
        } catch(UnknownHostException ex) {}<br/>
        System.out.println("s: password = " + this.password);<br/>
        <br/>
        connector = new Thread(this);<br/>
        connector.start();<br/>
        <br/>
        // register commands<br/>
        registerCommand(new HelpCommand(this));<br/>
        registerCommand(new KickCommand(this));<br/>
        registerCommand(new ResetCommand(this));<br/>
        registerCommand(new RollCommand(this));<br/>
        registerCommand(new VictoryCommand(this));<br/>
        registerCommand(new WhoCommand(this));<br/>
    }<br/>
    <br/>
    public void setGame(Game g) {<br/>
        game = g;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Make a default message o' the day containing the version string, and<br/>
     * if it was found, the build timestamp<br/>
     */<br/>
    private String createMotd() {<br/>
        StringBuffer buf = new StringBuffer();<br/>
        buf.append("Welcome to MegaMek.  Server is running version ");<br/>
        buf.append(MegaMek.VERSION);<br/>
        buf.append(", build date ");<br/>
        if (MegaMek.TIMESTAMP &gt; 0L) {<br/>
            buf.append(new Date(MegaMek.TIMESTAMP).toString());<br/>
        } else {<br/>
            buf.append("unknown");<br/>
        }<br/>
        buf.append(".");<br/>
        <br/>
        return buf.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * @return true if the server has a password<br/>
     */<br/>
    public boolean isPassworded() {<br/>
        return password != null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * @return true if the password matches<br/>
     */<br/>
    public boolean isPassword(Object guess) {<br/>
        return password.equals(guess);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Registers a new command in the server command table<br/>
     */<br/>
    private void registerCommand(ServerCommand command) {<br/>
        commandsHash.put(command.getName(), command);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the command associated with the specified name<br/>
     */<br/>
    public ServerCommand getCommand(String name) {<br/>
        return (ServerCommand)commandsHash.get(name);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shuts down the server.<br/>
     */<br/>
    public void die() {<br/>
        // kill thread accepting new connections<br/>
        connector = null;<br/>
        <br/>
        // close socket<br/>
        try {<br/>
            serverSocket.close();<br/>
        } catch(IOException ex) { ; }<br/>
        <br/>
        // kill pending connnections<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.die();<br/>
        }<br/>
        connectionsPending = null;<br/>
        <br/>
        // kill active connnections<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.die();<br/>
        }<br/>
        connections = null;<br/>
        connectionIds = null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns an enumeration of all the command names<br/>
     */<br/>
    public Enumeration getAllCommandNames() {<br/>
        return commandsHash.keys();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sent when a clients attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server greeting -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Allow the player to set whatever parameters he is able to<br/>
     */<br/>
    private void receivePlayerInfo(Packet packet, int connId) {<br/>
        Player player = (Player)packet.getObject(0);<br/>
        game.getPlayer(connId).setColorIndex(player.getColorIndex());<br/>
        game.getPlayer(connId).setStartingPos(player.getStartingPos());<br/>
        game.getPlayer(connId).setTeam(player.getTeam());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recieves a player name, sent from a pending connection, and connects<br/>
     * that connection.<br/>
     */<br/>
    private void receivePlayerName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
        String name = (String)packet.getObject(0);<br/>
        boolean returning = false;<br/>
        <br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending connection");<br/>
            return;<br/>
        }<br/>
        <br/>
        // check if they're connecting with the same name as a ghost player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.isGhost() &amp;&amp; player.getName().equals(name)) {<br/>
                returning = true;<br/>
                player.setGhost(false);<br/>
                // switch id<br/>
                connId = player.getId();<br/>
                conn.setId(connId);<br/>
            }<br/>
        }<br/>
        <br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
        <br/>
        // add and validate the player info<br/>
        if (!returning) {<br/>
            game.addPlayer(connId, new Player(connId, name));<br/>
            validatePlayerInfo(connId);<br/>
        }<br/>
        <br/>
        // if it is not the lounge phase, this player becomes an observer<br/>
        if (game.phase != Game.PHASE_LOUNGE<br/>
        &amp;&amp; game.getEntitiesOwnedBy(getPlayer(connId)) &lt; 1) {<br/>
            getPlayer(connId).setObserver(true);<br/>
        }<br/>
        <br/>
        // send the player the motd<br/>
        sendServerChat(connId, motd);<br/>
        <br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
        <br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
        <br/>
        // send current game info<br/>
        sendCurrentInfo(connId);<br/>
        <br/>
        System.out.println("s: player " + connId<br/>
        + " (" + getPlayer(connId).getName() + ") connected from "<br/>
        + getClient(connId).getSocket().getInetAddress());<br/>
        sendServerChat(getPlayer(connId).getName() + " connected from "<br/>
        + getClient(connId).getSocket().getInetAddress());<br/>
        <br/>
        // there is more than one player, uncheck the friendly fire option<br/>
        if (game.getNoOfPlayers() &gt; 1 &amp;&amp; game.getOptions().booleanOption("friendly_fire")) {<br/>
            game.getOptions().getOption("friendly_fire").setValue(false);<br/>
            send(createGameSettingsPacket());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends a player the info they need to look at the current phase<br/>
     */<br/>
    private void sendCurrentInfo(int connId) {<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(createGameSettingsPacket());<br/>
        if (doBlind()) {<br/>
            send(connId, createFilteredEntitiesPacket(getPlayer(connId)));<br/>
        }<br/>
        else {<br/>
            send(connId, createEntitiesPacket());<br/>
        }<br/>
        switch (game.phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                send(connId, createMapSettingsPacket());<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
            case Game.PHASE_END :<br/>
            case Game.PHASE_VICTORY :<br/>
                send(createReportPacket());<br/>
            default :<br/>
                getPlayer(connId).setDone(game.getEntitiesOwnedBy(getPlayer(connId)) &lt;= 0);<br/>
                send(connId, createBoardPacket());<br/>
                break;<br/>
        }<br/>
        send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(game.phase)));<br/>
        if (game.phaseHasTurns(game.getPhase())) {<br/>
            send(new Packet(Packet.COMMAND_TURN, game.getTurn()));<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    <br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        final Player player = getPlayer(playerId);<br/>
        <br/>
        //        maybe this isn't actually useful<br/>
        //        // replace characters we don't like with "X"<br/>
        //        StringBuffer nameBuff = new StringBuffer(player.getName());<br/>
        //        for (int i = 0; i &lt; nameBuff.length(); i++) {<br/>
        //            int chr = nameBuff.charAt(i);<br/>
        //            if (LEGAL_CHARS.indexOf(chr) == -1) {<br/>
        //                nameBuff.setCharAt(i, 'X');<br/>
        //            }<br/>
        //        }<br/>
        //        player.setName(nameBuff.toString());<br/>
        <br/>
        //TODO: check for duplicate or reserved names<br/>
        <br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player otherPlayer = (Player)i.nextElement();<br/>
            if (otherPlayer.getId() != playerId) {<br/>
                colorUsed[otherPlayer.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (colorUsed[player.getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    player.setColorIndex(i);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when it is sensed that a connection has terminated.<br/>
     */<br/>
    public void disconnected(int connId) {<br/>
        final Connection conn = getClient(connId);<br/>
        final Player player = getPlayer(connId);<br/>
        <br/>
        // if the connection's even still there, remove it<br/>
        if (conn != null) {<br/>
            conn.die();<br/>
            connections.removeElement(conn);<br/>
            connectionIds.remove(new Integer(connId));<br/>
        }<br/>
        <br/>
        // in the lounge, just remove all entities for that player<br/>
        if (game.phase == Game.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
            //send(createEntitiesPacket());<br/>
            entityAllUpdate();<br/>
        }<br/>
        <br/>
        // if a player has active entities, he becomes a ghost<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0) {<br/>
            player.setGhost(true);<br/>
            player.setDone(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, new Integer(player.getId())));<br/>
        }<br/>
        <br/>
        // make sure the game advances<br/>
        if (game.phaseHasTurns(game.getPhase())) {<br/>
            if (game.getTurn().getPlayerNum() == player.getId()) {<br/>
                endCurrentTurn();<br/>
            }<br/>
        } else {<br/>
            checkReady();<br/>
        }<br/>
        <br/>
        System.out.println("s: player " + connId + " disconnected");<br/>
        sendServerChat(player.getName() + " disconnected.");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks each player to see if he has no entities, and if true, sets the<br/>
     * observer flag for that player.  An exception is that there are no<br/>
     * observers during the lounge phase.<br/>
     */<br/>
    public void checkForObservers() {<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setObserver(game.getEntitiesOwnedBy(p) &lt; 1 &amp;&amp; game.phase != Game.PHASE_LOUNGE);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Reset the game back to the lounge.<br/>
     *<br/>
     * TODO: couldn't this be a hazard if there are other things executing at<br/>
     *  the same time?<br/>
     */<br/>
    public void resetGame() {<br/>
        // remove all entities<br/>
        game.reset();<br/>
        send(createEntitiesPacket());<br/>
        <br/>
        //TODO: remove ghosts<br/>
        <br/>
        // reset all players<br/>
        resetPlayersDone();<br/>
        transmitAllPlayerDones();<br/>
        <br/>
        pilotRolls.removeAllElements();<br/>
        <br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
    }<br/>
    <br/>
    public void autoSave()<br/>
    {<br/>
        saveGame("autosave");<br/>
    }<br/>
    <br/>
    public void saveGame(String sFile) {<br/>
        String sFinalFile = sFile + ".sav";<br/>
        try {<br/>
            ObjectOutputStream oos = new ObjectOutputStream(<br/>
                    new FileOutputStream(sFinalFile));<br/>
            oos.writeObject(game);<br/>
            oos.flush();<br/>
            oos.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to save file: " + sFinalFile);<br/>
            e.printStackTrace();<br/>
        }<br/>
        sendChat("MegaMek", "Game saved to " + sFinalFile);<br/>
    }<br/>
    <br/>
    public boolean loadGame(File f) {<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                    new FileInputStream(f));<br/>
            game = (Game)ois.readObject();<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
            return false;<br/>
        }<br/>
        <br/>
        // reattach the transient fields and ghost the players<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements(); ) {<br/>
            Entity ent = (Entity)e.nextElement();<br/>
            ent.setOwner(game.getPlayer(ent.getOwnerId()));<br/>
            ent.setGame(game);<br/>
            ent.restore();<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setGame(game);<br/>
            p.setGhost(true);<br/>
        }<br/>
        <br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Counts up how many non-ghost, non-observer players are connected.<br/>
     */<br/>
    private int countActivePlayers() {<br/>
        int count = 0;<br/>
        <br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver()) {<br/>
                count++;<br/>
            }<br/>
        }<br/>
        <br/>
        return count;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
        <br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            game.removeEntity(entity.getId());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Enumeration getConnections() {<br/>
        return connections.elements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            <br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Are we out of turns (done with the phase?)<br/>
     */<br/>
    private boolean areMoreTurns() {<br/>
        return turnIndex &lt; turns.size();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the next turn object or null if we're done with this phase<br/>
     */<br/>
    private GameTurn nextTurn() {<br/>
        return (GameTurn)turns.elementAt(turnIndex++);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this entity<br/>
     * that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            entity.newRound();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase() {<br/>
        // first, mark doomed entities as destroyed and move them to the graveyard<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
            if (entity.isDestroyed() || entity.getCrew().isDead()) {<br/>
                int condition = Game.UNIT_SALVAGEABLE;<br/>
                if ( !entity.isSalvage() ) {<br/>
                    condition = Game.UNIT_DEVASTATED;<br/>
                }<br/>
                game.removeEntity(entity.getId(), condition);<br/>
                send( createRemoveEntityPacket(entity.getId(), condition) );<br/>
            }<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            entity.applyDamage();<br/>
            <br/>
            entity.reloadEmptyWeapons();<br/>
            <br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
            <br/>
            // reset done to false<br/>
            entity.setDone(!entity.isActive());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.setDone(false);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
            <br/>
        }<br/>
        transmitAllPlayerDones();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Writes the victory report<br/>
     */<br/>
    private void prepareVictoryReport() {<br/>
        roundReport = new StringBuffer();<br/>
        <br/>
        roundReport.append("\nVictory!\n-------------------\n\n");<br/>
<br/>
        Enumeration survivors = game.getEntities();<br/>
        if ( survivors.hasMoreElements() ) {<br/>
            roundReport.append("Survivors are:\n");<br/>
            while ( survivors.hasMoreElements() ) {<br/>
                Entity entity = (Entity) survivors.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration retreat = game.getRetreatedEntities();<br/>
        if ( retreat.hasMoreElements() ) {<br/>
            roundReport.append("\nThe following units are in retreat:\n");<br/>
            while ( retreat.hasMoreElements() ) {<br/>
                Entity entity = (Entity) retreat.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration graveyard = game.getGraveyardEntities();<br/>
        if ( graveyard.hasMoreElements() ) {<br/>
            roundReport.append("\nGraveyard contains:\n");<br/>
            while ( graveyard.hasMoreElements() ) {<br/>
                Entity entity = (Entity) graveyard.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration devastated = game.getDevastatedEntities();<br/>
        if ( devastated.hasMoreElements() ) {<br/>
            roundReport.append("\nThe following utterly destroyed units are not available for salvage:\n");<br/>
            while ( devastated.hasMoreElements() ) {<br/>
                Entity entity = (Entity) devastated.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        roundReport.append("\nDetailed unit status saved to entitystatus.txt\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Generates a detailed report for campaign use<br/>
     */<br/>
    private String getDetailedVictoryReport() {<br/>
        StringBuffer sb = new StringBuffer();<br/>
        <br/>
        Vector vAllUnits = new Vector();<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
        <br/>
        for ( Enumeration i = game.getRetreatedEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getGraveyardEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
        <br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
<br/>
            // Record the player.<br/>
            Player p = (Player)i.nextElement();<br/>
            sb.append("++++++++++ " )<br/>
                .append( p.getName() )<br/>
                .append( " ++++++++++\n");<br/>
<br/>
            // Record the player's alive, retreated, or salvageable units.<br/>
            for (int x = 0; x &lt; vAllUnits.size(); x++) {<br/>
                Entity e = (Entity)vAllUnits.elementAt(x);<br/>
                if (e.getOwner() == p) {<br/>
                    sb.append(UnitStatusFormatter.format(e));<br/>
                }<br/>
            }<br/>
<br/>
            // Record the player's devastated units.<br/>
            Enumeration devastated = game.getDevastatedEntities();<br/>
            if ( devastated.hasMoreElements() ) {<br/>
                sb.append("=============================================================\n");<br/>
                sb.append("The following utterly destroyed units are not available for salvage:\n");<br/>
                while ( devastated.hasMoreElements() ) {<br/>
                    Entity e = (Entity) devastated.nextElement();<br/>
                    if (e.getOwner() == p) {<br/>
                        sb.append( e.getShortName() )<br/>
                            .append( ", Pilot: " )<br/>
                            .append( e.getCrew().getName() )<br/>
                            .append( " (" )<br/>
                            .append( e.getCrew().getGunnery() )<br/>
                            .append( "/" )<br/>
                            .append( e.getCrew().getPiloting() )<br/>
                            .append( ")\n" );<br/>
                    }<br/>
                } // Handle the next unsalvageable unit for the player<br/>
                sb.append("=============================================================\n");<br/>
            }<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        return sb.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Forces victory at then end of the turn.<br/>
     */<br/>
    public void forceVictory() {<br/>
        forceVictory = true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when a player declares that he is "done."  Checks to see if all<br/>
     * players are done, and if so, moves on to the next phase.<br/>
     */<br/>
    private void checkReady() {<br/>
        // are there any active players?<br/>
        boolean allAboard = countActivePlayers() &gt; 0;<br/>
        // check if all active players are done<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver() &amp;&amp; !player.isDone()) {<br/>
                allAboard = false;<br/>
            }<br/>
        }<br/>
        // need at least one entity in the game for the lounge phase to end<br/>
        if (allAboard &amp;&amp; !game.phaseHasTurns(game.phase)<br/>
        &amp;&amp; (game.phase != Game.PHASE_LOUNGE || game.getNoOfEntities() &gt; 0)) {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when the current player has done his current turn and the turn<br/>
     * counter needs to be advanced.<br/>
     */<br/>
    private void endCurrentTurn() {<br/>
        changeToNextTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.phase = phase;<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
        <br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
            <br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                mapSettings.setBoardsAvailableVector(scanForBoards(mapSettings.getBoardWidth(), mapSettings.getBoardHeight()));<br/>
                mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
                // remove the last traces of last round<br/>
                attacks.removeAllElements();<br/>
                roundReport = new StringBuffer();<br/>
                resetEntityRound();<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                // roll 'em<br/>
                resetActivePlayersDone();<br/>
                rollInitiative();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder();<br/>
                writeInitiativeReport();<br/>
                send(createReportPacket());<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder();<br/>
                resetActivePlayersDone();<br/>
                //send(createEntitiesPacket());<br/>
                entityAllUpdate();<br/>
                phaseReport = new StringBuffer();<br/>
                break;<br/>
            case Game.PHASE_END :<br/>
                phaseReport = new StringBuffer();<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                resolveHeat();<br/>
                checkForSuffocation();<br/>
                resolveCrewDamage();<br/>
                resolveCrewWakeUp();<br/>
                resolveFire();<br/>
                autoSave();<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                }<br/>
                log.append( "\n" );<br/>
                log.append( roundReport.toString() );<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
                resetActivePlayersDone();<br/>
                send(createReportPacket());<br/>
                break;<br/>
            case Game.PHASE_VICTORY :<br/>
                prepareVictoryReport();<br/>
                send(createReportPacket());<br/>
                send(createEndOfGamePacket());<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Should we play this phase or skip it?  The only phases we'll skip<br/>
     * are the firing or the physical phase if no entities are eligible.<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                return areMoreTurns();<br/>
            default :<br/>
                return true;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_EXCHANGE :<br/>
                resetPlayersDone();<br/>
                applyBoardSettings();<br/>
                game.setHasDeployed(false);<br/>
                game.determineWindDirection();<br/>
                // If we add transporters for any Magnetic Clamp<br/>
                // equiped squads, then update the clients' entities.<br/>
                if ( game.checkForMagneticClamp() ) {<br/>
                    send(createEntitiesPacket());<br/>
                }<br/>
                // transmit the board to everybody<br/>
                send(createBoardPacket());<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                // set turn<br/>
                turnIndex = 0;<br/>
                changeToNextTurn();<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                changePhase(Game.PHASE_EXCHANGE);<br/>
                break;<br/>
            case Game.PHASE_EXCHANGE :<br/>
                changePhase(Game.PHASE_INITIATIVE);<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
                game.setHasDeployed(true);<br/>
                changePhase(Game.PHASE_INITIATIVE);<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
                if (game.hasDeployed()) {<br/>
                    changePhase(Game.PHASE_MOVEMENT);<br/>
                }<br/>
                else {<br/>
                    changePhase(Game.PHASE_DEPLOYMENT);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_MOVEMENT :<br/>
                roundReport.append("\nMovement Phase\n-------------------\n");<br/>
                addMovementHeat();<br/>
                resolveCrewDamage();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolvePilotingRolls(); // Skids cause damage in movement phase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveCrewDamage(); // again, I guess<br/>
                checkForFlamingDeath();<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                    changePhase(Game.PHASE_MOVEMENT_REPORT);<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                    changePhase(Game.PHASE_FIRING);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
                changePhase(Game.PHASE_FIRING);<br/>
                break;<br/>
            case Game.PHASE_FIRING :<br/>
                assignAMS();<br/>
                resolveWeaponAttacks();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                    changePhase(Game.PHASE_FIRING_REPORT);<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                    changePhase(Game.PHASE_PHYSICAL);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
                changePhase(Game.PHASE_PHYSICAL);<br/>
                break;<br/>
            case Game.PHASE_PHYSICAL :<br/>
                resolvePhysicalAttacks();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                }<br/>
                changePhase(Game.PHASE_END);<br/>
                break;<br/>
            case Game.PHASE_END :<br/>
                if (victory()) {<br/>
                    changePhase(Game.PHASE_VICTORY);<br/>
                } else {<br/>
                    changePhase(Game.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_VICTORY :<br/>
                forceVictory = false;<br/>
                resetGame();<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Tries to change to the next turn.  If there are no more turns, ends the<br/>
     * current phase.  If the player whose turn it is next is not connected,<br/>
     * we skip that player.<br/>
     */<br/>
    private void changeToNextTurn() {<br/>
        // if there aren't any more turns, end the phase<br/>
        if (!areMoreTurns()) {<br/>
            endCurrentPhase();<br/>
            return;<br/>
        }<br/>
        GameTurn nextTurn = nextTurn();<br/>
        if (getPlayer(nextTurn.getPlayerNum()).isGhost()) {<br/>
            changeToNextTurn();<br/>
            return;<br/>
        }<br/>
        changeTurn(nextTurn);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Changes it to make it the specified player's turn.<br/>
     */<br/>
    private void changeTurn(GameTurn turn) {<br/>
        final Player player = getPlayer(turn.getPlayerNum());<br/>
        game.setTurn(turn);<br/>
        if (player != null) {<br/>
            player.setDone(false);<br/>
        }<br/>
        send(new Packet(Packet.COMMAND_TURN, turn));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns true if victory conditions have been met.  Victory conditions<br/>
     * are when there is only one player left with mechs or only one team.<br/>
     */<br/>
    public boolean victory() {<br/>
        if (forceVictory) {<br/>
            return true;<br/>
        }<br/>
        <br/>
        if (!game.getOptions().booleanOption("check_victory")) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        // is there only one player left with mechs?<br/>
        int playersAlive = 0;<br/>
        int teamsAlive = 0;<br/>
        boolean teamKnownAlive[] = new boolean[Player.MAX_TEAMS];<br/>
        boolean unteamedAlive = false;<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements();) {<br/>
            Player player = (Player)e.nextElement();<br/>
            int team = player.getTeam();<br/>
            if (game.getLiveEntitiesOwnedBy(player) &gt; 0) {<br/>
                playersAlive++;<br/>
                if (team == Player.TEAM_NONE) {<br/>
                    unteamedAlive = true;<br/>
                } else if (!teamKnownAlive[team]) {<br/>
                    teamsAlive++;<br/>
                    teamKnownAlive[team] = true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return playersAlive &lt;= 1 || (teamsAlive == 1 &amp;&amp; !unteamedAlive);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Applies board settings.  This loads and combines all the boards that<br/>
     * were specified into one mega-board and sets that board as current.<br/>
     */<br/>
    public void applyBoardSettings() {<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);<br/>
        Board[] sheetBoards = new Board[mapSettings.getMapWidth() * mapSettings.getMapHeight()];<br/>
        for (int i = 0; i &lt; mapSettings.getMapWidth() * mapSettings.getMapHeight(); i++) {<br/>
            sheetBoards[i] = new Board();<br/>
            String name = (String)mapSettings.getBoardsSelectedVector().elementAt(i);<br/>
            boolean isRotated = false;<br/>
            if ( name.startsWith( Board.BOARD_REQUEST_ROTATION ) ) {<br/>
                isRotated = true;<br/>
                name = name.substring( Board.BOARD_REQUEST_ROTATION.length() );<br/>
            }<br/>
            sheetBoards[i].load( name + ".board");<br/>
            sheetBoards[i].flip( isRotated, isRotated );<br/>
        }<br/>
        game.board.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(),<br/>
        mapSettings.getMapWidth(), mapSettings.getMapHeight(), sheetBoards);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deploys an entity near a selected point on the board.<br/>
     *<br/>
     * @param entity the entity to deploy<br/>
     * @param pos the point to deploy near<br/>
     * @param towards another point that the deployed mechs will face towards<br/>
     */<br/>
    private boolean deploy(Entity entity, Coords pos, Coords towards, int recurse) {<br/>
        if (game.board.contains(pos) &amp;&amp; game.getFirstEntity(pos) == null<br/>
        &amp;&amp; !entity.isHexProhibited(game.board.getHex(pos))) {<br/>
            placeEntity(entity, pos, pos.direction(towards));<br/>
            return true;<br/>
        }<br/>
        <br/>
        // if pos is filled, try some different positions<br/>
        for (int j = 0; j &lt; recurse; j++) {<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                Coords deployPos = pos.translated(i);<br/>
                if (deploy(entity, deployPos, towards, j)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return false;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Places a mech on the board<br/>
     */<br/>
    private void placeEntity(Entity entity, Coords pos, int facing) {<br/>
        entity.setPosition(pos);<br/>
        entity.setFacing(facing);<br/>
        entity.setSecondaryFacing(facing);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the starting point for the specified player<br/>
     */<br/>
    private Coords getStartingCoords(int startingPos) {<br/>
        switch (startingPos) {<br/>
            default :<br/>
            case 0 :<br/>
                return new Coords(1, 1);<br/>
            case 1 :<br/>
                return new Coords(game.board.width / 2, 1);<br/>
            case 2 :<br/>
                return new Coords(game.board.width - 2, 1);<br/>
            case 3 :<br/>
                return new Coords(game.board.width - 2, game.board.height / 2);<br/>
            case 4 :<br/>
                return new Coords(game.board.width - 2, game.board.height - 2);<br/>
            case 5 :<br/>
                return new Coords(game.board.width / 2, game.board.height - 2);<br/>
            case 6 :<br/>
                return new Coords(1, game.board.height - 2);<br/>
            case 7 :<br/>
                return new Coords(1, game.board.height / 2);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        roundCounter++;<br/>
        <br/>
        // roll the dice for each player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.getInitiative().clear();<br/>
        }<br/>
        <br/>
        // roll off all ties<br/>
        resolveInitTies(game.getPlayersVector());<br/>
        <br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
    <br/>
    /**<br/>
     * This goes thru and adds a roll on to the end of the intiative "stack"<br/>
     * for all players involved.  Then it checks the list again for ties, and<br/>
     * recursively resolves all further ties.<br/>
     */<br/>
    private void resolveInitTies(Vector players) {<br/>
        // add a roll for all players<br/>
        for (Enumeration i = players.elements(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.getInitiative().addRoll();<br/>
        }<br/>
        // check for further ties<br/>
        Vector ties = new Vector();<br/>
        for (Enumeration i = players.elements(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            ties.removeAllElements();<br/>
            ties.addElement(player);<br/>
            for (Enumeration j = game.getPlayers(); j.hasMoreElements();) {<br/>
                final Player other = (Player)j.nextElement();<br/>
                if (player != other &amp;&amp; player.getInitiative().equals(other.getInitiative())) {<br/>
                    ties.addElement(other);<br/>
                }<br/>
            }<br/>
            if (ties.size() &gt; 1) {<br/>
                resolveInitTies(ties);<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Determine turn order by number of entities that are selectable this phase<br/>
     *<br/>
     * TODO: this is a real mess<br/>
     */<br/>
    private void determineTurnOrder() {<br/>
        // sort players<br/>
        com.sun.java.util.collections.ArrayList plist = new com.sun.java.util.collections.ArrayList(game.getNoOfPlayers());<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            plist.add(player);<br/>
        }<br/>
        com.sun.java.util.collections.Collections.sort(plist, new com.sun.java.util.collections.Comparator() {<br/>
            public int compare(Object o1, Object o2) {<br/>
                return ((Player)o1).getInitiative().compareTo(((Player)o2).getInitiative());<br/>
            }<br/>
        });<br/>
        <br/>
        // determine turn order<br/>
        int[] order = new int[game.getNoOfPlayers()];<br/>
        int oi = 0;<br/>
        for (com.sun.java.util.collections.Iterator i = plist.iterator(); i.hasNext();) {<br/>
            final Player player = (Player)i.next();<br/>
            order[oi++] = player.getId();<br/>
        }<br/>
        <br/>
        // count how many entities each player controls, and how many turns we have to assign<br/>
        int MAX_PLAYERS = 255; //XXX HACK HACK HACK!<br/>
        int[] noe = new int[MAX_PLAYERS];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int playerId = 0;<br/>
        int noOfTurns = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int[] noi = new int[MAX_PLAYERS]; // The number of Infantry for player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int noOfInfTurns = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infLast = game.getOptions().booleanOption("inf_move_last");<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            if (entity.isSelectable()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerId = entity.getOwner().getId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Special handling for infantry for certain game options.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    noi[playerId]++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If multiple Infantry move per Mek and Vehicle and this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // is NOT the start of a new block of infantry for the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // player do NOT add a turn.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMulti &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 != (noi[playerId] % Game.INF_MOVE_MULTI) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If Infantry move after Meks and Vehicles, we'll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // delay calculating the infantry turns.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else if ( infLast ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noOfInfTurns++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                noe[playerId]++;<br/>
                noOfTurns++;<br/>
            }<br/>
        }<br/>
        <br/>
        // generate turn list<br/>
        turns.setSize(noOfTurns + noOfInfTurns);<br/>
        turnIndex = 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle all "mainline entities".  I.E. Meks, Vehicles, and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// (unless overrided by the "inf_move_last" option) Infantry.<br/>
        while (turnIndex &lt; noOfTurns) {<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoe = 1;<br/>
            int lnoe = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                if (noe[i] &gt; 0 &amp;&amp; noe[i] &lt; lnoe) {<br/>
                    lnoe = noe[i];<br/>
                }<br/>
                if (noe[i] &gt; hnoe) {<br/>
                    hnoe = noe[i];<br/>
                }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noe[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                /* if you have less than twice the next lowest,<br/>
                 * move 1, otherwise, move more.<br/>
                 * if you have less than half the maximum,<br/>
                 * move none<br/>
                 */<br/>
                int ntm = Math.max(1, (int)Math.floor(noe[order[i]] / lnoe));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns.setElementAt(new GameTurn(order[i]), turnIndex);<br/>
                    turnIndex++;<br/>
                    noe[order[i]]--;<br/>
                }<br/>
            }<br/>
        } // Handle the next "mainline entity"<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Now handle all Infantry (the "inf_move_last" option must be on).<br/>
        while (turnIndex &lt; turns.size()) {<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoi = 1;<br/>
            int lnoi = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                if (noi[i] &gt; 0 &amp;&amp; noi[i] &lt; lnoi) {<br/>
                    lnoi = noi[i];<br/>
                }<br/>
                if (noi[i] &gt; hnoi) {<br/>
                    hnoi = noi[i];<br/>
                }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noi[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                /* if you have less than twice the next lowest,<br/>
                 * move 1, otherwise, move more.<br/>
                 * if you have less than half the maximum,<br/>
                 * move none<br/>
                 */<br/>
                int ntm = Math.max(1, (int)Math.floor(noi[order[i]] / lnoi));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns.setElementAt(new GameTurn(order[i]), turnIndex);<br/>
                    turnIndex++;<br/>
                    noi[order[i]]--;<br/>
                }<br/>
            }<br/>
        } // Handle the next infantry platoon<br/>
<br/>
        // reset turn counters<br/>
        turnIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = -1;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport() {<br/>
        // write to report<br/>
        if (game.hasDeployed()) {<br/>
            roundReport.append("\nInitiative Phase for Round #").append(roundCounter);<br/>
        }<br/>
        else {<br/>
            roundReport.append("\nInitiative Phase for Deployment");<br/>
        }<br/>
        roundReport.append("\n------------------------------\n");<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            roundReport.append(player.getName() ).append( " rolls a ");<br/>
            for (int j = 0; j &lt; player.getInitiative().size(); j++) {<br/>
                if (j != 0) {<br/>
                    roundReport.append(" / ");<br/>
                }<br/>
                roundReport.append(player.getInitiative().getRoll(j));<br/>
            }<br/>
            roundReport.append(".\n");<br/>
        }<br/>
        roundReport.append("\nThe turn order is:\n  ");<br/>
        boolean firstTurn = true;<br/>
        for (Enumeration i = turns.elements(); i.hasMoreElements();) {<br/>
            GameTurn turn = (GameTurn)i.nextElement();<br/>
            roundReport.append((firstTurn ? "" : ", ") ).append( getPlayer(turn.getPlayerNum()).getName());<br/>
            firstTurn = false;<br/>
        }<br/>
        roundReport.append("\n\n");<br/>
        roundReport.append("  Wind direction is "+game.getStringWindDirection()+"\n");<br/>
        <br/>
        // reset turn index<br/>
        turnIndex = 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            if (!isEligibleFor(entity, phase)) {<br/>
                entity.setDone(true);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if an entity is eligible for a phase.<br/>
     */<br/>
    private boolean isEligibleFor(Entity entity, int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_FIRING :<br/>
                return isEligibleForFiring(entity, phase);<br/>
            case Game.PHASE_PHYSICAL :<br/>
                if (entity instanceof Mech) {<br/>
                    return isEligibleForPhysical(entity, phase);<br/>
                }<br/>
                else {<br/>
                    return false;<br/>
                }<br/>
            default:<br/>
                return true;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * An entity is eligible if its to-hit number is anything but impossible.<br/>
     * This is only really an issue if friendly fire is turned off.<br/>
     */<br/>
    private boolean isEligibleForFiring(Entity entity, int phase) {<br/>
        // if you're charging, no shooting<br/>
        if (entity.isUnjammingRAC()) return false;<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        //        // check game options<br/>
        //        if (!game.getOptions().booleanOption("skip_ineligable_firing")) {<br/>
        //            return true;<br/>
        //        }<br/>
        <br/>
        // TODO: check for any weapon attacks<br/>
        <br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Check if the entity has any valid targets for physical attacks.<br/>
     */<br/>
    private boolean isEligibleForPhysical(Entity entity, int phase) {<br/>
        boolean canHit = false;<br/>
        boolean friendlyFire = game.getOptions().booleanOption("friendly_fire");<br/>
        <br/>
        // dead mek walking<br/>
        if (!entity.isActive()) return false;<br/>
        <br/>
        // if you're charging or finding a club, it's already declared<br/>
        if (entity.isUnjammingRAC()) return false;<br/>
        if (entity.isCharging() || entity.isMakingDfa() || entity.isFindingClub()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        // check game options<br/>
        if (!game.getOptions().booleanOption("skip_ineligable_physical")) {<br/>
            return true;<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity target = (Entity)e.nextElement();<br/>
            <br/>
            // don't shoot at friendlies unless you are into that sort of thing<br/>
            // and do not shoot yourself even then<br/>
            if (!(entity.isEnemyOf(target) || (friendlyFire &amp;&amp; entity.getId() != target.getId() ))) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
            PunchAttackAction.LEFT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
            PunchAttackAction.RIGHT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
            KickAttackAction.LEFT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
            KickAttackAction.RIGHT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitBrushOff<br/>
                ( game, entity.getId(), target.getId(),<br/>
                  BrushOffAttackAction.LEFT ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitBrushOff<br/>
                ( game, entity.getId(), target.getId(),<br/>
                  BrushOffAttackAction.RIGHT ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitThrash<br/>
                ( game, entity.getId(), target.getId() ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
        }<br/>
        <br/>
        return canHit;<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the loader load the indicated unit.<br/>
     * The unit being loaded loses its turn.<br/>
     *<br/>
     * @param   loader - the &lt;code&gt;Entity&lt;/code&gt; that is loading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being loaded.<br/>
     */<br/>
    private void loadUnit( Entity loader, Entity unit ) {<br/>
<br/>
        // Remove the loaded unit from the screen.<br/>
        unit.setPosition( null );<br/>
<br/>
        // Remove the *last* friendly turn (removing the *first* penalizes<br/>
        // the opponent too much, and re-calculating moves is too hard).<br/>
        for ( int index = this.turns.size() - 1;<br/>
              index &gt;= this.turnIndex; index-- ) {<br/>
<br/>
            // If the index-th turn is for the loaded unit's<br/>
            // player, remove it and stop looking.<br/>
            if ( unit.getOwnerId()  == <br/>
                 ( (GameTurn)turns.elementAt(index) ).getPlayerNum() ) {<br/>
                this.turns.removeElementAt( index );<br/>
                break;<br/>
            }<br/>
<br/>
        } // Check the next turn<br/>
<br/>
        // Load the unit.<br/>
        loader.load( unit );<br/>
<br/>
        // The loaded unit is being carried by the loader.<br/>
        unit.setTransportId( loader.getId() );<br/>
<br/>
        // Update the loaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the unloader unload the indicated unit.<br/>
     * The unit being unloaded does *not* gain a turn.<br/>
     *<br/>
     * @param   unloader - the &lt;code&gt;Entity&lt;/code&gt; that is unloading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being unloaded.<br/>
     * @param   pos - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if the unit isn't carried in unloader.<br/>
     */<br/>
    private boolean unloadUnit( Entity unloader, Entity unit,<br/>
                             Coords pos, int facing ) {<br/>
<br/>
        // Unload the unit.<br/>
        if ( !unloader.unload( unit ) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The unloaded unit is no longer being carried.<br/>
        unit.setTransportId( Entity.NONE );<br/>
<br/>
        // Place the unloaded unit onto the screen.<br/>
        unit.setPosition( pos );<br/>
<br/>
        // Point the unloaded unit in the given direction.<br/>
        unit.setFacing( facing );<br/>
        unit.setSecondaryFacing( facing );<br/>
<br/>
        // Update the unloaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
<br/>
        // Unloaded successfully.<br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receives an entity movement packet, and if valid, executes it and ends<br/>
     * the current turn.<br/>
     */<br/>
    private void receiveMovement(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        MovementData md = (MovementData)packet.getObject(1);<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_MOVEMENT) {<br/>
            System.err.println("error: server got movement packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)) {<br/>
            System.err.println("error: server got invalid movement packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processMovement(entity, md);<br/>
        endCurrentTurn();<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps thru an entity movement packet, executing it.<br/>
     */<br/>
    private void processMovement(Entity entity, MovementData md) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveLast = game.getOptions().booleanOption("inf_move_last");<br/>
<br/>
        // Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If "inf_move_mutli" option is selected, and we're in the middle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// of a block of Infantry moves, entity had better be an Infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// platoon owned by the most recent player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( infMoveMulti &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;     ( !(entity instanceof Infantry) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;       entity.getOwnerId() != turnLastPlayerId ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If "inf_move_last" option is selected, player can't move<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// a Mek or Vehicle after Infantry have started to move.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( infMoveLast &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  !(entity instanceof Infantry) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// check for fleeing<br/>
        if (md.contains(MovementData.STEP_FLEE)) {<br/>
            // Unit has fled the battlefield.<br/>
            phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
            ).append( " flees the battlefield.\n");<br/>
            // Is the unit carrying passengers?<br/>
            final Vector passengers = entity.getLoadedUnits();<br/>
            if ( !passengers.isEmpty() ) {<br/>
                final Enumeration iter = passengers.elements();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    final Entity passenger = (Entity) iter.nextElement();<br/>
                    // Unit has fled the battlefield.<br/>
                    phaseReport.append( "   It carries " )<br/>
                        .append( passenger.getDisplayName() )<br/>
                        .append( " with it.\n" );<br/>
                    game.removeEntity( passenger.getId(),<br/>
                                       Game.UNIT_IN_RETREAT );<br/>
                    send( createRemoveEntityPacket(passenger.getId(),<br/>
                                                   Game.UNIT_IN_RETREAT) );<br/>
                }<br/>
            }<br/>
            // Is the unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                // Unit has fled the battlefield.<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                phaseReport.append( "   It takes " )<br/>
                    .append( swarmer.getDisplayName() )<br/>
                    .append( " with it.\n" );<br/>
                game.removeEntity( swarmerId, Game.UNIT_IN_RETREAT );<br/>
                send( createRemoveEntityPacket(swarmerId,<br/>
                                               Game.UNIT_IN_RETREAT) );<br/>
            }<br/>
            <br/>
            game.removeEntity( entity.getId(), Game.UNIT_IN_RETREAT );<br/>
            send( createRemoveEntityPacket(entity.getId(),<br/>
                                           Game.UNIT_IN_RETREAT) );<br/>
            return;<br/>
        }<br/>
        <br/>
        // check for MASC failure<br/>
        if (entity instanceof Mech) {<br/>
            if (((Mech)entity).checkForMASCFailure(phaseReport)) {<br/>
                // no movement after that<br/>
                return;<br/>
            }<br/>
        }<br/>
                <br/>
        <br/>
        // okay, proceed with movement calculations<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int distance = 0;<br/>
        int mpUsed = 0;<br/>
        int moveType = Entity.MOVE_NONE;<br/>
        int overallMoveType = Entity.MOVE_NONE;<br/>
        boolean firstStep;<br/>
        boolean wasProne;<br/>
        boolean fellDuringMovement;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int prevFacing = curFacing;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Hex prevHex = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;final boolean isInfantry = (entity instanceof Infantry);<br/>
        <br/>
        // Compile the move<br/>
        Compute.compile(game, entity.getId(), md);<br/>
        <br/>
        // get last step's movement type<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            } else {<br/>
                overallMoveType = step.getMovementType();<br/>
            }<br/>
        }<br/>
        <br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        fellDuringMovement = false;<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            wasProne = entity.isProne();<br/>
            <br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
            <br/>
            // check piloting skill for getting up<br/>
            if (step.getType() == MovementData.STEP_GET_UP) {<br/>
                entity.heatBuildup += 1;<br/>
                entity.setProne(false);<br/>
                wasProne = false;<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "getting up"), true);<br/>
            } else if (firstStep) {<br/>
                // running with destroyed hip or gyro needs a check<br/>
                if (overallMoveType == Entity.MOVE_RUN &amp;&amp; !entity.isProne()<br/>
                &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                || entity.hasHipCrit())) {<br/>
                    doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "running with damaged hip actuator or gyro"), false);<br/>
                }<br/>
                firstStep = false;<br/>
            }<br/>
            <br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                moveType = step.getMovementType();<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
             <br/>
            if (step.getType() == MovementData.STEP_UNJAM_RAC) {<br/>
                entity.setUnjammingRAC(true);<br/>
                attacks.addElement(new UnjamAction(entity.getId()));<br/>
<br/>
                break;<br/>
            }<br/>
<br/>
            // set most step parameters<br/>
            moveType = step.getMovementType();<br/>
            distance = step.getDistance();<br/>
            mpUsed = step.getMpUsed();<br/>
<br/>
            // check for charge<br/>
            if (step.getType() == MovementData.STEP_CHARGE) {<br/>
                Entity target = step.getTarget( game );<br/>
                ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getId(), target.getPosition());<br/>
                entity.setDisplacementAttack(caa);<br/>
                pendingCharges.addElement(caa);<br/>
                break;<br/>
            }<br/>
            <br/>
            // check for dfa<br/>
            if (step.getType() == MovementData.STEP_DFA) {<br/>
                Entity target = step.getTarget( game );<br/>
                DfaAttackAction daa = new DfaAttackAction(entity.getId(), target.getId(), target.getPosition());<br/>
                entity.setDisplacementAttack(daa);<br/>
                pendingCharges.addElement(daa);<br/>
                break;<br/>
            }<br/>
<br/>
            // set last step parameters<br/>
            curPos = step.getPosition();<br/>
            curFacing = step.getFacing();<br/>
<br/>
            final Hex curHex = game.board.getHex(curPos);<br/>
<br/>
            // Check for skid.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( moveType != Entity.MOVE_JUMP<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevHex != null<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevHex.contains(Terrain.PAVEMENT)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; overallMoveType == Entity.MOVE_RUN<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevFacing != curFacing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !lastPos.equals(curPos)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !isInfantry ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Have an entity-meaningful PSR message.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PilotingRollData psr = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    psr = new PilotingRollData<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(entity.getId(), getMovementPSRModifier(distance),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "running &amp; turning on pavement", true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    psr = new PilotingRollData<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(entity.getId(), getMovementPSRModifier(distance),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "reckless driving on pavement", true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the entity skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !doSkillCheckWhileMoving(entity, lastPos, lastPos, psr) ){<br/>
<br/>
                    curPos = lastPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Coords nextPos = curPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Hex    nextHex = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    skidDistance = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Enumeration targets = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Entity target = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    curElevation;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    nextElevation;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // All charge damage is based upon<br/>
                    // the pre-skid move distance.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.delta_distance = distance-1;<br/>
<br/>
                    // BUG: all attacks against a skidding target are at +2,<br/>
                    //          and are *NOT* based upon distance moved at all.<br/>
                    // TODO: add Entity.MOVE_SKID constant and update the<br/>
                    //          Compute#getTargetMovementModifier methods.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // What is the first hex in the skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos = curPos.translated( prevFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextHex = game.board.getHex( nextPos );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Move the entity a number hexes from curPos in the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // prevFacing direction equal to half the distance moved<br/>
                    // this turn (rounded up), unless something intervenes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for ( skidDistance = 0;<br/>
                          skidDistance &lt; (int) Math.ceil(entity.delta_distance / 2.0); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  skidDistance++ ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Is the next hex off the board?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !game.board.contains(nextPos) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Can the entity skid off the map?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( game.getOptions().booleanOption("push_off_board") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  One dead entity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.removeEntity(entity.getId(),<br/>
                                                  Game.UNIT_IN_RETREAT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(entity.getId(),<br/>
                                                              Game.UNIT_IN_RETREAT));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("*** " ).append( entity.getDisplayName() ).append( " has skidded off the field. ***\n");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nope.  Update the report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Can't skid off the field.\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Can the skiding entity enter the hex?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity.isHexProhibited(nextHex) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "   Can't skid into hex " ).append( <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: inflict any damage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
                        // BMRr pg. 22 - Can't skid uphill,<br/>
                        //      but can skid downhill.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curElevation = game.board.getHex(curPos).floor();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextElevation = nextHex.floor();<br/>
                        // Hovercraft can "skid" over water.<br/>
                        if ( entity instanceof Tank &amp;&amp;<br/>
                             entity.getMovementType() ==<br/>
                             Entity.MovementType.HOVER ) {<br/>
                            Terrain land = game.board.getHex(curPos).<br/>
                                getTerrain(Terrain.WATER);<br/>
                            if ( land != null ) {<br/>
                                curElevation += land.getLevel();<br/>
                            }<br/>
                            land = nextHex.getTerrain(Terrain.WATER);<br/>
                            if ( land != null ) {<br/>
                                nextElevation += land.getLevel();<br/>
                            }<br/>
                        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( curElevation &lt; nextElevation ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append<br/>
                                ( "   Can not skid uphill into hex " +<br/>
                                  nextPos.getBoardNum() ).append( ".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the next hex contain an entities?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean stopTheSkid = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets = game.getEntities( nextPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( targets.hasMoreElements() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target = (Entity) targets.nextElement();<br/>
<br/>
                            // TODO : allow ready targets to move out of way<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO : Handle targets in buildings.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Mechs and vehicles get charged.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !(target instanceof Infantry) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids into " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    " in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    "... " );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Resolve a charge against the target.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ToHitData toHit = new ToHitData();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toHit.setHitTable( target.isProne() ? <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ToHitData.HIT_NORMAL :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ToHitData.HIT_KICK );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toHit.setSideTable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (Compute.targetSideTable(entity, target));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveChargeDamage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (entity, target, toHit, prevFacing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The skid ends here if the target lives.<br/>
                                // TODO : do we keep skiding if the target<br/>
                                //      is pushed off the board?<br/>
                                if ( !target.isDoomed() &amp;&amp;<br/>
                                     !target.isDestroyed() ) {<br/>
                                    stopTheSkid = true;<br/>
                                }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Resolve "move-through" damage on infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids through " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    " in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    "... " );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry don't have different<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tables for punches and kicks<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HitData hit = target.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Compute.targetSideTable(entity, target)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Damage equals tonnage, divided by 5.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( damageEntity(target, hit, (int)Math.round(entity.getWeight()/5)) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // End handle-infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Has the target been destroyed?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( target.isDoomed() ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Has the target taken a turn?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !target.isDone() ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Dead entities don't take turns.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int targetOwnerId = target.getOwner().getId();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for ( int loop = turnIndex + 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  loop &lt; turns.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  loop++ ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Is the loop-th turn for the <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// destroyed target's player?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( targetOwnerId == ( (GameTurn)turns.elementAt(loop) ).getPlayerNum() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Yup. Remove the turn and stop looping.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turns.removeElementAt( loop );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // Check the next turn<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End target-still-to-move<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  Clean out the entity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.setDestroyed(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.moveToGraveyard(target.getId());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(target.getId()));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the target's position,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // unless it is off the game map.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !game.isInGraveyard(target) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityUpdate( target.getId() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End someone's-in-the-way<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do we stay in the current hex and stop skidding?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( stopTheSkid ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Did we skid into a building?<br/>
                        // TODO : BMRr pg. 22, only count buildings that are<br/>
                        //      higher than our starting terrain height.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( nextHex.contains(Terrain.BUILDING) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "   Skids into building in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO : Damage the building and the skidding entity.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Skid into the building's hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = nextPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.setPosition( curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update the position and keep skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curPos = nextPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setPosition( curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids into hex " ).append( <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos.getBoardNum() ).append( ".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the next hex in the skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos = nextPos.translated( prevFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextHex = game.board.getHex( nextPos );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // Handle the next skid hex.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If the skidding entity violates stacking,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // displace targets until it doesn't.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = entity.getPosition();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target = Compute.stackingViolation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(game, entity.getId(), curPos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    while (target != null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos = Compute.getValidDisplacement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (game, target.getId(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     target.getPosition(), prevFacing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ASSUMPTION<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// There should always be *somewhere* that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the target can go... last skid hex if<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// nothing else is available.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( null == nextPos ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // But I don't trust the assumption fully.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Report the error and try to continue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    System.err.println( "The skid of " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" should displace " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" but there is nowhere to go."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "    " ); // indent displacement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doEntityDisplacement(target, curPos, nextPos, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = Compute.stackingViolation( game, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.getId(), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Mechs suffer damage for every hex skidded.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate one half falling damage times skid length.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// report skid damage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("    " ).append( entity.getDisplayName() ).append( " suffers " ).append( damage ).append( " damage from the skid.");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// standard damage loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All skid damage is to the front.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (damage &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int cluster = Math.min(5, damage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append(damageEntity(entity, hit, cluster));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    damage -= cluster;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Clean up the entity if it has been destroyed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity.isDoomed() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setDestroyed(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.moveToGraveyard(entity.getId());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(entity.getId()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Let the player know the ordeal is over.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "      Skid ends.\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // set entity parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curFacing = entity.getFacing();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = entity.getPosition();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.setSecondaryFacing( curFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    mpUsed = entity.getRunMP(); // skid consumes all movement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.moved = moveType;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    fellDuringMovement = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            }<br/>
<br/>
            // check if we've moved into rubble<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; curHex.levelOf(Terrain.RUBBLE) &gt; 0) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Rubble"));<br/>
            }<br/>
            <br/>
            // check to see if we've moved OUT of fire and we are a mech<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; game.board.getHex(lastPos).contains(Terrain.FIRE)) {<br/>
                if (entity instanceof Mech) {<br/>
                    entity.heatBuildup+=2;<br/>
                    phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
                    ).append( " passes through a fire.  It will generate 2 more heat this round.\n");<br/>
                }<br/>
            }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
            <br/>
            // check to see if we've moved INTO fire and we are not a mech<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; game.board.getHex(curPos).contains(Terrain.FIRE)) {<br/>
                if (!(entity instanceof Mech)) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
            }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
            // check if we've moved into water<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; curHex.levelOf(Terrain.WATER) &gt; 0<br/>
            &amp;&amp; entity.getMovementType() != Entity.MovementType.HOVER) {<br/>
                if (curHex.levelOf(Terrain.WATER) == 1) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"));<br/>
                } else if (curHex.levelOf(Terrain.WATER) == 2) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"));<br/>
                    // Any swarming infantry will be destroyed.<br/>
                    final int swarmerId = entity.getSwarmAttackerId();<br/>
                    if ( Entity.NONE != swarmerId ) {<br/>
                        final Entity swarmer = game.getEntity( swarmerId );<br/>
                        swarmer.setSwarmTargetId( Entity.NONE );<br/>
                        entity.setSwarmAttackerId( Entity.NONE );<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append( "   The swarming unit, " )<br/>
                            .append( swarmer.getShortName() )<br/>
                            .append( ", drowns!\n" )<br/>
                            .append( destroyEntity(swarmer,<br/>
                                                   "a watery grave", false) );<br/>
                        entityUpdate( swarmerId );<br/>
                    }<br/>
                } else {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"));<br/>
                    // Any swarming infantry will be destroyed.<br/>
                    final int swarmerId = entity.getSwarmAttackerId();<br/>
                    if ( Entity.NONE != swarmerId ) {<br/>
                        final Entity swarmer = game.getEntity( swarmerId );<br/>
                        swarmer.setSwarmTargetId( Entity.NONE );<br/>
                        entity.setSwarmAttackerId( Entity.NONE );<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append( "   The swarming unit, " )<br/>
                            .append( swarmer.getShortName() )<br/>
                            .append( ", drowns!\n" )<br/>
                            .append( destroyEntity(swarmer,<br/>
                                                   "a watery grave", false) );<br/>
                        entityUpdate( swarmerId );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mech on fire with infernos can wash them off.<br/>
                // Check if enterning depth 2 water or prone in depth 1.<br/>
                if ( entity instanceof Mech &amp;&amp;<br/>
                     entity.infernos.isStillBurning() ) {<br/>
                    if ( ( 1 == curHex.levelOf(Terrain.WATER) &amp;&amp;<br/>
                           entity.isProne() ) ||<br/>
                         ( 2 &lt;= curHex.levelOf(Terrain.WATER) ) ) {<br/>
<br/>
                        // Wash off inferno from mech and add one to hex.<br/>
                        game.board.addInfernoTo<br/>
                            ( curPos, InfernoTracker.STANDARD_ROUND, 1 );<br/>
                        entity.infernos.clear();<br/>
<br/>
                        // start a fire in the hex<br/>
                        phaseReport.append( " Inferno removed from " )<br/>
                            .append( entity.getDisplayName() )<br/>
                            .append( " and fire started in hex!\n" );<br/>
                        curHex.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
                        sendChangedHex(curPos);<br/>
                    }<br/>
                }<br/>
<br/>
            }<br/>
<br/>
            // Handle loading units.<br/>
            if ( step.getType() == MovementData.STEP_LOAD ) {<br/>
<br/>
                // Find the unit being loaded.<br/>
                Entity loaded = null;<br/>
                Enumeration entities = game.getEntities( curPos );<br/>
                while ( entities.hasMoreElements() ) {<br/>
<br/>
                    // Is the other unit friendly and not the current entity?<br/>
                    loaded = (Entity)entities.nextElement();<br/>
                    if ( entity.getOwner() == loaded.getOwner() &amp;&amp;<br/>
                         !entity.equals(loaded) ) {<br/>
<br/>
                        // The moving unit should be able to load the other<br/>
                        // unit and the other should be able to have a turn.<br/>
                        if ( !entity.canLoad(loaded) ||<br/>
                             !loaded.isSelectable() ) {<br/>
                            // Something is fishy in Denmark.<br/>
                            System.err.println( entity.getShortName() +<br/>
                                                " can not load " +<br/>
                                                loaded.getShortName() );<br/>
                            loaded = null;<br/>
                        }<br/>
                        else {<br/>
                            // Have the deployed unit load the indicated unit.<br/>
                            this.loadUnit( entity, loaded );<br/>
<br/>
                            // Stop looking.<br/>
                            break;<br/>
                        }<br/>
<br/>
                    } else {<br/>
                        // Nope. Discard it.<br/>
                        loaded = null;<br/>
                    }<br/>
<br/>
                } // Handle the next entity in this hex.<br/>
<br/>
                // We were supposed to find someone to load.<br/>
                if ( loaded == null ) {<br/>
                    System.err.println( "Could not find unit for " +<br/>
                                        entity.getShortName() +<br/>
                                        " to load in " + curPos );<br/>
                }<br/>
<br/>
            } // End STEP_LOAD<br/>
<br/>
            // Handle unloading units.<br/>
            if ( step.getType() == MovementData.STEP_UNLOAD ) {<br/>
                Entity unloaded = step.getTarget( game );<br/>
                if ( !this.unloadUnit( entity, unloaded,<br/>
                                       curPos, curFacing ) ) {<br/>
                    System.err.println( "Error! Server was told to unload " +<br/>
                                        unloaded.getShortName() +<br/>
                                        " from " + entity.getShortName() +<br/>
                                        " into " + curPos.getBoardNum() );<br/>
                }<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
            <br/>
            // update lastPos, prevFacing &amp; prevHex<br/>
            lastPos = new Coords(curPos);<br/>
            if (!curHex.equals(prevHex)) {<br/>
                prevFacing = curFacing;<br/>
            }<br/>
            prevHex = curHex;<br/>
        }<br/>
        <br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
        entity.mpUsed = mpUsed;<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == Entity.MOVE_JUMP &amp;&amp; !entity.isMakingDfa()) {<br/>
            // check for damaged criticals<br/>
            if (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0 || entity.hasLegActuatorCrit()) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "landing with damaged leg actuator or gyro"), false);<br/>
            }<br/>
            // jumped into water?<br/>
            int waterLevel = game.board.getHex(curPos).levelOf(Terrain.WATER);<br/>
            if (waterLevel == 1) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"), false);<br/>
            } else if (waterLevel == 2) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"), false);<br/>
                // Any swarming infantry will be destroyed.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                if ( Entity.NONE != swarmerId ) {<br/>
                    final Entity swarmer = game.getEntity( swarmerId );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setPosition( curPos );<br/>
                    phaseReport.append( "   The swarming unit, " )<br/>
                        .append( swarmer.getShortName() )<br/>
                        .append( ", drowns!\n" )<br/>
                        .append( destroyEntity(swarmer,<br/>
                                               "a watery grave", false) );<br/>
                    entityUpdate( swarmerId );<br/>
                }<br/>
            } else if (waterLevel &gt;= 3) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"), false);<br/>
                // Any swarming infantry will be destroyed.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                if ( Entity.NONE != swarmerId ) {<br/>
                    final Entity swarmer = game.getEntity( swarmerId );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setPosition( curPos );<br/>
                    phaseReport.append( "   The swarming unit, " )<br/>
                        .append( swarmer.getShortName() )<br/>
                        .append( ", drowns!\n" )<br/>
                        .append( destroyEntity(swarmer,<br/>
                                               "a watery grave", false) );<br/>
                    entityUpdate( swarmerId );<br/>
                }<br/>
            }<br/>
<br/>
            // If the entity is being swarmed, jumping may dislodge the fleas.<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                final PilotingRollData roll =<br/>
                    Compute.getBasePilotingRoll(game, entity.getId());<br/>
<br/>
                // Add a +4 modifier.<br/>
                roll.addModifier( 4, "dislodge swarming infantry" );<br/>
<br/>
                // If the swarmer has Assault claws, give a 1 modifier.<br/>
                // We can stop looking when we find our first match.<br/>
                for ( Enumeration iter = swarmer.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        roll.addModifier( 1, "swarmer has assault claws" );<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // okay, print the info<br/>
                phaseReport.append("\n")<br/>
                    .append( entity.getDisplayName() )<br/>
                    .append( " tries to dislodge swarming infantry.\n" );<br/>
<br/>
                // roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
                                   ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
                                   ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
                if (diceRoll &lt; roll.getValue()) {<br/>
                    phaseReport.append("fails.\n");<br/>
                } else {<br/>
                    phaseReport.append("succeeds.\n");<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    // Did the infantry fall into water?<br/>
                    final Hex curHex = game.board.getHex(curPos);<br/>
                    if ( curHex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
                        // Swarming infantry die.<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append("    ")<br/>
                            .append(swarmer.getDisplayName())<br/>
                            .append(" is dislodged and drowns!")<br/>
                            .append(destroyEntity(swarmer, "a watery grave", false));<br/>
                    } else {<br/>
                        // Swarming infantry take an 11 point hit.<br/>
                        // ASSUMPTION : damage should not be doubled.<br/>
                        phaseReport.append("    ")<br/>
                            .append(swarmer.getDisplayName())<br/>
                            .append(" is dislodged and suffers 11 damage.")<br/>
                            .append( damageEntity(swarmer, <br/>
                                                  swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),<br/>
                                                  11) )<br/>
                            .append( "\n" );<br/>
                        swarmer.setPosition( curPos );<br/>
                    }<br/>
                    entityUpdate( swarmerId );<br/>
                } // End successful-PSR<br/>
<br/>
            } // End try-to-dislodge-swarmers<br/>
<br/>
        } // End entity-is-jumping<br/>
<br/>
        // should we give another turn to the entity to keep moving?<br/>
        if (fellDuringMovement &amp;&amp; entity.mpUsed &lt; entity.getRunMP() <br/>
        &amp;&amp; entity.isSelectable() &amp;&amp; !entity.isDoomed()) {<br/>
            entity.applyDamage();<br/>
            entity.setDone(false);<br/>
            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());<br/>
            turns.insertElementAt(newTurn, turnIndex);<br/>
        } else {<br/>
            entity.setDone(true);<br/>
        }<br/>
        <br/>
        // Is the entity Infantry?<br/>
        if ( entity instanceof Infantry ) {<br/>
            // Increment the counter.<br/>
            turnInfMoved++;<br/>
<br/>
            // Record the player moving the infantry.<br/>
            turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
            // Do infantry move in blocks?<br/>
            if ( infMoveMulti ) {<br/>
<br/>
                // Are we at the end of a block?<br/>
                if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
                     !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
                                // Yup.  Reset the counter.<br/>
                    turnInfMoved = 0;<br/>
                }<br/>
                else {<br/>
                                // Nope.  Decrement the turn index.<br/>
                    turnIndex--;<br/>
                }<br/>
<br/>
            } // End inf_move_multi<br/>
<br/>
        } // End entity-is-infantry<br/>
<br/>
        // If the entity is being swarmed, update the attacker's position.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            swarmer.setPosition( curPos );<br/>
            // If the hex is on fire, and the swarming infantry is<br/>
            // *not* Battle Armor, it drops off.<br/>
            if ( !(swarmer instanceof BattleArmor) &amp;&amp;<br/>
                 game.board.getHex(curPos).contains(Terrain.FIRE) ) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                phaseReport.append( "\n   " )<br/>
                    .append( swarmer.getShortName() )<br/>
                    .append( " can't stand the fire's heat and drops off.\n" );<br/>
            }<br/>
            entityUpdate( swarmerId );<br/>
        }<br/>
<br/>
        // Update the entitiy's position,<br/>
        // unless it is off the game map.<br/>
        if ( !game.isInGraveyard(entity) ) {<br/>
            entityUpdate( entity.getId() );<br/>
        }<br/>
        <br/>
        // if using double blind, update the player on new units he might see<br/>
        if (doBlind()) {<br/>
            send(entity.getOwner().getId(), createFilteredEntitiesPacket(entity.getOwner()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add heat from the movement phase<br/>
     */<br/>
    public void addMovementHeat() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            // build up heat from movement<br/>
            if (entity.moved == Entity.MOVE_WALK) {<br/>
                entity.heatBuildup += 1;<br/>
            } else if (entity.moved == Entity.MOVE_RUN) {<br/>
                entity.heatBuildup += 2;<br/>
            } else if (entity.moved == Entity.MOVE_JUMP) {<br/>
                entity.heatBuildup += Math.max(3, entity.delta_distance);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the movement phase).<br/>
     * We have a special case for getting up because quads need not roll to stand<br/>
     * if they have no damaged legs.  If a quad is short a gyro, however....<br/>
     */<br/>
    private void doSkillCheckInPlace(Entity entity, PilotingRollData reason, boolean gettingUp) {<br/>
        // non-mechs should never get here<br/>
        if (! (entity instanceof Mech) || entity.isProne()) {<br/>
            return;<br/>
        }<br/>
        <br/>
        if (gettingUp &amp;&amp; !entity.needsRollToStand() &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &lt; 2)) {<br/>
            phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " does not need to make "<br/>
            ).append( "a piloting skill check to stand up because it has all four of its legs.");<br/>
            return;<br/>
        }<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        <br/>
        // append the reason modifier<br/>
        roll.append(reason);<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
        ).append( " must make a piloting skill check (" ).append( reason.getPlainDesc() ).append( ")"<br/>
        ).append( ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
        ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
        ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFall(entity, roll);<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    /**<br/>
     * Do a piloting skill check while moving<br/>
     *<br/>
     * @return &lt;code&gt;true&lt;/code&gt; if the pilot passes the skill check.<br/>
     */<br/>
    private boolean doSkillCheckWhileMoving(Entity entity, Coords src, Coords dest,<br/>
    PilotingRollData reason) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean result = true;<br/>
<br/>
        // Non mechs should never get here, unless we're avoiding skids.<br/>
        if (! (entity instanceof Mech) &amp;&amp; !reason.isForSkid() ) {<br/>
            return result;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        boolean fallsInPlace;<br/>
        int fallElevation;<br/>
        <br/>
        // append the reason modifier<br/>
        roll.append(reason);<br/>
        <br/>
        // will the entity fall in the source or destination hex?<br/>
        if ( src.equals(dest) ) {<br/>
            fallsInPlace = true;<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
        }<br/>
        <br/>
        // how far down did it fall?<br/>
        fallElevation = Math.abs(destHex.floor() - srcHex.floor());<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
        ).append( " must make a piloting skill check"<br/>
        ).append( " while moving from hex " ).append( src.getBoardNum()<br/>
        ).append( " to hex " ).append( dest.getBoardNum()<br/>
        ).append( " (" ).append( reason.getPlainDesc() ).append( ")" ).append( ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
        ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
        ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Vehicles don't fall, they fail<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("falls.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doEntityFallsInto(entity, (fallsInPlace ? dest : src), (fallsInPlace ? src : dest), roll);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("fails.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setPosition( fallsInPlace ? src : dest );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    result = false;<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return result;<br/>
    }<br/>
    <br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int fallElevation = Math.abs(destHex.floor() - srcHex.floor());<br/>
        int direction = src.direction(dest);<br/>
        // check entity in target hex<br/>
        Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
        // check if we can fall in that hex<br/>
        if (violation != null<br/>
        &amp;&amp; !Compute.isValidDisplacement(game, violation.getId(), src, dest)) {<br/>
            // if target can't be displaced, fall in source hex.<br/>
            // NOTE: source hex should never contain a non-displacable entity<br/>
            Coords temp = dest;<br/>
            dest = src;<br/>
            src = temp;<br/>
            violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
        }<br/>
        <br/>
        // falling mech falls<br/>
        phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
        ).append( fallElevation ).append( " level(s) into hex "<br/>
        ).append( dest.getBoardNum() ).append( ".\n");<br/>
        <br/>
        // if hex was empty, deal damage and we're done<br/>
        if (violation == null) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
        <br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2) {<br/>
            // accidental death from above<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            // target gets displaced<br/>
            doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
    PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
        // Handle null hexes.<br/>
        if ( srcHex == null || destHex == null ) {<br/>
            System.err.println( "Can not displace " + entity.getShortName() +<br/>
                                " from " + src + <br/>
                                " to " + dest + "." );<br/>
        }<br/>
        int fallElevation = entity.elevationOccupied(srcHex) - entity.elevationOccupied(destHex);<br/>
        Entity violation =Compute.stackingViolation(game, entity.getId(), dest);<br/>
        <br/>
        // can't fall upwards<br/>
        if (fallElevation &lt; 0) {<br/>
            fallElevation = 0;<br/>
        }<br/>
        <br/>
        // if destination is empty, this could be easy...<br/>
        if (violation == null) {<br/>
            if (fallElevation &lt; 2) {<br/>
                // no cliff: move and roll normally<br/>
                phaseReport.append(entity.getDisplayName()<br/>
                ).append( " is displaced into hex "<br/>
                ).append( dest.getBoardNum() ).append( ".\n");<br/>
                entity.setPosition(dest);<br/>
                if (roll != null) {<br/>
                    pilotRolls.addElement(roll);<br/>
                }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update the entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityUpdate( entity.getId() );<br/>
                return;<br/>
            } else {<br/>
                // cliff: fall off it, deal damage, prone immediately<br/>
                phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
                ).append( fallElevation ).append( " levels into hex "<br/>
                ).append( dest.getBoardNum() ).append( ".\n");<br/>
                // only given a modifier, so flesh out into a full piloting roll<br/>
                PilotingRollData pilotRoll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
                if (roll != null) {<br/>
                    pilotRoll.append(roll);<br/>
                }<br/>
                doEntityFall(entity, dest, fallElevation, pilotRoll);<br/>
                return;<br/>
            }<br/>
        }<br/>
        <br/>
        // okay, destination occupied.  hmmm...<br/>
        System.err.println("server.doEntityDisplacement: destination occupied");<br/>
        if (fallElevation &lt; 2) {<br/>
            // domino effect: move &amp; displace target<br/>
            phaseReport.append(entity.getDisplayName()<br/>
            ).append( " is displaced into hex "<br/>
            ).append( dest.getBoardNum() ).append( ", violating stacking with "<br/>
            ).append( violation.getDisplayName() ).append( ".\n");<br/>
            entity.setPosition(dest);<br/>
            if (roll != null) {<br/>
                pilotRolls.addElement(roll);<br/>
            }<br/>
            doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
            return;<br/>
        } else {<br/>
            // accidental fall from above: havoc!<br/>
            phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
            ).append( fallElevation ).append( " levels into hex "<br/>
            ).append( dest.getBoardNum() ).append( ", violating stacking with "<br/>
            ).append( violation.getDisplayName() ).append( ".\n");<br/>
            <br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "base");<br/>
            toHit.append(Compute.getTargetMovementModifier(game, violation.getId()));<br/>
            toHit.append(Compute.getTargetTerrainModifier(game, violation));<br/>
            <br/>
            // roll dice<br/>
            final int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("Collision occurs on a " ).append( toHit.getValue()<br/>
            ).append( " or greater.  Rolls " ).append( diceRoll);<br/>
            if (diceRoll &gt;= toHit.getValue()) {<br/>
                phaseReport.append(", hits!\n");<br/>
                // deal damage to target<br/>
                int damage = (int)Math.ceil(entity.getWeight() / 10);<br/>
                phaseReport.append(violation.getDisplayName() ).append( " takes "<br/>
                ).append( damage ).append( " from the collision.");<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = violation.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                    phaseReport.append(damageEntity(violation, hit, cluster));<br/>
                    damage -= cluster;<br/>
                }<br/>
                phaseReport.append("\n");<br/>
                <br/>
                // attacker falls as normal, on his back<br/>
                // only given a modifier, so flesh out into a full piloting roll<br/>
                PilotingRollData pilotRoll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
                pilotRoll.append(roll);<br/>
                doEntityFall(entity, dest, fallElevation, 3, pilotRoll);<br/>
                <br/>
                // defender pushed away, or destroyed<br/>
                Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(violation, dest, targetDest, new PilotingRollData(violation.getId(), 2, "fallen on"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append(destroyEntity(violation, "impossible displacement", false));<br/>
                }<br/>
            } else {<br/>
                phaseReport.append(", misses.\n");<br/>
                //TODO: this is not quite how the rules go<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.IMPOSSIBLE, "pushed off a cliff"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( entity.getId() );<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append(destroyEntity(entity, "impossible displacement", false));<br/>
                }<br/>
            }<br/>
            return;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receive a deployment packet.  If valid, execute it and end the current<br/>
     * turn.<br/>
     */<br/>
    private void receiveDeployment(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Coords coords = (Coords)packet.getObject(1);<br/>
        int nFacing = packet.getIntValue(2);<br/>
        <br/>
        // Handle units that deploy loaded with other units.<br/>
        int loadedCount = packet.getIntValue(3);<br/>
        Vector loadVector = new Vector();<br/>
        for ( int i = 0; i &lt; loadedCount; i++ ){<br/>
            int loadedId = packet.getIntValue( 4 + i );<br/>
            loadVector.<span class="upd">add</span>(game.getEntity( loadedId ));<br/>
        }<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_DEPLOYMENT) {<br/>
            System.err.println("error: server got deployment packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)<br/>
        || !game.board.isLegalDeployment(coords, entity.getOwner())) {<br/>
            System.err.println("error: server got invalid deployment packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processDeployment(entity, coords, nFacing, loadVector);<br/>
        endCurrentTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process a deployment packet by... deploying the entity!  We load any<br/>
     * other specified entities inside of it too.  Also, check that the<br/>
     * deployment is valid.<br/>
     */<br/>
    private void processDeployment(Entity entity, Coords coords, int nFacing, Vector loadVector) {<br/>
        for (Enumeration i = loadVector.elements(); i.hasMoreElements();) {<br/>
            Entity loaded = (Entity)i.nextElement();<br/>
            if ( loaded == null || loaded.getPosition() != null ||<br/>
                 loaded.getTransportId() != Entity.NONE ) {<br/>
                // Something is fishy in Denmark.<br/>
                System.err.println("error: " + entity + " can not load entity #" + loaded );<br/>
                break;<br/>
            }<br/>
            else {<br/>
                // Have the deployed unit load the indicated unit.<br/>
                this.loadUnit( entity, loaded );<br/>
            }<br/>
        }<br/>
<br/>
        entity.setPosition(coords);<br/>
        entity.setFacing(nFacing);<br/>
        entity.setSecondaryFacing(nFacing);<br/>
        entity.setDone(true);<br/>
        entityUpdate(entity.getId());<br/>
        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Is the entity Infantry?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Increment the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    turnInfMoved++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Record the player moving the infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do infantry move in blocks?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMoveMulti ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Are we at the end of a block?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Yup.  Reset the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Nope.  Decrement the turn index.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turnIndex--;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } // End inf_move_multi<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} // End entity-is-infantry<br/>
    }<br/>
    <br/>
    /**<br/>
     * Gets a bunch of entity attacks from the packet.  If valid, processess<br/>
     * them and ends the current turn.<br/>
     */<br/>
    private void receiveAttack(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Vector vector = (Vector)packet.getObject(1);<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_FIRING <br/>
        &amp;&amp; game.getPhase() != Game.PHASE_PHYSICAL) {<br/>
            System.err.println("error: server got attack packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)) {<br/>
            System.err.println("error: server got invalid attack packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processAttack(entity, vector);<br/>
        endCurrentTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process a batch of entity attack (or twist) actions by adding them to<br/>
     * the proper list to be processed later.<br/>
     */<br/>
    private void processAttack(Entity entity, Vector vector) {<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            <br/>
            // is this the right entity?<br/>
            if (ea.getEntityId() != entity.getId()) {<br/>
                System.err.println("error: attack packet has wrong attacker");<br/>
                continue;<br/>
            }<br/>
            <br/>
            if (ea instanceof PushAttackAction) {<br/>
                // push attacks go the end of the displacement attacks<br/>
                PushAttackAction paa = (PushAttackAction)ea;<br/>
                entity.setDisplacementAttack(paa);<br/>
                pendingCharges.addElement(paa);<br/>
            } else {<br/>
                // add to the normal attack list.<br/>
                attacks.addElement(ea);<br/>
            }<br/>
        }<br/>
        // this entity is done for the round<br/>
        entity.setDone(true);<br/>
        entityUpdate(entity.getId());<br/>
        <br/>
        // update all players on the attacks<br/>
        send(createAttackPacket(vector));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Auto-target active AMS systems<br/>
     */<br/>
    private void assignAMS() {<br/>
        <br/>
        // sort all missile-based attacks by the target<br/>
        Hashtable htAttacks = new Hashtable();<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements(); ) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());<br/>
<br/>
                // Only entities can have AMS.<br/>
                if ( Targetable.TYPE_ENTITY != waa.getTargetType() ) {<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Can only use AMS versus missles.<br/>
                if (((WeaponType)weapon.getType()).getDamage() == WeaponType.DAMAGE_MISSILE) {<br/>
                    Entity target = game.getEntity(waa.getTargetId());<br/>
                    Vector v = (Vector)htAttacks.get(target);<br/>
                    if (v == null) {<br/>
                        v = new Vector();<br/>
                        htAttacks.put(target, v);<br/>
                    }<br/>
                    v.addElement(waa);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        // let each target assign its AMS<br/>
        for (Enumeration i = htAttacks.keys(); i.hasMoreElements(); ) {<br/>
            Entity e = (Entity)i.nextElement();<br/>
            Vector vAttacks = (Vector)htAttacks.get(e);<br/>
            e.assignAMS(vAttacks, attacks);<br/>
        }<br/>
    }<br/>
<br/>
        <br/>
    <br/>
    /**<br/>
     * Resolve all fire for the round<br/>
     */<br/>
    private void resolveWeaponAttacks() {<br/>
        roundReport.append("\nWeapon Attack Phase\n-------------------\n");<br/>
        <br/>
        Vector results = new Vector(attacks.size());<br/>
        <br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            Entity entity = game.getEntity(((EntityAction)o).getEntityId());<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                results.addElement(preTreatWeaponAttack(waa));<br/>
                //resolveWeaponAttack(waa, cen);<br/>
            } else if (o instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)o;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
            } else if (o instanceof FlipArmsAction) {<br/>
                FlipArmsAction faa = (FlipArmsAction)o;<br/>
                game.getEntity(faa.getEntityId()).setArmsFlipped(faa.getIsFlipped());<br/>
            } else if (o instanceof FindClubAction) {<br/>
                FindClubAction fca = (FindClubAction)o;<br/>
                entity.setFindingClub(true);<br/>
                try {<br/>
                    entity.addEquipment(EquipmentType.getByInternalName("Tree Club"), Mech.LOC_NONE);<br/>
                } catch (LocationFullException ex) {<br/>
                    // unlikely...<br/>
                }<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " uproots a tree for use as a club.\n");<br/>
            } else if (o instanceof UnjamAction) {<br/>
                resolveUnjam(entity.getId());<br/>
            } else {<br/>
                // hmm, error<br/>
            }<br/>
        }<br/>
        <br/>
        // loop through weapon results and resolve<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = results.elements(); i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult)i.nextElement();<br/>
            resolveWeaponAttack(wr, cen);<br/>
            cen = wr.waa.getEntityId();<br/>
        }<br/>
        <br/>
        // and clear the attacks Vector<br/>
        attacks.removeAllElements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolve an Unjam Action object<br/>
     */<br/>
    private void resolveUnjam(int EntityId) {<br/>
        final Entity ae = game.getEntity(EntityId);<br/>
        final int TN = ae.crew.getGunnery() + 3;<br/>
        phaseReport.append("\nRAC unjam attempts for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        for (Enumeration i = ae.getWeapons(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if(mounted.isJammed()) {<br/>
                WeaponType wtype = (WeaponType)mounted.getType();<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                    phaseReport.append("  Unjamming " ).append( wtype.getName() ).append( "; needs " ).append( TN ).append( ", ");<br/>
                    int roll = Compute.d6(2);<br/>
                    phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
                    if(roll &gt;= TN) {<br/>
                        phaseReport.append(" Successfully unjammed!\n");<br/>
                        mounted.setJammed(false);<br/>
                    }<br/>
                    else {<br/>
                        phaseReport.append(" Still jammed!\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Generated by a first pass through the weapon attack list.<br/>
     */<br/>
    private class WeaponResult {<br/>
        public WeaponAttackAction waa = null;<br/>
        public ToHitData toHit = null; // stored before ammo depletion, jams<br/>
        public int roll = -1;<br/>
        public boolean revertsToSingleShot = false;<br/>
        public int amsShotDown = 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Generates a WeaponResult object for a WeaponAttackAction.  Adds heat,<br/>
     * depletes ammo, sets weapons used.<br/>
     */<br/>
    private WeaponResult preTreatWeaponAttack(WeaponAttackAction waa) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        Mounted ammo = null;<br/>
        if (usesAmmo) {<br/>
            if (waa.getAmmoId() &gt; -1) {<br/>
                ammo = ae.getEquipment(waa.getAmmoId());<br/>
                weapon.setLinked(ammo);<br/>
            } else {<br/>
                ammo = weapon.getLinked();<br/>
            }<br/>
        }<br/>
        boolean streakMiss;<br/>
        <br/>
        WeaponResult wr = new WeaponResult();<br/>
        wr.waa = waa;<br/>
        <br/>
        // has this weapon fired already?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon has already been used this round");<br/>
            return wr;<br/>
        }<br/>
        // is the weapon functional?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon was destroyed in a previous round");<br/>
            return wr;<br/>
        }<br/>
        // is it jammed?<br/>
        if (weapon.isJammed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon is jammed");<br/>
            return wr;<br/>
        }<br/>
        <br/>
        // make sure ammo is loaded<br/>
        if (usesAmmo &amp;&amp; (ammo == null || ammo.getShotsLeft() == 0 || ammo.isDumping())) {<br/>
            ae.loadWeapon(weapon);<br/>
            ammo = weapon.getLinked();<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        wr.toHit = Compute.toHitWeapon(game, waa, attacks);<br/>
        <br/>
        // roll dice<br/>
        wr.roll = Compute.d6(2);<br/>
        <br/>
        // if the shot is possible and not a streak miss, add heat and use ammo<br/>
        streakMiss = (wtype.getAmmoType() == AmmoType.T_SRM_STREAK &amp;&amp; wr.roll &lt; wr.toHit.getValue());<br/>
        if (wr.toHit.getValue() != TargetRoll.IMPOSSIBLE &amp;&amp; !streakMiss) {<br/>
            wr = addHeatUseAmmoFor(waa, wr);<br/>
        }<br/>
        <br/>
        // set the weapon as having fired<br/>
        weapon.setUsedThisRound(true);<br/>
        <br/>
        // if not streak miss, resolve any AMS attacks on this attack<br/>
        if (!streakMiss) {<br/>
            wr = resolveAmsFor(waa, wr);<br/>
        }<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Adds heat and uses ammo appropriate for a single attack of this weapon.<br/>
     * Call only on a valid attack (and with a streak weapon, only on hits.)<br/>
     *<br/>
     * @returns modified WeaponResult<br/>
     */<br/>
    private WeaponResult addHeatUseAmmoFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        Mounted ammo = weapon.getLinked();<br/>
        <br/>
        // how many shots are we firing?<br/>
        int nShots = howManyShots(weapon, ammo);<br/>
        <br/>
        // do we need to revert to single shot?<br/>
        if (usesAmmo &amp;&amp; nShots &gt; 1) {<br/>
            int nAvail = ae.getTotalAmmoOfType((AmmoType)ammo.getType());<br/>
            if (nAvail &lt; nShots) {<br/>
                wr.revertsToSingleShot = true;<br/>
                nShots = 1;<br/>
            }<br/>
        }<br/>
        <br/>
        // use up ammo<br/>
        if (usesAmmo) {<br/>
            for (int i = 0; i &lt; nShots; i++) {<br/>
                if (ammo.getShotsLeft() &lt;= 0) {<br/>
                    ae.loadWeapon(weapon);<br/>
                    ammo = weapon.getLinked();<br/>
                }<br/>
                ammo.setShotsLeft(ammo.getShotsLeft() - 1);<br/>
            }<br/>
        }<br/>
        <br/>
        // build up some heat<br/>
        ae.heatBuildup += (wtype.getHeat() * nShots);<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolves any AMS fire for this weapon attack, adding AMS heat, depleting<br/>
     * AMS ammo.<br/>
     * @returns the appropriately modified WeaponResult<br/>
     */<br/>
    private WeaponResult resolveAmsFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
        <br/>
        // any AMS attacks by the target?<br/>
        Vector vCounters = waa.getCounterEquipment();<br/>
        if (vCounters == null) {<br/>
            return wr;<br/>
        } <br/>
        <br/>
        // resolve AMS counter-fire<br/>
        for (int x = 0; x &lt; vCounters.size(); x++) {<br/>
            Mounted counter = (Mounted)vCounters.elementAt(x);<br/>
            Mounted mAmmo = counter.getLinked();<br/>
            if (!(counter.getType() instanceof WeaponType) <br/>
            || ((WeaponType)counter.getType()).getAmmoType() != AmmoType.T_AMS<br/>
            || !counter.isReady() || counter.isMissing()) {<br/>
                continue;<br/>
            }<br/>
            // roll hits<br/>
            int amsHits = Compute.d6(((WeaponType)counter.getType()).getDamage());<br/>
<br/>
            // build up some heat (assume target is ams owner)<br/>
            te.heatBuildup += ((WeaponType)counter.getType()).getHeat();<br/>
<br/>
            // decrement the ammo<br/>
            mAmmo.setShotsLeft(Math.max(0, mAmmo.getShotsLeft() - amsHits));<br/>
<br/>
            // set the ams as having fired<br/>
            counter.setUsedThisRound(true);<br/>
<br/>
            wr.amsShotDown += amsHits;<br/>
        }<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns how many shots the weapon is using<br/>
     */<br/>
    private int howManyShots(Mounted weapon, Mounted ammo) {<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        int nShots = 1;<br/>
        // figure out # of shots for variable-shot weapons<br/>
        if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA &amp;&amp; weapon.curMode().equals("Ultra")) {<br/>
            nShots = 2;<br/>
        } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY ||<br/>
                   wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
            if (weapon.curMode().equals("2-shot")) {<br/>
                nShots = 2;<br/>
            } else if (weapon.curMode().equals("3-shot")) {<br/>
                nShots = 3;<br/>
            } else if (weapon.curMode().equals("4-shot")) {<br/>
                nShots = 4;<br/>
            } else if (weapon.curMode().equals("6-shot")) {<br/>
                nShots = 6;<br/>
            }<br/>
        }<br/>
        return nShots;<br/>
    }<br/>
    <br/>
    private boolean tryIgniteHex(Coords c, boolean bInferno, int nTargetRoll) {        <br/>
    <br/>
        boolean bAnyTerrain = false;<br/>
        // inferno always ignites<br/>
        if (bInferno) {<br/>
            game.board.addInfernoTo(c, InfernoTracker.STANDARD_ROUND, 1);<br/>
            nTargetRoll = 0;<br/>
            bAnyTerrain = true;<br/>
        }<br/>
        <br/>
        Hex hex = game.board.getHex(c);                                 <br/>
        if (burn(hex, nTargetRoll, bAnyTerrain)) {<br/>
            phaseReport.append("           The hex ignites!\n");<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
    <br/>
    private boolean tryClearHex(Coords c, int nTarget) {<br/>
        <br/>
        Hex h = game.board.getHex(c);<br/>
        int woodsRoll = Compute.d6(2);<br/>
        phaseReport.append("    Checking to clear woods; needs " ).append( nTarget )<br/>
                .append( ", rolls " ).append( woodsRoll ).append( ": ");<br/>
<br/>
        if(woodsRoll &gt;= nTarget) {<br/>
            int woods = h.levelOf(Terrain.WOODS);<br/>
            if(woods &gt; 1) {<br/>
                 h.removeTerrain(Terrain.WOODS);<br/>
                 h.addTerrain(new Terrain(Terrain.WOODS, woods - 1));<br/>
                 phaseReport.append(" Heavy Woods converted to Light Woods!\n");<br/>
            }<br/>
            else if(woods == 1) {<br/>
                 h.removeTerrain(Terrain.WOODS);<br/>
                 h.addTerrain(new Terrain(Terrain.ROUGH, 1));<br/>
                 phaseReport.append(" Light Woods converted to Rough!\n");<br/>
            }<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        } else {<br/>
            phaseReport.append(" fails!\n");<br/>
            return false;<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     */<br/>
    private void resolveWeaponAttack(WeaponResult wr, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
        final Targetable target = game.getTarget(wr.waa.getTargetType(), wr.waa.getTargetId());<br/>
        Entity entityTarget = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            entityTarget = (Entity)target;<br/>
        }<br/>
        final Mounted weapon = ae.getEquipment(wr.waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        final boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        // 2002-09-16 Infantry weapons have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !isWeaponInfantry;<br/>
        final Mounted ammo = usesAmmo ? weapon.getLinked() : null;<br/>
        final AmmoType atype = ammo == null ? null : (AmmoType)ammo.getType();<br/>
        Infantry platoon = null;<br/>
        BattleArmor troopers = null;<br/>
        final boolean isBattleArmorAttack = wtype.hasFlag(WeaponType.F_BATTLEARMOR);<br/>
        ToHitData toHit = wr.toHit;<br/>
        boolean bInferno = (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_INFERNO);<br/>
        if (!bInferno) {<br/>
            // also check for inferno infantry<br/>
            bInferno = (isWeaponInfantry &amp;&amp; wtype.hasFlag(WeaponType.F_INFERNO));<br/>
        }<br/>
        <br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nWeapons fire for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
<br/>
        // Swarming infantry can stop during any weapons phase after start.<br/>
        if ( Infantry.STOP_SWARM.equals( wtype.getInternalName() ) ) {<br/>
            // ... but only as their *only* attack action.<br/>
            if ( toHit.getValue() == ToHitData.IMPOSSIBLE ) {<br/>
                phaseReport.append( "Swarm attack can not be ended (" +<br/>
                                    toHit.getDesc() ).append( ")\n" );<br/>
                return;<br/>
            } else {<br/>
                phaseReport.append( "Swarm attack ended.\n" );<br/>
                // Only apply the "stop swarm 'attack'" to the swarmed Mek.<br/>
                if ( ae.getSwarmTargetId() != target.getTargetID() ) {<br/>
                    Entity other = game.getEntity( ae.getSwarmTargetId() );<br/>
                    other.setSwarmAttackerId( Entity.NONE );<br/>
                } else {<br/>
                    entityTarget.setSwarmAttackerId( Entity.NONE );<br/>
                }<br/>
                ae.setSwarmTargetId( Entity.NONE );<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Report weapon attack and its to-hit value.<br/>
        phaseReport.append("    " ).append( wtype.getName() ).append( " at " ).append( target.getDisplayName());<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the shot is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_FAIL) {<br/>
            phaseReport.append(", the shot is an automatic miss (" ).append( toHit.getDesc() ).append( "), ");<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            phaseReport.append(", the shot is an automatic hit (" ).append( toHit.getDesc() ).append( "), ");<br/>
        } else {<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        }<br/>
        <br/>
        // if firing an HGR unbraced, schedule a PSR<br/>
        if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY &amp;&amp; ae.mpUsed &gt; 0) {<br/>
            // the mod is weight-based<br/>
            int nMod;<br/>
            if (ae.getWeight() &lt;= Mech.WEIGHT_LIGHT) {<br/>
                nMod = 2;<br/>
            } else if (ae.getWeight() &lt;= Mech.WEIGHT_MEDIUM) {<br/>
                nMod = 1;<br/>
            } else if (ae.getWeight() &lt;= Mech.WEIGHT_HEAVY) {<br/>
                nMod = 0;<br/>
            } else {<br/>
                nMod = -1;<br/>
            }<br/>
            <br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), nMod, "fired HeavyGauss unbraced"));<br/>
        }<br/>
        <br/>
        // dice have been rolled, thanks<br/>
        phaseReport.append("rolls " ).append( wr.roll ).append( " : ");<br/>
        <br/>
        // check for AC jams<br/>
        int nShots = howManyShots(weapon, ammo);<br/>
        if (nShots &gt; 1) {<br/>
            int jamCheck = 0;<br/>
            if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA &amp;&amp; weapon.curMode().equals("Ultra")) {<br/>
                jamCheck = 2;<br/>
            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                if (nShots == 2) {<br/>
                    jamCheck = 2;<br/>
                }<br/>
                else if (nShots == 4) {<br/>
                    jamCheck = 3;<br/>
                }<br/>
                else if (nShots == 6) {<br/>
                    jamCheck = 4;<br/>
                }<br/>
            }<br/>
        <br/>
            if (jamCheck &gt; 0 &amp;&amp; wr.roll &lt;= jamCheck) {<br/>
                phaseReport.append("misses AND THE AUTOCANNON JAMS.\n");<br/>
                weapon.setJammed(true);<br/>
                // ultras are destroyed by jamming<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA) {<br/>
                    weapon.setHit(true);<br/>
                }<br/>
                return;<br/>
            }<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (wr.roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            if (wr.amsShotDown &gt; 0) {<br/>
                phaseReport.append("\tAMS activates, firing " ).append( wr.amsShotDown ).append( " shot(s).\n");<br/>
            }<br/>
            <br/>
            // Non-streaks can set fires on misses<br/>
            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL &amp;&amp; wtype.getAmmoType() != AmmoType.T_SRM_STREAK) {<br/>
                <br/>
                // make sure it's a fire-setting weapon<br/>
                if (bInferno || wtype.getFireTN() != TargetRoll.IMPOSSIBLE) {<br/>
                    tryIgniteHex(target.getPosition(), bInferno, 11);<br/>
                }<br/>
            }<br/>
<br/>
            return;<br/>
        }<br/>
        <br/>
        // special case NARC hits.  No damage, but a beacon is appended<br/>
        if (wtype.getAmmoType() == AmmoType.T_NARC) {<br/>
            if (entityTarget == null) {<br/>
                phaseReport.append("hits, but doesn't do anything.\n");<br/>
            } else {<br/>
                entityTarget.setNarcedBy(ae.getOwner().getTeam());<br/>
                phaseReport.append("hits.  Pod attached.\n");<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // yeech.  handle damage. . different weapons do this in very different ways<br/>
        int hits = 1, nCluster = 1, nSalvoBonus = 0;<br/>
        int nDamPerHit = wtype.getDamage();<br/>
        boolean bSalvo = false;<br/>
        // ecm check is heavy, so only do it once<br/>
        boolean bCheckedECM = false;<br/>
        boolean bECMAffected = false;<br/>
        boolean bMekStealthActive = false;<br/>
        String sSalvoType = " shot(s) ";<br/>
<br/>
        // Mek swarms attach the attacker to the target.<br/>
        if ( Infantry.SWARM_MEK.equals( wtype.getInternalName() ) ) {<br/>
            // Is the target already swarmed?<br/>
            if ( Entity.NONE != entityTarget.getSwarmAttackerId() ) {<br/>
                phaseReport.append( "succeds, but the defender is " );<br/>
                phaseReport.append( "already swarmed by another unit.\n" );<br/>
            } else {<br/>
                phaseReport.append( "succeeds!  Defender swarmed.\n" );<br/>
                ae.setSwarmTargetId( wr.waa.getTargetId() );<br/>
                entityTarget.setSwarmAttackerId( wr.waa.getEntityId() );<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Magnetic Mine Launchers roll number of hits on battle armor<br/>
        // hits table but use # mines firing instead of men shooting.<br/>
        else if ( wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
            hits = Compute.getBattleArmorHits( nShots );<br/>
            bSalvo = true;<br/>
            sSalvoType = " mine(s) ";<br/>
        }<br/>
<br/>
        // Other battle armor attacks use # of men firing to determine hits.<br/>
        // Each hit can be in a new location. The damage per shot comes from<br/>
        // the "racksize".<br/>
        else if ( isBattleArmorAttack ) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry) ae;<br/>
            nCluster = 1;<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            hits = platoon.getShootingStrength();<br/>
            // All attacks during Mek Swarms hit; all<br/>
            // others use the Battle Armor hits table.<br/>
            if ( ae.getSwarmTargetId() != wr.waa.getTargetId() ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
<br/>
            // Handle Inferno SRM squads.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        // Infantry damage depends on # men left in platoon.<br/>
        else if (isWeaponInfantry) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry)ae;<br/>
            nCluster = 5;<br/>
            nDamPerHit = 1;<br/>
            hits = platoon.getDamage(platoon.getShootingStrength());<br/>
<br/>
            // Handle Inferno SRM infantry.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
        } else if (wtype.getDamage() == WeaponType.DAMAGE_MISSILE ||<br/>
                   wtype.hasFlag(WeaponType.F_MISSILE_HITS) ) {<br/>
            bSalvo = true;<br/>
<br/>
            // Weapons with ammo type T_BA_MG or T_BA_SMALL_LASER<br/>
            // don't have an atype object.<br/>
            if ( wtype.getAmmoType() == AmmoType.T_BA_MG ||<br/>
                 wtype.getAmmoType() == AmmoType.T_BA_SMALL_LASER ) {<br/>
                nDamPerHit = Math.abs( wtype.getAmmoType() );<br/>
            } else {<br/>
                sSalvoType = " missile(s) ";<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
            }<br/>
            <br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_MRM || <br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
                nCluster = 5;<br/>
            }<br/>
<br/>
            // calculate # of missiles hitting<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM || <br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
                <br/>
                // check for artemis, else check for narc<br/>
                Mounted mLinker = weapon.getLinkedBy();<br/>
                if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                     ( mLinker != null &amp;&amp;<br/>
                       mLinker.getType() instanceof MiscType &amp;&amp; <br/>
                       !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp;<br/>
                       mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) ) {<br/>
                            <br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        } else {<br/>
                            bECMAffected = Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition());<br/>
                        }<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                } else if (entityTarget != null &amp;&amp; entityTarget.isNarcedBy(ae.getOwner().getTeam())) {<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        } else {<br/>
                            bECMAffected = Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition());<br/>
                        }<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If dealing with Inferno rounds set damage to zero and reset<br/>
            // all salvo bonuses (cannot mix with other special munitions).<br/>
            if (bInferno) {<br/>
                    nDamPerHit = 0;<br/>
                    nSalvoBonus = 0;<br/>
                    sSalvoType = " inferno missile(s) ";<br/>
                    bSalvo = false;<br/>
            }<br/>
<br/>
            if (wtype.getAmmoType() == AmmoType.T_SRM_STREAK) {<br/>
                hits = wtype.getRackSize();<br/>
            } else if ( wtype.getRackSize() == 30 ||<br/>
                        wtype.getRackSize() == 40 ) {<br/>
                // I'm going to assume these are MRMs<br/>
                hits = Compute.missilesHit(wtype.getRackSize() / 2) +<br/>
                    Compute.missilesHit(wtype.getRackSize() / 2);<br/>
            } else if ( ae instanceof BattleArmor ) {<br/>
<br/>
                // Battle Armor units multiply their racksize by the<br/>
                // # of men shooting and they can't use NARCs.<br/>
                platoon = (Infantry) ae;<br/>
                int temp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
<br/>
                // All attacks during Mek Swarms hit the same location;<br/>
                // all others use the Battle Armor hits table.<br/>
                hits = temp;<br/>
                if ( ae.getSwarmTargetId() != wr.waa.getTargetId() ) {<br/>
<br/>
                    // Account for more than 20 missles hitting.<br/>
                    hits = 0;<br/>
                    while ( temp &gt; 20 ) {<br/>
                        hits += Compute.missilesHit( 20 );<br/>
                        temp -= 20;<br/>
                    }<br/>
                    hits += Compute.missilesHit( temp );<br/>
<br/>
                } // End not-mek-swarming<br/>
                <br/>
            } else {<br/>
                hits = Compute.missilesHit(wtype.getRackSize(), nSalvoBonus);<br/>
            }<br/>
<br/>
            // Advanced SRM's don't hit with an odd # of missles.<br/>
            if ( null != atype &amp;&amp;<br/>
                 atype.getAmmoType() == AmmoType.T_SRM_ADVANCED ) {<br/>
                hits = 2 * (int) Math.floor( (1.0 + (float) hits) / 2.0);<br/>
            }<br/>
<br/>
        } else if (atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            // Cluster shots break into single point clusters.<br/>
            bSalvo = true;<br/>
            hits = Compute.missilesHit(wtype.getRackSize());<br/>
            nDamPerHit = 1;<br/>
        } else if (nShots &gt; 1) {<br/>
            // this should handle multiple attacks from ultra and rotary ACs<br/>
            bSalvo = true;<br/>
            hits = Compute.missilesHit(nShots);<br/>
        } else if (atype != null &amp;&amp; atype.hasFlag(AmmoType.F_MG) &amp;&amp;<br/>
                   !isWeaponInfantry &amp;&amp; (target instanceof Infantry) &amp;&amp;<br/>
                   !(target instanceof BattleArmor) ) {<br/>
            // Mech and Vehicle MGs do *DICE* of damage to PBI.<br/>
            // 2002-10-24 Suvarov454 : no need for so many lines in the report.<br/>
            nDamPerHit = Compute.d6(wtype.getDamage());<br/>
            phaseReport.append( "riddles the target with " ).append( <br/>
                nDamPerHit ).append( sSalvoType ).append( "and " );<br/>
        }<br/>
        else if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY) {<br/>
            // HGR does range-dependent damage<br/>
            int nRange = ae.getPosition().distance(target.getPosition());<br/>
            if (nRange &lt;= wtype.getShortRange()) {<br/>
                nDamPerHit = 25;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nDamPerHit = 20;<br/>
            } else {<br/>
                nDamPerHit = 10;<br/>
            }<br/>
        }<br/>
<br/>
        // Some weapons double the number of hits scored.<br/>
        if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
            hits *= 2;<br/>
        }<br/>
<br/>
        // All attacks (except from infantry weapons)<br/>
        // during Mek Swarms hit the same location.<br/>
        if ( !isWeaponInfantry &amp;&amp;<br/>
             ae.getSwarmTargetId() == wr.waa.getTargetId() ) {<br/>
            nCluster = hits;<br/>
        }<br/>
<br/>
        // Battle Armor MGs do one die of damage per hit to PBI.<br/>
        if ( wtype.getAmmoType() == AmmoType.T_BA_MG &amp;&amp;<br/>
             (target instanceof Infantry) &amp;&amp; !(target instanceof BattleArmor) ) {<br/>
            nDamPerHit = Compute.d6(hits);<br/>
            phaseReport.append( "riddles the target with " ).append( <br/>
                nDamPerHit ).append( sSalvoType ).append( "and " );<br/>
            hits = 1;<br/>
            bSalvo = false;<br/>
        }<br/>
<br/>
        // Report the number of hits.<br/>
        if (bSalvo) {<br/>
            phaseReport.append(hits ).append( sSalvoType ).append( "hit" ).append( toHit.getTableDesc());<br/>
            if (bECMAffected) {<br/>
                phaseReport.append(" (ECM prevents bonus)");<br/>
            }<br/>
            else if (bMekStealthActive) {<br/>
                phaseReport.append(" (active Stealth prevents bonus)");<br/>
            }<br/>
            if (nSalvoBonus &gt; 0) {<br/>
                phaseReport.append(" (w/ +")<br/>
                    .append(nSalvoBonus)<br/>
                    .append(" bonus)");<br/>
            }<br/>
            phaseReport.append(".");<br/>
            <br/>
            if (wr.amsShotDown &gt; 0) {<br/>
                int shotDown = Math.min(wr.amsShotDown, hits);<br/>
                phaseReport.append("\n\tAMS engages, firing ")<br/>
                    .append(wr.amsShotDown).append(" shots, shooting down ")<br/>
                    .append(shotDown).append(" missile(s).");<br/>
                hits -= wr.amsShotDown;<br/>
            }<br/>
        }<br/>
<br/>
        // convert the ATM missile damages to LRM type 5 point cluster damage<br/>
        // done here after AMS has been performed<br/>
        if (wtype.getAmmoType() == AmmoType.T_ATM)<br/>
        {<br/>
            hits = nDamPerHit * hits;<br/>
            nDamPerHit = 1;<br/>
        }<br/>
<br/>
        // Make sure the player knows when his attack causes no damage.<br/>
        if ( hits == 0 ) {<br/>
            phaseReport.append( "attack deals zero damage.\n" );<br/>
        }<br/>
<br/>
        // for each cluster of hits, do a chunk of damage<br/>
        while (hits &gt; 0) {<br/>
            int nDamage;<br/>
<br/>
            // If the attack was with inferno rounds then<br/>
            // do heat and fire instead of damage.<br/>
            if ( bInferno ) {<br/>
                // TODO: remove this block and make infantry invalid<br/>
                //       targets for Infernos in Compute#toHitWeapon()<br/>
                // Infernos cannot attack infantry directly so instead<br/>
                // they attack hits the hex and sets it on fire.<br/>
                if (target instanceof Infantry) {<br/>
                    phaseReport.append("hits!\n");<br/>
                    tryIgniteHex(target.getPosition(), true, 0);<br/>
                    return;<br/>
                }<br/>
<br/>
                // targeting a hex for ignition<br/>
                if(target.getTargetType() == Targetable.TYPE_HEX_IGNITE) {<br/>
                    phaseReport.append( "hits with " )<br/>
                        .append( hits )<br/>
                        .append( " inferno missles.\n" );<br/>
                    tryIgniteHex(target.getPosition(), true, 0);<br/>
                    return;<br/>
                }<br/>
                <br/>
                // Targeting an entity<br/>
                if (entityTarget != null ) {<br/>
                    entityTarget.infernos.add( InfernoTracker.STANDARD_ROUND,<br/>
                                     hits );<br/>
                    if ( !bSalvo ) {<br/>
                        phaseReport.append( "hits with " )<br/>
                            .append( hits )<br/>
                            .append( " inferno missles." );<br/>
                    }<br/>
                    phaseReport.append("\n        " )<br/>
                        .append( target.getDisplayName() )<br/>
                        .append( " now on fire for ")<br/>
                        .append( entityTarget.infernos.getTurnsLeftToBurn() )<br/>
                        .append(" turns.\n");<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    Hex h = game.getBoard().getHex(c);<br/>
<br/>
                    phaseReport.append(" Fire started in hex!\n");<br/>
                    h.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
                    game.board.addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return;<br/>
                }<br/>
            } // End is-inferno<br/>
<br/>
            // targeting a hex for igniting<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_IGNITE) {<br/>
                phaseReport.append("hits!\n");<br/>
                if (bInferno || wtype.getFireTN() != TargetRoll.IMPOSSIBLE) {<br/>
                    tryIgniteHex(target.getPosition(), bInferno, wtype.getFireTN());<br/>
                }<br/>
                return;<br/>
            }<br/>
            <br/>
            // targeting a hex for clearing<br/>
            // is it true that flamers can't clear?<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_CLEAR) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                phaseReport.append("hits!\n");<br/>
                phaseReport.append("    Terrain takes " ).append( nDamage ).append( " damage.\n");<br/>
                <br/>
                // any clear attempt can result in accidental ignition<br/>
                // even weapons that can't normally start fires.  that's weird. . <br/>
                if (tryIgniteHex(target.getPosition(), bInferno, 9)) {<br/>
                    return;<br/>
                }<br/>
                <br/>
                int tn = 14 - nDamage;<br/>
                if(!wtype.hasFlag(WeaponType.F_FLAMER)) {<br/>
                    tryClearHex(target.getPosition(), tn);<br/>
                } <br/>
                <br/>
                return;<br/>
            }<br/>
<br/>
            // Battle Armor squads equipped with fire protection<br/>
            // gear automatically avoid flaming death.<br/>
            if ( wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp; <br/>
                 target instanceof BattleArmor ) {<br/>
                for ( Enumeration iter = entityTarget.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        phaseReport.append( "hits, but " )<br/>
                            .append(target.getDisplayName() )<br/>
                            .append( " is protected from the flamer by its gear.\n" );<br/>
                        return;<br/>
                    }<br/>
                }<br/>
            } // End target-may-be-immune<br/>
<br/>
            // Flamers do heat, not damage.<br/>
            else if (entityTarget != null &amp;&amp; wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp; game.getOptions().booleanOption("flamer_heat")) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                phaseReport.append("\n        Target gains ").append(nDamage).append(" more heat during heat phase.");<br/>
                entityTarget.heatBuildup += nDamage;<br/>
                hits = 0;<br/>
            }<br/>
            else if (entityTarget != null) {<br/>
                HitData hit = entityTarget.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
<br/>
                // If a leg attacks hit a leg that isn't<br/>
                // there, then hit the other leg.<br/>
                if ( wtype.getInternalName().equals("LegAttack") &amp;&amp;<br/>
                     entityTarget.getInternal(hit) &lt;= 0 ) {<br/>
                    if ( hit.getLocation() == Mech.LOC_RLEG ) {<br/>
                        hit = new HitData( Mech.LOC_LLEG );<br/>
                    }<br/>
                    else {<br/>
                        hit = new HitData( Mech.LOC_RLEG );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mine Launchers automatically hit the<br/>
                // CT of a Mech or the front of a Tank.<br/>
                if ( wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
                    if ( target instanceof Mech ) {<br/>
                        hit = new HitData( Mech.LOC_CT );<br/>
                    }<br/>
                    else { // te instanceof Tank<br/>
                        hit = new HitData( Tank.LOC_FRONT );<br/>
                    }<br/>
                }<br/>
<br/>
                // Each hit in the salvo get's its own hit location.<br/>
                if (!bSalvo) {<br/>
                    phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).<br/>
                            append( entityTarget.getLocationAbbr(hit));<br/>
                }<br/>
<br/>
                // Special weapons do criticals instead of damage.<br/>
                if ( nDamPerHit == WeaponType.DAMAGE_SPECIAL ) {<br/>
                    // Do criticals.<br/>
                    String specialDamage = criticalEntity( entityTarget, hit.getLocation() );<br/>
<br/>
                    // Replace "no effect" results with 4 points of damage.<br/>
                    if ( specialDamage.endsWith(" no effect.") ) {<br/>
                        specialDamage = damageEntity(entityTarget, hit, 4);<br/>
                    }<br/>
                    else {<br/>
                        specialDamage = "\n" + specialDamage;<br/>
                    }<br/>
<br/>
                    // Report the result<br/>
                    phaseReport.append( specialDamage );<br/>
                }<br/>
                else {<br/>
                    // Resolve damage normally.<br/>
                    nDamage = nDamPerHit * Math.min(nCluster, hits);<br/>
                    phaseReport.append(damageEntity(entityTarget, hit, nDamage));<br/>
                }<br/>
                hits -= nCluster;<br/>
            }<br/>
        } // Handle the next cluster.<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        roundReport.append("\nPhysical Attack Phase\n-------------------\n");<br/>
        <br/>
        int cen = Entity.NONE;<br/>
        <br/>
        // add any pending charges<br/>
        for (Enumeration i = pendingCharges.elements(); i.hasMoreElements();) {<br/>
            attacks.addElement(i.nextElement());<br/>
        }<br/>
        pendingCharges.removeAllElements();<br/>
        <br/>
        // remove any duplicate attack declarations<br/>
        cleanupPhysicalAttacks();<br/>
        <br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            <br/>
            // verify that the attacker is still active<br/>
            AttackAction aa = (AttackAction)o;<br/>
            if (!(game.getEntity(aa.getEntityId()).isActive())<br/>
            &amp;&amp; !(o instanceof DfaAttackAction)) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            if (o instanceof PunchAttackAction) {<br/>
                PunchAttackAction paa = (PunchAttackAction)o;<br/>
                if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                    // If we're punching while prone (at a Tank,<br/>
                    // duh), then we can only use one arm.<br/>
                    Entity ae = game.getEntity( aa.getEntityId() );<br/>
                    if ( ae.isProne() ) {<br/>
                        // As a sanity check, make certain<br/>
                        // that no arm has been destroyed.<br/>
                        if ( ae.isLocationDestroyed(Mech.LOC_RARM) ) {<br/>
                            phaseReport.append( ae.getDisplayName() ).append<br/>
                                ( " can't punch: right arm destroyed.\n" );<br/>
                            continue;<br/>
                        }<br/>
                        else if ( ae.isLocationDestroyed(Mech.LOC_LARM) ) {<br/>
                            phaseReport.append( ae.getDisplayName() ).append<br/>
                                ( " can't punch: left arm destroyed.\n" );<br/>
                            continue;<br/>
                        }<br/>
<br/>
                        // Find out which arm has the best attack.<br/>
                        paa.setArm(PunchAttackAction.LEFT);<br/>
                        ToHitData left = Compute.toHitPunch( game, paa );<br/>
                        double oddsLeft = Compute.oddsAbove(left.getValue());<br/>
                        int damageLeft = Compute.getPunchDamageFor<br/>
                            ( ae, PunchAttackAction.LEFT );<br/>
                        paa.setArm(PunchAttackAction.RIGHT);<br/>
                        ToHitData right = Compute.toHitPunch( game, paa );<br/>
                        double oddsRight = Compute.oddsAbove(right.getValue());<br/>
                        int damageRight = Compute.getPunchDamageFor<br/>
                            ( ae, PunchAttackAction.RIGHT );<br/>
<br/>
                        // Use the best attack.<br/>
                        if (  oddsLeft*damageLeft &gt; oddsRight*damageRight ) {<br/>
                            // Be sure to set the left arm first.<br/>
                            paa.setArm(PunchAttackAction.LEFT);<br/>
                            resolvePunchAttack(paa, cen);<br/>
                            cen = paa.getEntityId();<br/>
                        } else {<br/>
                            // We've already set the right arm.<br/>
                            resolvePunchAttack(paa, cen);<br/>
                            cen = paa.getEntityId();<br/>
                        }<br/>
                    } // End Entity-is-prone<br/>
                    else {<br/>
                        paa.setArm(PunchAttackAction.LEFT);<br/>
                        resolvePunchAttack(paa, cen);<br/>
                        cen = paa.getEntityId();<br/>
                        paa.setArm(PunchAttackAction.RIGHT);<br/>
                        resolvePunchAttack(paa, cen);<br/>
                    }<br/>
                } else {<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof KickAttackAction) {<br/>
                KickAttackAction kaa = (KickAttackAction)o;<br/>
                resolveKickAttack(kaa, cen);<br/>
                cen = kaa.getEntityId();<br/>
            } else if (o instanceof BrushOffAttackAction) {<br/>
                BrushOffAttackAction baa = (BrushOffAttackAction)o;<br/>
                if (baa.getArm() == BrushOffAttackAction.BOTH) {<br/>
                    baa.setArm(BrushOffAttackAction.LEFT);<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                    cen = baa.getEntityId();<br/>
                    baa.setArm(BrushOffAttackAction.RIGHT);<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                } else {<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                    cen = baa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof ThrashAttackAction) {<br/>
                ThrashAttackAction taa = (ThrashAttackAction)o;<br/>
                resolveThrashAttack(taa, cen);<br/>
                cen = taa.getEntityId();<br/>
            } else if (o instanceof ClubAttackAction) {<br/>
                ClubAttackAction caa = (ClubAttackAction)o;<br/>
                resolveClubAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            } else if (o instanceof PushAttackAction) {<br/>
                PushAttackAction paa = (PushAttackAction)o;<br/>
                resolvePushAttack(paa, cen);<br/>
                cen = paa.getEntityId();<br/>
            }  else if (o instanceof ChargeAttackAction) {<br/>
                ChargeAttackAction caa = (ChargeAttackAction)o;<br/>
                resolveChargeAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            }  else if (o instanceof DfaAttackAction) {<br/>
                DfaAttackAction daa = (DfaAttackAction)o;<br/>
                resolveDfaAttack(daa, cen);<br/>
                cen = daa.getEntityId();<br/>
            } else {<br/>
                // hmm, error.<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Cleans up the attack declarations for the physical phase by removing<br/>
     * all attacks past the first for any one mech.  Also clears out attacks<br/>
     * by dead or disabled mechs.<br/>
     */<br/>
    private void cleanupPhysicalAttacks() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            removeDuplicateAttacks(entity.getId());<br/>
        }<br/>
        removeDeadAttacks();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes any actions in the attack queue beyond the first by the<br/>
     * specified entity.<br/>
     */<br/>
    private void removeDuplicateAttacks(int entityId) {<br/>
        boolean attacked = false;<br/>
        Vector toKeep = new Vector(attacks.size());<br/>
        <br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            if (action.getEntityId() != entityId) {<br/>
                toKeep.addElement(action);<br/>
            } else if (!attacked) {<br/>
                toKeep.addElement(action);<br/>
                attacked = true;<br/>
            } else {<br/>
                System.err.println("server: removing duplicate phys attack for id#" + entityId);<br/>
            }<br/>
        }<br/>
        <br/>
        attacks = toKeep;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes all attacks by any dead entities.  It does this by going through<br/>
     * all the attacks and only keeping ones from active entities.  DFAs are<br/>
     * kept even if the pilot is unconcious, so that he can fail.<br/>
     */<br/>
    private void removeDeadAttacks() {<br/>
        Vector toKeep = new Vector(attacks.size());<br/>
        <br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(action.getEntityId());<br/>
            if (entity != null &amp;&amp; !entity.isDestroyed()<br/>
            &amp;&amp; (entity.isActive() || action instanceof DfaAttackAction)) {<br/>
                toKeep.addElement(action);<br/>
            }<br/>
        }<br/>
        <br/>
        attacks = toKeep;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PunchAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? "Left Arm" : "Right Arm";<br/>
        <br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Punch (" +armName ).append( ") at " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPunch(game, paa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the punch is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getPunchDamageFor(ae, paa.getArm());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(KickAttackAction kaa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Entity te = game.getEntity(kaa.getTargetId());<br/>
        final String legName = kaa.getLeg() == KickAttackAction.LEFT<br/>
        ? "Left Leg"<br/>
        : "Right Leg";<br/>
        <br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Kick (" ).append( legName ).append( ") at " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitKick(game, kaa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the kick is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        <br/>
        int damage = Compute.getKickDamageFor(ae, kaa.getLeg());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        if (te.getMovementType() == Entity.MovementType.BIPED || te.getMovementType() == Entity.MovementType.QUAD) {<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was kicked"));<br/>
        }<br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a brush off attack<br/>
     */<br/>
    private void resolveBrushOffAttack( BrushOffAttackAction baa,<br/>
                                        int lastEntityId ) {<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        final Entity te = game.getEntity(baa.getTargetId());<br/>
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT<br/>
            ? "Left Arm" : "Right Arm";<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            phaseReport.append( "\nPhysical attacks for " )<br/>
                .append( ae.getDisplayName() )<br/>
                .append( "\n" );<br/>
        }<br/>
<br/>
        phaseReport.append("    Brush Off " )<br/>
            .append( te.getDisplayName() )<br/>
            .append( " with " )<br/>
            .append( armName );<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitBrushOff(game, baa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append( ", but the brush off is impossible (" )<br/>
                .append( toHit.getDesc() )<br/>
                .append( ")\n" );<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs ").append(toHit.getValue()).append(", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls ").append(roll).append(" : ");<br/>
<br/>
        int damage = Compute.getBrushOffDamageFor(ae, baa.getArm());<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
<br/>
            // Missed Brush Off attacks cause punch damage to the attacker.<br/>
            toHit.setHitTable( ToHitData.HIT_PUNCH );<br/>
            toHit.setSideTable( ToHitData.SIDE_FRONT );<br/>
            HitData hit = ae.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            phaseReport.append( ae.getDisplayName() )<br/>
                .append( " punches itself in the " )<br/>
                .append( ae.getLocationAbbr(hit) )<br/>
                .append( damageEntity(ae, hit, damage) )<br/>
                .append("\n");<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                          toHit.getSideTable() );<br/>
        phaseReport.append("hits")<br/>
            .append( toHit.getTableDesc() )<br/>
            .append( " " )<br/>
            .append( te.getLocationAbbr(hit) );<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        phaseReport.append("\n");<br/>
<br/>
        // Dislodge the swarming infantry.<br/>
        ae.setSwarmAttackerId( Entity.NONE );<br/>
        te.setSwarmTargetId( Entity.NONE );<br/>
        phaseReport.append( te.getDisplayName() )<br/>
            .append( " is dislodged.\n" );<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a thrash attack<br/>
     */<br/>
    private void resolveThrashAttack( ThrashAttackAction baa,<br/>
                                        int lastEntityId ) {<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        final Entity te = game.getEntity(baa.getTargetId());<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            phaseReport.append( "\nPhysical attacks for " )<br/>
                .append( ae.getDisplayName() )<br/>
                .append( "\n" );<br/>
        }<br/>
<br/>
        phaseReport.append("    Thrash at " )<br/>
            .append( te.getDisplayName() );<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitThrash(game, baa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append( ", but the thrash is impossible (" )<br/>
                .append( toHit.getDesc() )<br/>
                .append( ")\n" );<br/>
            return;<br/>
        }<br/>
<br/>
        // Thrash attack may hit automatically<br/>
        if ( toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS ) {<br/>
            phaseReport.append( "; hits automatically," );<br/>
        } else {<br/>
            phaseReport.append( "; needs " )<br/>
                .append( toHit.getValue() )<br/>
                .append( ", " );<br/>
<br/>
            // roll<br/>
            int roll = Compute.d6(2);<br/>
            phaseReport.append("rolls ").append(roll).append(" : ");<br/>
<br/>
            // do we hit?<br/>
            if (roll &lt; toHit.getValue()) {<br/>
                phaseReport.append("misses.\n");<br/>
                return;<br/>
            }<br/>
            phaseReport.append( ", hits" );<br/>
        }<br/>
<br/>
        // Standard damage loop in 5 point clusters.<br/>
        int hits = Compute.getThrashDamageFor(ae);<br/>
        phaseReport.append( " and deals " )<br/>
            .append( hits )<br/>
            .append( " points of damage in 5 point clusters.");<br/>
        while ( hits &gt; 0 ) {<br/>
            int damage = Math.min(5, hits);<br/>
            hits -= damage;<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            phaseReport.append("\nHits ").append( te.getLocationAbbr(hit) );<br/>
            phaseReport.append(damageEntity(te, hit, damage));<br/>
        }<br/>
        phaseReport.append("\n");<br/>
<br/>
        // Thrash attacks cause PSRs.  Failed PSRs cause falling damage.<br/>
        // This fall damage applies even though the Thrashing Mek is prone.<br/>
        PilotingRollData roll = Compute.getBasePilotingRoll(game, ae.getId());<br/>
        roll.addModifier( 0, "thrashing at infantry" );<br/>
        phaseReport.append( ae.getDisplayName() )<br/>
            .append( " must make a piloting skill check (" )<br/>
            .append( "thrashing at infantry).\n");<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " )<br/>
            .append( roll.getValueAsString() )<br/>
            .append( " [" )<br/>
            .append( roll.getDesc() )<br/>
            .append( "]" )<br/>
            .append( ", rolls " )<br/>
            .append( diceRoll )<br/>
            .append( " : " );<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("fails.\n");<br/>
            doEntityFall( ae, roll );<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a club attack<br/>
     */<br/>
    private void resolveClubAttack(ClubAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // restore club attack<br/>
        caa.getClub().restore();<br/>
        <br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    " ).append( caa.getClub().getName() ).append( " attack on " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitClub(game, caa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the attack is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getClubDamageFor(ae, caa.getClub());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        phaseReport.append("\n");<br/>
        <br/>
        if (caa.getClub().getType().hasFlag(MiscType.F_TREE_CLUB)) {<br/>
            phaseReport.append("The " ).append( caa.getClub().getName() ).append( " breaks.\n");<br/>
            ae.removeMisc(caa.getClub().getName());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PushAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        <br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Pushing " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPush(game, paa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the push is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
        <br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
        <br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            phaseReport.append("succeeds: target is pushed into hex "<br/>
            ).append( dest.getBoardNum()<br/>
            ).append( "\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
            <br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (!te.getPosition().equals(src)) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest)) {<br/>
                game.removeEntity(te.getId(),<br/>
                                  Game.UNIT_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(te.getId(),<br/>
                                              Game.UNIT_IN_RETREAT));<br/>
                phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " has been forced from the field. ***\n");<br/>
                ae.setPosition(src);<br/>
            } else {<br/>
                phaseReport.append("succeeds, but target can't be moved.\n");<br/>
                pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
            }<br/>
        }<br/>
        <br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(ChargeAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
        <br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append("    Charge cancelled as the target has been destroyed.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // attacker fell down?<br/>
        if (ae.isProne()) {<br/>
            phaseReport.append("    Charge cancelled as the attacker has fallen.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // attacker immobile?<br/>
        if (ae.isImmobile()) {<br/>
            phaseReport.append("    Charge cancelled as the attacker has been immobilized.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        phaseReport.append("    Charging " ).append( te.getDisplayName());<br/>
        <br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(caa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitCharge(game, caa);<br/>
        <br/>
        // if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            phaseReport.append(", but the charge is impossible (" ).append( toHit.getDesc() ).append( ") : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
            phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Resolve the damage.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    resolveChargeDamage( ae, te, toHit, direction );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge's damage<br/>
     */<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getChargeDamageFor(ae);<br/>
        int damageTaken = Compute.getChargeDamageTakenBy(ae, te);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PilotingRollData chargePSR = null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If we're upright, we may fall down.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( !ae.isProne() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    chargePSR = new PilotingRollData(ae.getId(), 2, "charging");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
        phaseReport.append("hits.");<br/>
        phaseReport.append("\n  Defender takes " ).append( damage ).append( " damage" ).append( toHit.getTableDesc() ).append( ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " ).append( damageTaken ).append( " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            phaseReport.append("\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
        } else {<br/>
            if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest)) {<br/>
                game.removeEntity(te.getId(),<br/>
                                  Game.UNIT_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(te.getId(),<br/>
                                              Game.UNIT_IN_RETREAT));<br/>
                phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " target has been forced from the field. ***\n");<br/>
                doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
            } else {<br/>
                // they stil have to roll<br/>
                pilotRolls.addElement(new PilotingRollData(te.getId(), 2, "was charged"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pilotRolls.addElement(chargePSR);<br/>
            }<br/>
        }<br/>
        <br/>
        phaseReport.append("\n");<br/>
<br/>
    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )<br/>
    <br/>
    /**<br/>
     * Handle a death from above attack<br/>
     */<br/>
    private void resolveDfaAttack(DfaAttackAction daa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Entity te = game.getEntity(daa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
        <br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
        <br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append("    Death from above deals no damage as the target has been destroyed.\n");<br/>
            if (ae.isProne()) {<br/>
                // attacker prone during weapons phase<br/>
                doEntityFall(ae, daa.getTargetPos(), 2, 3, Compute.getBasePilotingRoll(game, ae.getId()));<br/>
            } else {<br/>
                // same effect as successful DFA<br/>
                doEntityDisplacement(ae, ae.getPosition(), daa.getTargetPos(), new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
            }<br/>
            return;<br/>
        }<br/>
        <br/>
        phaseReport.append("    Attempting death from above on " ).append( te.getDisplayName());<br/>
        <br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(daa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitDfa(game, daa);<br/>
        <br/>
        // hack: if the attacker's prone, or incapacitated, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne() || !ae.isActive()) {<br/>
            roll = -12;<br/>
            phaseReport.append(" but the attacker is prone or incapacitated : ");<br/>
        } else if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            phaseReport.append(" but the attack is impossible (" ).append( toHit.getDesc() ).append( ") : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
            phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            if (targetDest != null) {<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, dest, targetDest, null);<br/>
                // attacker falls into destination hex<br/>
                phaseReport.append(ae.getDisplayName() ).append( " falls into hex " ).append( dest.getBoardNum() ).append( ".\n");<br/>
                doEntityFall(ae, dest, 2, 3, Compute.getBasePilotingRoll(game, ae.getId()));<br/>
            } else {<br/>
                // attacker destroyed<br/>
                phaseReport.append(destroyEntity(ae, "impossible displacement", false));<br/>
            }<br/>
            return;<br/>
        }<br/>
        <br/>
        // we hit...<br/>
        int damage = Compute.getDfaDamageFor(ae);<br/>
        int damageTaken = Compute.getDfaDamageTakenBy(ae);<br/>
        <br/>
        phaseReport.append("hits.");<br/>
        <br/>
        phaseReport.append("\n  Defender takes " ).append( damage ).append( " damage" ).append( toHit.getTableDesc() ).append( ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " ).append( damageTaken ).append( " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        phaseReport.append("\n");<br/>
        <br/>
        // defender pushed away or destroyed<br/>
        Coords src = ae.getPosition();<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest.translated(direction))) {<br/>
            game.removeEntity(te.getId(),<br/>
                              Game.UNIT_IN_RETREAT);<br/>
            send(createRemoveEntityPacket(te.getId(),<br/>
                                          Game.UNIT_IN_RETREAT));<br/>
            phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " target has been forced from the field. ***\n");<br/>
        } else {<br/>
            if (targetDest != null) {<br/>
                doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
            } else {<br/>
                // ack!  automatic death!<br/>
                phaseReport.append(destroyEntity(te, "impossible displacement", false));<br/>
            }<br/>
        }<br/>
        // HACK: to avoid automatic falls, displace from dest to dest<br/>
        doEntityDisplacement(ae, dest, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        roundReport.append("\nHeat Phase\n----------\n");<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            Hex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
            <br/>
            // heat doesn't matter for non-mechs<br/>
            if (!(entity instanceof Mech)) {<br/>
                entity.heatBuildup = 0;<br/>
<br/>
                // If the unit is hit with an Inferno, do flaming death test.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
                continue;<br/>
            }<br/>
            else {<br/>
                // Meks gain heat from inferno hits.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    int infernoHeat = entity.infernos.getHeat();<br/>
                    entity.heatBuildup += infernoHeat;<br/>
                    roundReport.append( "Added " )<br/>
                        .append( infernoHeat )<br/>
                        .append( " from a burning inferno round...\n" );<br/>
                }<br/>
            }<br/>
<br/>
            // should we even bother?<br/>
            if ( entity.isDestroyed() || entity.isDoomed() ||<br/>
                 entity.crew.isDead() ) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            if (!entity.isShutDown()) {<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
            }<br/>
<br/>
            // If a Mek had an active Stealth suite, add 10 heat.<br/>
            if ( entity instanceof Mech &amp;&amp; entity.isStealthActive() ) {<br/>
                entity.heatBuildup += 10;<br/>
                roundReport.append("Added 10 heat from Stealth Armor...\n");<br/>
            }<br/>
<br/>
            // Add +5 Heat if the hex you're in is on fire<br/>
            // and was on fire for the full round.<br/>
            if (entityHex.levelOf(Terrain.FIRE) == 2) {<br/>
                entity.heatBuildup += 5;<br/>
                roundReport.append("Added 5 heat from a fire...\n");<br/>
            }<br/>
            <br/>
            // add the heat we've built up so far.<br/>
            roundReport.append( entity.getDisplayName() )<br/>
                .append( " gains " )<br/>
                .append( entity.heatBuildup )<br/>
                .append( " heat,");<br/>
            entity.heat += entity.heatBuildup;<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = Math.min( entity.getHeatCapacityWithWater(),<br/>
                                   entity.heat );<br/>
            <br/>
            entity.heat -= tosink;<br/>
            roundReport.append( " sinks " )<br/>
                .append( tosink )<br/>
                .append( " heat and is now at " )<br/>
                .append( entity.heat )<br/>
                .append( " heat.\n");<br/>
<br/>
            // Does the unit have inferno ammo?<br/>
            if( entity.hasInfernoAmmo() ) {<br/>
<br/>
                // Apply the inferno ammo explosion.<br/>
                if (entity.heat &gt;= 10) {<br/>
                    int boom = 4 + (entity.heat &gt;= 14 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 19 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 23 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 28 ? 2 : 0);<br/>
                    int boomroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( boom )<br/>
                        .append( "+ to avoid inferno ammo explosion, rolls " )<br/>
                        .append( boomroll )<br/>
                        .append( " : " );<br/>
                    if (boomroll &gt;= boom) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails to avoid explosion.\n");<br/>
                        roundReport.append(explodeInfernoAmmoFromHeat(entity));<br/>
                    }<br/>
                }<br/>
            } // End avoid-inferno-explosion<br/>
<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; 30 &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    entity.setShutDown(false);<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " automatically starts up.\n" );<br/>
                } else {<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int suroll = Compute.d6(2);<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( startup )<br/>
                        .append( "+ to start up, rolls " )<br/>
                        .append( suroll )<br/>
                        .append( " : " );<br/>
                    if (suroll &gt;= startup) {<br/>
                        entity.setShutDown(false);<br/>
                        roundReport.append("successful!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails.\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            // 2003-01-26 JAD - Don't shut down if you just restarted.<br/>
            else if (entity.heat &gt;= 14 &amp;&amp; !entity.isShutDown()) {<br/>
                if (entity.heat &gt;= 30) {<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " automatically shuts down.\n" );<br/>
                    // add a piloting roll and resolve immediately<br/>
                    pilotRolls.addElement(new PilotingRollData<br/>
                        ( entity.getId(), 3, "reactor shutdown" ));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int sdroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( shutdown )<br/>
                        .append( "+ to avoid shutdown, rolls " )<br/>
                        .append( sdroll )<br/>
                        .append( " : ");<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("shuts down.\n");<br/>
                        // add a piloting roll and resolve immediately<br/>
                        pilotRolls.addElement(new PilotingRollData<br/>
                            ( entity.getId(), 3, "reactor shutdown" ));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                    (entity.heat &gt;= 28 ? 2 : 0);<br/>
                int boomroll = Compute.d6(2);<br/>
                roundReport.append( entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( boom )<br/>
                        .append( "+ to avoid ammo explosion, rolls " )<br/>
                        .append( boomroll )<br/>
                        .append( " : ");<br/>
                if (boomroll &gt;= boom) {<br/>
                    roundReport.append("avoids successfully!\n");<br/>
                } else {<br/>
                    roundReport.append("fails to avoid explosion.\n");<br/>
                    roundReport.append(explodeAmmoFromHeat(entity));<br/>
                }<br/>
            }<br/>
            <br/>
            // heat effects: mechwarrior damage<br/>
            if (entity.getHitCriticals( CriticalSlot.TYPE_SYSTEM,<br/>
                                        Mech.SYSTEM_LIFE_SUPPORT,<br/>
                                        Mech.LOC_HEAD ) &gt; 0<br/>
                &amp;&amp; entity.heat &gt;= 15) {<br/>
                if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    roundReport.append(entity.getDisplayName() ).append( " has 25 or higher heat and damaged life support.  Mechwarrior takes 2 damage.\n");<br/>
                    damageCrew(entity, 2);<br/>
                } else {<br/>
                    // mechwarrior takes 1 damage<br/>
                    roundReport.append(entity.getDisplayName() ).append( " has 15 or higher heat and damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                    damageCrew(entity, 1);<br/>
                }<br/>
                // The pilot may have just expired.<br/>
                if ( entity.crew.isDead() ) {<br/>
                    roundReport.append( "*** " )<br/>
                        .append( entity.getDisplayName() )<br/>
                        .append( " PILOT BAKES TO DEATH! ***" );<br/>
                }<br/>
            }<br/>
<br/>
        }<br/>
    }<br/>
    <br/>
    private void doFlamingDeath(Entity entity) {<br/>
        int boomroll = Compute.d6(2);<br/>
        // Infantry are unaffected by fire while they're still swarming.<br/>
        if ( Entity.NONE != entity.getSwarmTargetId() ) {<br/>
            return;<br/>
        }<br/>
        // Battle Armor squads equipped with fire protection<br/>
        // gear automatically avoid flaming death.<br/>
        for ( Enumeration iter = entity.getMisc(); iter.hasMoreElements(); ) {<br/>
            Mounted mount = (Mounted) iter.nextElement();<br/>
            EquipmentType equip = mount.getType();<br/>
            if ( BattleArmor.ASSAULT_CLAW.equals(equip.getInternalName()) ) {<br/>
                phaseReport.append(entity.getDisplayName() )<br/>
                    .append( " is on fire, but is protected by its gear.\n" );<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        phaseReport.append( entity.getDisplayName() )<br/>
            .append( " is on fire.  Needs an 8+ to avoid destruction, rolls " )<br/>
            .append( boomroll )<br/>
            .append( " : ");<br/>
        if (boomroll &gt;= 8) {<br/>
            phaseReport.append("avoids successfully!\n");<br/>
        } else {<br/>
            phaseReport.append("fails to avoid horrible instant flaming death.\n");<br/>
            phaseReport.append(destroyEntity(entity, "fire"));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a piloting<br/>
     * skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.getMovementType() == Entity.MovementType.BIPED ||<br/>
            entity.getMovementType() == Entity.MovementType.QUAD) {<br/>
                // if this mech has 20+ damage, add another roll to the list.<br/>
                if (entity.damageThisPhase &gt;= 20) {<br/>
                    pilotRolls.addElement(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any non-mech units are standing in fire.  Called at the<br/>
     * end of the movement phase<br/>
     */<br/>
    public void checkForFlamingDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity instanceof Mech ||<br/>
                 entity.isDoomed() ||<br/>
                 entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if (curHex.contains(Terrain.FIRE)) {<br/>
                doFlamingDeath(entity);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if ((curHex.levelOf(Terrain.WATER) &gt; 1<br/>
            || (curHex.levelOf(Terrain.WATER) == 1 &amp;&amp; entity.isProne()))<br/>
            &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                roundReport.append("\n" ).append( entity.getDisplayName() ).append( " is underwater with damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * (used at end of weapons, physical phases)<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (!(entity instanceof Mech) || entity.isProne() || entity.isDoomed() || entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            int rolls = 0;<br/>
            StringBuffer reasons = new StringBuffer();<br/>
            PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
            for (Enumeration j = pilotRolls.elements(); j.hasMoreElements();) {<br/>
                final PilotingRollData modifier = (PilotingRollData)j.nextElement();<br/>
                if (modifier.getEntityId() == entity.getId()) {<br/>
                    rolls++;<br/>
                    if (reasons.length() &gt; 0) {<br/>
                        reasons.append(", ");<br/>
                    }<br/>
                    reasons.append(modifier.getPlainDesc());<br/>
                    roll.append(modifier);<br/>
                }<br/>
            }<br/>
            // any rolls needed?<br/>
            if (rolls == 0) {<br/>
                continue;<br/>
            }<br/>
            if (roll.getValue() == PilotingRollData.AUTOMATIC_FAIL || roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " must make " ).append( rolls ).append( " piloting skill roll(s) and automatically fails (" ).append( roll.getDesc() ).append( ").\n");<br/>
                doEntityFall(entity, roll);<br/>
            } else {<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " must make " ).append( rolls ).append( " piloting skill roll(s) (" ).append( reasons.toString() ).append( ").\n");<br/>
                phaseReport.append("The target is " ).append( roll.getValueAsString() ).append( " [" ).append( roll.getDesc() ).append( "].\n");<br/>
                for (int j = 0; j &lt; rolls; j++) {<br/>
                    final int diceRoll = Compute.d6(2);<br/>
                    phaseReport.append("    " ).append( entity.getDisplayName() ).append( " needs " ).append( roll.getValueAsString() ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
                    phaseReport.append((diceRoll &gt;= roll.getValue() ? "remains standing" : "falls") ).append( ".\n");<br/>
                    if (diceRoll &lt; roll.getValue()) {<br/>
                        doEntityFall(entity, roll);<br/>
                        // break rolling loop<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        pilotRolls.removeAllElements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     */<br/>
    private String damageCrew(Entity en, int damage) {<br/>
        String s = new String();<br/>
        <br/>
        if (!en.crew.isDead()) {<br/>
            en.crew.setHits(en.crew.getHits() + damage);<br/>
            s += "        Pilot of " + en.getDisplayName() + " \"" + en.crew.getName() + "\" takes " + damage + " damage.";<br/>
            if (en.crew.getHits() &lt; 6) {<br/>
                en.crew.setRollsNeeded(en.crew.getRollsNeeded() + damage);<br/>
            } else {<br/>
                en.crew.setDead(true);<br/>
                en.crew.setRollsNeeded(0);<br/>
                s += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
            }<br/>
        }<br/>
        <br/>
        return s;<br/>
    }<br/>
    <br/>
    /**<br/>
     * This checks if the mech pilot goes unconcious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    final int totalHits = e.getCrew().getHits();<br/>
            final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
            e.crew.setRollsNeeded(0);<br/>
            <br/>
            if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            for (int hit = totalHits - rollsNeeded + 1; hit &lt;= totalHits; hit++) {<br/>
                int roll = Compute.d6(2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rollTarget = Compute.getConciousnessNumber( hit );<br/>
                phaseReport.append("\nPilot of " ).append( e.getDisplayName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " \"" ).append( e.getCrew().getName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( "\" needs a " ).append( rollTarget<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " to stay concious.  Rolls " ).append( roll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " : ");<br/>
                if (roll &gt;= rollTarget) {<br/>
                    phaseReport.append("successful!");<br/>
                } else {<br/>
                    e.crew.setUnconcious(true);<br/>
                    e.crew.setKoThisRound(true);<br/>
                    phaseReport.append("blacks out.");<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            phaseReport.append("\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Make the rolls indicating whether any unconcious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            <br/>
            // only unconscious pilots of mechs can roll to wake up<br/>
            if (!e.isTargetable() || !e.crew.isUnconcious() ||<br/>
            e.crew.isKoThisRound() || !(e instanceof Mech)) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            int roll = Compute.d6(2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    int rollTarget = Compute.getConciousnessNumber( e.crew.getHits() );<br/>
            roundReport.append("\nPilot of " ).append( e.getDisplayName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " \"" ).append( e.crew.getName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( "\" needs a " ).append( rollTarget<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " to regain conciousness.  Rolls " ).append( roll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " : ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (roll &gt;= rollTarget) {<br/>
                roundReport.append("successful!");<br/>
                e.crew.setUnconcious(false);<br/>
            } else {<br/>
                roundReport.append("fails.");<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            roundReport.append("\n");<br/>
        }<br/>
    }<br/>
    <br/>
    public String damageEntity(Entity te, HitData hit, int damage) {<br/>
        return damageEntity(te, hit, damage, false);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals the listed damage to a mech.  Returns a description<br/>
     * string for the log.<br/>
     *<br/>
     * Currently mech only.<br/>
     *<br/>
     * @param te the target entity<br/>
     * @param hit the hit data for the location hit<br/>
     * @param damage the damage to apply<br/>
     * @param ammoExplosion ammo explosion type damage is handled slightly differently<br/>
     */<br/>
    private String damageEntity(Entity te, HitData hit, int damage, boolean ammoExplosion) {<br/>
        String desc = new String();<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;boolean isBattleArmor = (te instanceof BattleArmor);<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;boolean isPlatoon = !isBattleArmor &amp;&amp; (te instanceof Infantry);<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;Hex te_hex = null;<br/>
        <br/>
        int crits = hit.getEffect() == HitData.EFFECT_CRITICAL ? 1 : 0;<br/>
        //int loc = hit.getLocation();<br/>
        HitData nextHit = null;<br/>
<br/>
        // Is the infantry in the open?<br/>
        // TODO : do infantry take double damage in Swamp or Smoke<br/>
        if ( isPlatoon &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed() ) {<br/>
            te_hex = game.board.getHex( te.getPosition() );<br/>
            if ( te_hex != null &amp;&amp;<br/>
                 !te_hex.contains( Terrain.WOODS ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.ROUGH ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.RUBBLE ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.BUILDING ) ) {<br/>
                // PBI.  Damage is doubled.<br/>
                damage = damage * 2;<br/>
                desc += "\n        Infantry platoon caught in the open!!!  Damage doubled." ;<br/>
            }<br/>
        }<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;// Allocate the damage<br/>
        while (damage &gt; 0) {<br/>
            // let's resolve some damage!<br/>
            desc += "\n        " + te.getDisplayName() + " takes " + damage + " damage to " + te.getLocationAbbr(hit) + ".";<br/>
            <br/>
            // was the section destroyed earlier this phase?<br/>
            if (te.getInternal(hit) == Entity.ARMOR_DOOMED) {<br/>
                // cannot transfer a through armor crit if so<br/>
                crits = 0;<br/>
            }<br/>
<br/>
            // Does an exterior passenger absorb some of the damage?<br/>
            int nLoc = hit.getLocation();<br/>
            Entity passenger = te.getExteriorUnitAt( nLoc, hit.isRear() );<br/>
            if ( !ammoExplosion &amp;&amp;<br/>
                 null != passenger &amp;&amp; !passenger.isDoomed() ) {<br/>
<br/>
                // Yup.  Roll up some hit data for that passenger.<br/>
                desc += "\n            The passenger, " +<br/>
                    passenger.getDisplayName() + ", gets in the way.";<br/>
                HitData passHit = passenger.rollHitLocation<br/>
                    ( ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
<br/>
                // How much damage will the passenger absorb?<br/>
                int absorb = 0;<br/>
                HitData nextPassHit = passHit;<br/>
                do {<br/>
                    if ( 0 &lt; passenger.getArmor( nextPassHit ) ) {<br/>
                        absorb += passenger.getArmor( nextPassHit );<br/>
                    }<br/>
                    absorb += passenger.getInternal( nextPassHit );<br/>
                    nextPassHit = passenger.getTransferLocation( nextPassHit );<br/>
                } while ( damage &gt; absorb &amp;&amp; nextPassHit.getLocation() &gt;= 0 );<br/>
<br/>
                // Damage the passenger.<br/>
                desc += damageEntity( passenger, passHit, damage );<br/>
<br/>
                // Did some damage pass on?<br/>
                if ( damage &gt; absorb ) {<br/>
                    // Yup.  Remove the absorbed damage.<br/>
                    damage -= absorb;<br/>
                    desc += "\n    " + damage +<br/>
                        " damage point(s) passes on to " +<br/>
                        te.getDisplayName() + ".";<br/>
                } else {<br/>
                    // Nope.  Return our description.<br/>
                    return desc;<br/>
                }<br/>
<br/>
            } // End nLoc-has-exterior-passenger<br/>
<br/>
            // is this a mech dumping ammo being hit in the rear torso?<br/>
            boolean bTorso = (nLoc == Mech.LOC_CT || nLoc == Mech.LOC_RT || nLoc == Mech.LOC_LT);<br/>
            if (te instanceof Mech &amp;&amp; hit.isRear() &amp;&amp; bTorso) {<br/>
                for (Enumeration e = te.getAmmo(); e.hasMoreElements(); ) {<br/>
                    Mounted mAmmo = (Mounted)e.nextElement();<br/>
                    if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed() &amp;&amp; !mAmmo.isHit()) {<br/>
                        // doh.  explode it<br/>
                        desc += explodeEquipment(te, mAmmo.getLocation(), mAmmo);<br/>
                        mAmmo.setHit(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            // is there armor in the location hit?<br/>
            if (!ammoExplosion &amp;&amp; te.getArmor(hit) &gt; 0) {<br/>
                if (te.getArmor(hit) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(hit) - damage, hit);<br/>
                    te.damageThisPhase += damage;<br/>
                    damage = 0;<br/>
                    desc += " " + te.getArmor(hit) + " Armor remaining";<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    int absorbed = Math.max(te.getArmor(hit), 0);<br/>
                    te.setArmor(Entity.ARMOR_DESTROYED, hit);<br/>
                    te.damageThisPhase += absorbed;<br/>
                    damage -= absorbed;<br/>
                    desc += " Armor destroyed,";<br/>
                }<br/>
            }<br/>
            <br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(hit) &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Triggers a critical hit on Vehicles and Mechs.<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !isPlatoon &amp;&amp; !isBattleArmor ) {<br/>
                    crits++;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                    if (te.getInternal(hit) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(hit) - damage, hit);<br/>
                        te.damageThisPhase += damage;<br/>
                        damage = 0;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry platoons have men not "Internals".<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( isPlatoon ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " " + te.getInternal(hit) + " men alive.";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
                        desc += " " + te.getInternal(hit) + " Internal Structure remaining";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        int absorbed = Math.max(te.getInternal(hit), 0);<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        te.damageThisPhase += absorbed;<br/>
                        damage -= absorbed;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry have only one section.<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( isPlatoon ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " &lt;&lt;&lt;PLATOON KILLED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ( isBattleArmor ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " &lt;&lt;&lt;TROOPER KILLED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
                        desc += " &lt;&lt;&lt;SECTION DESTROYED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        if (hit.getLocation() == Mech.LOC_RT || hit.getLocation() == Mech.LOC_LT) {<br/>
                            int numEngineHits = 0;<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                            if (numEngineHits &gt; 2) {<br/>
                                // third engine hit<br/>
                                phaseReport.append(destroyEntity(te, "engine destruction"));<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
                <br/>
                // is the internal structure gone?  what are the transfer potentials?<br/>
                if (te.getInternal(hit) &lt;= 0) {<br/>
                    nextHit = te.getTransferLocation(hit);<br/>
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {<br/>
                        // Entity destroyed.  Ammo explosions are<br/>
                        // neither survivable nor salvagable.<br/>
                        desc += destroyEntity(te, "damage", !ammoExplosion,<br/>
                                              !ammoExplosion);<br/>
                        // nowhere for further damage to go<br/>
                        damage = 0;<br/>
                    } else if ( nextHit.getLocation() == Entity.LOC_NONE ) {<br/>
                        // Rest of the damage is wasted.<br/>
                        damage = 0;<br/>
                    } else if (ammoExplosion &amp;&amp; te.locationHasCase(hit.getLocation())) {<br/>
                        // remaining damage prevented<br/>
                        desc += " remaining " + damage + " damage prevented by CASE.";<br/>
                        damage = 0;<br/>
                    } else if (damage &gt; 0) {<br/>
                        // remaining damage transfers<br/>
                        desc += " " + damage + " damage transfers to "<br/>
                        + te.getLocationAbbr(nextHit) + ".";<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            // resolve special results<br/>
            if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {<br/>
                desc += "\n            Movement system damaged!";<br/>
                int nMP = te.getOriginalWalkMP();<br/>
                if (nMP &lt;= 1) {<br/>
                    ((Tank)te).immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    te_hex = game.board.getHex( te.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( te.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc += destroyEntity(te, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                }<br/>
                else {<br/>
                    te.setOriginalWalkMP(nMP - 1);<br/>
                }<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DESTROYED) {<br/>
                desc += "\n            Movement system destroyed!";<br/>
                ((Tank)te).immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;te_hex = game.board.getHex( te.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( te.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += destroyEntity(te, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_VEHICLE_TURRETLOCK) {<br/>
                desc += "\n            Turret locked!";<br/>
                ((Tank)te).lockTurret();<br/>
            }<br/>
            <br/>
            // roll all critical hits against this location<br/>
            for (int i = 0; i &lt; crits; i++) {<br/>
                desc += "\n" + criticalEntity(te, hit.getLocation());<br/>
            }<br/>
            crits = 0;<br/>
            <br/>
            if (te instanceof Mech &amp;&amp; hit.getLocation() == Mech.LOC_HEAD) {<br/>
                desc += "\n" + damageCrew(te, 1);<br/>
            }<br/>
            <br/>
            // loop to next location<br/>
            hit = nextHit;<br/>
        }<br/>
        <br/>
        return desc;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Rolls and resolves critical hits on mechs or vehicles.<br/>
     */<br/>
    private String criticalEntity(Entity en, int loc) {<br/>
        String desc = "        Critical hit on " + en.getLocationAbbr(loc) + ". ";<br/>
        int hits = 0;<br/>
        int roll = Compute.d6(2);<br/>
        desc += "Roll = " + roll + ";";<br/>
        if (roll &lt;= 7) {<br/>
            desc += " no effect.";<br/>
            return desc;<br/>
        } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
            hits = 1;<br/>
            desc += " 1 location.";<br/>
        } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
            hits = 2;<br/>
            desc += " 2 locations.";<br/>
        } else if (roll == 12) {<br/>
            if (en instanceof Tank) {<br/>
                hits = 3;<br/>
                desc += " 3 locations.";<br/>
            } else if (en.locationIsLeg(loc)) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                if (en.getInternal(loc) &gt; 0) {<br/>
                    destroyLocation(en, loc);<br/>
                }<br/>
                return desc;<br/>
            } else if (loc == Mech.LOC_RARM || loc == Mech.LOC_LARM) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                return desc;<br/>
            } else if (loc == Mech.LOC_HEAD) {<br/>
                desc += "&lt;&lt;&lt;HEAD BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                en.crew.setDead(true);<br/>
                desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                return desc;<br/>
            } else {<br/>
                // torso hit<br/>
                hits = 3;<br/>
                desc += " 3 locations.";<br/>
            }<br/>
        }<br/>
        <br/>
        // vehicle handle crits in their own 'special' way<br/>
        if (en instanceof Tank) {<br/>
            Tank tank = (Tank)en;<br/>
            for (int x = 0; x &lt; hits &amp;&amp; !tank.isDoomed(); x++) {<br/>
                switch (Compute.d6(1)) {<br/>
                    case 1 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Crew stunned for 3 turns";<br/>
                        // Carried units can't unload from a stunned transport.<br/>
                        // Units that escape a transport don't need to un-stun.<br/>
                        tank.stunCrew();<br/>
                        break;<br/>
                    case 2 :<br/>
                        // this one's ridiculous.  the 'main weapon' jams.<br/>
                        Mounted mWeap = tank.getMainWeapon();<br/>
                        if (mWeap == null) {<br/>
                            desc += "\n            No main weapon crit, because no main weapon!";<br/>
                        }<br/>
                        else {<br/>
                            desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; " + mWeap.getName() +<br/>
                            " jams.";<br/>
                            tank.setJammedWeapon(mWeap);<br/>
                        }<br/>
                        break;<br/>
                    case 3 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Engine destroyed.  Immobile.";<br/>
                        tank.immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hex te_hex = game.board.getHex( en.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( en.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += destroyEntity(en, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        break;<br/>
                    case 4 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Crew killed";<br/>
                        desc += destroyEntity(en, "crew death", true);<br/>
                        break;<br/>
                    case 5 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Fuel tank hit.  BOOM!";<br/>
                        desc += destroyEntity(en, "fuel tank explosion", false);<br/>
                       break;<br/>
                    case 6 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Power plant hit.  BOOM!";<br/>
                        desc += destroyEntity(en, "power plant destruction", false);<br/>
                        break;<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // transfer criticals, if needed<br/>
            if (hits &gt; 0 &amp;&amp; !en.hasHittableCriticals(loc)<br/>
            &amp;&amp; en.getTransferLocation(new HitData(loc)).getLocation() != Entity.LOC_DESTROYED) {<br/>
                loc = en.getTransferLocation(new HitData(loc)).getLocation();<br/>
                desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
                <br/>
                // may need to transfer crits twice--if you are shooting a CDA-3C Cicada and get lucky on the left arm two turns in a row<br/>
                if (hits &gt; 0 &amp;&amp; !en.hasHittableCriticals(loc)<br/>
                &amp;&amp; en.getTransferLocation(new HitData(loc)).getLocation() != Entity.LOC_DESTROYED) {<br/>
                    loc = en.getTransferLocation(new HitData(loc)).getLocation();<br/>
                    desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
                }<br/>
            }<br/>
            // roll criticals<br/>
            while (hits &gt; 0) {<br/>
                if (en.getHittableCriticals(loc) &lt;= 0) {<br/>
                    desc += "\n            Location has no more hittable critical slots.";<br/>
                    break;<br/>
                }<br/>
                int slot = Compute.randomInt(en.getNumberOfCriticals(loc));<br/>
                CriticalSlot cs = en.getCritical(loc, slot);<br/>
                if (cs == null || !cs.isHittable()) {<br/>
                    continue;<br/>
                }<br/>
                cs.setHit(true);<br/>
                switch(cs.getType()) {<br/>
                    case CriticalSlot.TYPE_SYSTEM :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + Mech.systemNames[cs.getIndex()] + ".";<br/>
                        switch(cs.getIndex()) {<br/>
                            case Mech.SYSTEM_COCKPIT :<br/>
                                // boink!<br/>
                                en.crew.setDead(true);<br/>
                                desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                                break;<br/>
                            case Mech.SYSTEM_ENGINE :<br/>
                                int numEngineHits = 0;<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                                if (numEngineHits &gt; 2) {<br/>
                                    // third engine hit<br/>
                                    desc += destroyEntity(en, "engine destruction");<br/>
                                }<br/>
                                break;<br/>
                            case Mech.SYSTEM_GYRO :<br/>
                                if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                                    // gyro destroyed<br/>
                                    pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 3, "gyro destroyed"));<br/>
                                } else {<br/>
                                    // first gyro hit<br/>
                                    pilotRolls.addElement(new PilotingRollData(en.getId(), 3, "gyro hit"));<br/>
                                }<br/>
                                break;<br/>
                            case Mech.ACTUATOR_UPPER_LEG :<br/>
                            case Mech.ACTUATOR_LOWER_LEG :<br/>
                            case Mech.ACTUATOR_FOOT :<br/>
                                // leg/foot actuator piloting roll<br/>
                                pilotRolls.addElement(new PilotingRollData(en.getId(), 1, "leg/foot actuator hit"));<br/>
                                break;<br/>
                            case Mech.ACTUATOR_HIP :<br/>
                                // hip piloting roll<br/>
                                pilotRolls.addElement(new PilotingRollData(en.getId(), 2, "hip actuator hit"));<br/>
                                break;<br/>
                        }<br/>
                        break;<br/>
                    case CriticalSlot.TYPE_EQUIPMENT :<br/>
                        Mounted mounted = en.getEquipment(cs.getIndex());<br/>
                        EquipmentType eqType = mounted.getType();<br/>
                        boolean hitBefore = mounted.isHit();<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + mounted.getDesc() + ".";<br/>
                        mounted.setHit(true);<br/>
<br/>
                        // If the item is the ECM suite of a Mek Stealth system<br/>
                        // then it's destruction turns off the stealth.<br/>
                        if ( !hitBefore &amp;&amp; eqType instanceof MiscType &amp;&amp;<br/>
                             eqType.hasFlag(MiscType.F_ECM) &amp;&amp;<br/>
                             mounted.getLinkedBy() != null ) {<br/>
                            Mounted stealth = mounted.getLinkedBy();<br/>
                            desc += "\n       " + stealth.getType().getName() +<br/>
                               " will stop functioning at end of turn.";<br/>
                            stealth.setMode( "Off" );<br/>
                        }<br/>
<br/>
                        // Handle equipment explosions.<br/>
                        if (eqType.isExplosive() &amp;&amp; !hitBefore) {<br/>
                            desc += explodeEquipment(en, loc, slot);<br/>
                        }<br/>
                        break;<br/>
                }<br/>
                hits--;<br/>
<br/>
            }<br/>
        }<br/>
        <br/>
        return desc;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    private void destroyLocation(Entity en, int loc) {<br/>
        // if it's already marked as destroyed, don't bother<br/>
        if (en.getInternal(loc) &lt; 0) {<br/>
            return;<br/>
        }<br/>
        // mark armor, internal as doomed<br/>
        en.setArmor(Entity.ARMOR_DOOMED, loc, false);<br/>
        en.setInternal(Entity.ARMOR_DOOMED, loc);<br/>
        if (en.hasRearArmor(loc)) {<br/>
            en.setArmor(Entity.ARMOR_DOOMED, loc, true);<br/>
        }<br/>
        // equipment marked missing<br/>
        for (Enumeration i = en.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setMissing(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as missing<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                cs.setMissing(true);<br/>
            }<br/>
        }<br/>
        // if it's a leg, the entity falls<br/>
        if (loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
            pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 5, "leg destroyed"));<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Mech.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Mark the unit as destroyed!  Units transported in the destroyed unit<br/>
     * will get a chance to escape.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason) {<br/>
        return destroyEntity( entity, reason, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the <br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason, <br/>
                                 boolean survivable) {<br/>
        // Generally, the entity can still be salvaged.<br/>
        return this.destroyEntity( entity, reason, survivable, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the <br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @param   canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that indicates if<br/>
     *          the unit can be salvaged (or cannibalized for spare parts).<br/>
     *          If &lt;code&gt;true&lt;/code&gt;, salvage operations are possible, if<br/>
     *          &lt;code&gt;false&lt;/code&gt;, the unit is too badly damaged.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason, <br/>
                                 boolean survivable, boolean canSalvage) {<br/>
        StringBuffer sb = new StringBuffer();<br/>
<br/>
        // The unit can suffer an ammo explosion after it has been destroyed.<br/>
        int condition = Game.UNIT_SALVAGEABLE;<br/>
        if ( !canSalvage ) {<br/>
            entity.setSalvage( canSalvage );<br/>
            condition = Game.UNIT_DEVASTATED;<br/>
        }<br/>
<br/>
        // Ignore entities that are already destroyed.<br/>
        if (!entity.isDoomed() &amp;&amp; !entity.isDestroyed()) {<br/>
            sb.append("\n*** ");<br/>
            sb.append(entity.getDisplayName());<br/>
            sb.append(" DESTROYED by ");<br/>
            sb.append(reason);<br/>
            sb.append("! ***\n");<br/>
            <br/>
            entity.setDoomed(true);<br/>
<br/>
            // Handle escape of transported units.<br/>
            Enumeration iter = entity.getLoadedUnits().elements();<br/>
            if ( iter.hasMoreElements() ) {<br/>
                Entity other = null;<br/>
                Coords curPos = entity.getPosition();<br/>
                Coords nextPos = null;<br/>
                Hex entityHex = game.getBoard().getHex( curPos );<br/>
                Hex nextHex = null;<br/>
                int curFacing = entity.getFacing();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    other = (Entity) iter.nextElement();<br/>
<br/>
                    // Can the other unit survive?<br/>
                    if ( !survivable ) {<br/>
<br/>
                        // Nope.<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        sb.append("\n*** " ).append( other.getDisplayName() +<br/>
                                  " was trapped in the wreckage. ***\n");<br/>
<br/>
                    }<br/>
                    // Can we unload the unit to the current hex?<br/>
                    else if (null != Compute.stackingViolation(game, other.getId(), curPos)<br/>
                             || other.isHexProhibited(entityHex) ) {<br/>
                        // TODO : this isn't covered in the rules<br/>
                        // Nope.<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        sb.append("\n*** " ).append( other.getDisplayName() +<br/>
                                  " tried to escape the wreckage, but couldn't. ***\n");<br/>
                    } // End can-not-unload<br/>
                    else {<br/>
                        // The other unit survives.<br/>
                        this.unloadUnit( entity, other, curPos, curFacing );<br/>
                    }<br/>
<br/>
                } // Handle the next transported unit.<br/>
<br/>
            } // End has-transported-unit<br/>
<br/>
            // Is this unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                sb.append( swarmer.getDisplayName() );<br/>
                sb.append( " ends its swarm attack.\n" );<br/>
                this.entityUpdate( swarmerId );<br/>
            }<br/>
<br/>
            // Is this unit swarming somebody?<br/>
            final int swarmedId = entity.getSwarmTargetId();<br/>
            if ( Entity.NONE != swarmedId ) {<br/>
                final Entity swarmed = game.getEntity( swarmedId );<br/>
                swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                entity.setSwarmTargetId( Entity.NONE );<br/>
                sb.append( swarmed.getDisplayName() );<br/>
                sb.append( " is freed from its swarm attack.\n" );<br/>
                this.entityUpdate( swarmedId );<br/>
            }<br/>
<br/>
        } // End entity-not-already-destroyed.<br/>
<br/>
        return sb.toString();<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes a piece of equipment on a mech explode!  POW!  This expects either<br/>
     * ammo, or an explosive weapon.<br/>
     */<br/>
    private String explodeEquipment(Entity en, int loc, int slot) {<br/>
        return explodeEquipment(en, loc, en.getEquipment(en.getCritical(loc, slot).getIndex()));<br/>
    } <br/>
    <br/>
    private String explodeEquipment(Entity en, int loc, Mounted mounted) {<br/>
        StringBuffer desc = new StringBuffer();<br/>
        // is this already destroyed?<br/>
        if (mounted.isDestroyed()) {<br/>
            System.err.println("server: explodeEquipment called on destroyed"<br/>
            + " equipment (" + mounted.getName() + ")");<br/>
            return "";<br/>
        }<br/>
        <br/>
        // special-case.  RACs only explode when jammed<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp; <br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
            if (!mounted.isJammed()) {<br/>
                return "";<br/>
            }<br/>
        }<br/>
<br/>
        // Inferno ammo causes heat buildup as well as the damage<br/>
        if ( mounted.getType() instanceof AmmoType &amp;&amp;<br/>
             ((AmmoType)mounted.getType()).getMunitionType() == AmmoType.M_INFERNO) {<br/>
            en.heatBuildup += 30;<br/>
        }<br/>
<br/>
        // determine and deal damage<br/>
        int damage = mounted.getExplosionDamage();<br/>
        <br/>
        if (damage &lt;= 0) {<br/>
            return "";<br/>
        }<br/>
        <br/>
        desc.append("\n*** ");<br/>
        desc.append(mounted.getName());<br/>
        desc.append(" EXPLODES!  ");<br/>
        desc.append(damage);<br/>
        desc.append(" DAMAGE! ***");<br/>
        <br/>
        desc.append(damageEntity(en, new HitData(loc), damage, true));<br/>
        desc.append("\n");<br/>
        if (!en.isDoomed() &amp;&amp; !en.isDestroyed()) {<br/>
            desc.append(damageCrew(en, 2));<br/>
            desc.append("\n");<br/>
        }<br/>
        <br/>
        return desc.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                if (cs == null || cs.isDestroyed() || cs.isHit() || cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {<br/>
                    continue;<br/>
                }<br/>
                Mounted mounted = entity.getEquipment(entity.getCritical(j, k).getIndex());<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if (!atype.isExplosive()) {<br/>
                    continue;<br/>
                }<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds. <br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            return explodeEquipment(entity, boomloc, boomslot);<br/>
        } else {<br/>
            return "  Luckily, there is no ammo to explode.\n";<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, int facing, PilotingRollData roll) {<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            phaseReport.append("But, since the 'mech is making a death from above attack, damage will be dealt during the physical phase.\n");<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }<br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
            case 1:<br/>
            case 2:<br/>
                side = "right side";<br/>
                table = ToHitData.SIDE_RIGHT;<br/>
                break;<br/>
            case 3:<br/>
                side = "rear";<br/>
                table = ToHitData.SIDE_REAR;<br/>
                break;<br/>
            case 4:<br/>
            case 5:<br/>
                side = "left side";<br/>
                table = ToHitData.SIDE_LEFT;<br/>
                break;<br/>
            case 0:<br/>
            default:<br/>
                side = "front";<br/>
                table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        // calculate damage<br/>
        int damage = (int)Math.round(entity.getWeight() / 10) * (height + 1);<br/>
        <br/>
        // TODO: only fall to surface of water<br/>
        if (game.board.getHex(fallPos).levelOf(Terrain.WATER) &gt; 0) {<br/>
            damage = (int)Math.ceil(damage / 2.0);<br/>
        }<br/>
        <br/>
        // report falling<br/>
        phaseReport.append("    " ).append( entity.getDisplayName() ).append( " falls on its " ).append( side ).append( ", suffering " ).append( damage ).append( " damage.");<br/>
<br/>
        // Any swarming infantry will be dislodged, but we don't want to<br/>
        // interrupt the fall's report.  We have to get the ID now because<br/>
        // the fall may kill the entity which will reset the attacker ID.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            phaseReport.append(damageEntity(entity, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        <br/>
        // pilot damage?<br/>
        roll.removeAutos();<br/>
<br/>
        if (height &gt; 0) {<br/>
            roll.addModifier(height, "height of fall");<br/>
        }<br/>
        <br/>
        if (roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            phaseReport.append("\nPilot of " ).append( entity.getDisplayName()<br/>
            ).append( " \"" ).append( entity.crew.getName() ).append( "\" cannot avoid damage.\n");<br/>
            phaseReport.append(damageCrew(entity, 1) ).append( "\n");<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("\nPilot of " ).append( entity.getDisplayName()<br/>
            ).append( " \"" ).append( entity.crew.getName() ).append( "\" must roll " ).append( roll.getValueAsString()<br/>
            ).append( " to avoid damage; rolls " ).append( diceRoll ).append( " : ");<br/>
            if (diceRoll &gt;= roll.getValue()) {<br/>
                phaseReport.append("succeeds.\n");<br/>
            } else {<br/>
                phaseReport.append("fails.\n");<br/>
                phaseReport.append(damageCrew(entity, 1) ).append( "\n");<br/>
            }<br/>
        }<br/>
         <br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Only Mechs can fall prone.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entity.setProne(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
<br/>
        // Now dislodge any swarming infantry.<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            entity.setSwarmAttackerId( Entity.NONE );<br/>
            swarmer.setSwarmTargetId( Entity.NONE );<br/>
            // Did the infantry fall into water?<br/>
            Hex fallHex = game.board.getHex( fallPos );<br/>
            if ( fallHex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
                // Swarming infantry die.<br/>
                swarmer.setPosition( fallPos );<br/>
                phaseReport.append("    ")<br/>
                    .append(swarmer.getDisplayName())<br/>
                    .append(" is dislodged and drowns!")<br/>
                    .append(destroyEntity(swarmer, "a watery grave", false));<br/>
            } else {<br/>
                // Swarming infantry take an 11 point hit.<br/>
                // ASSUMPTION : damage should not be doubled.<br/>
                phaseReport.append("    ")<br/>
                    .append(swarmer.getDisplayName())<br/>
                    .append(" is dislodged and suffers 11 damage.")<br/>
                    .append( damageEntity(swarmer, <br/>
                                          swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),<br/>
                                          11) )<br/>
                    .append( "\n" );<br/>
            }<br/>
            swarmer.setPosition( fallPos );<br/>
            entityUpdate( swarmerId );<br/>
        } // End dislodge-infantry<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, PilotingRollData roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
    <br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, PilotingRollData roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
    /** Make fires spread, smoke spread, and make sure that all fires<br/>
     * started this turn are marked as "burning" for next turn.<br/>
     * <br/>
     * A "FIRE" terrain has one of two levels: <br/>
     *  1 (Created this turn, and so can't spread of generate heat)<br/>
     *  2 (Created as a result of spreading fire or on a previous turn)<br/>
     *<br/>
     * Since fires created at end of turn act normally in the following turn, <br/>
     * spread fires have level 2.<br/>
     *<br/>
     * At NO TIME should any fire created outside this function have a level of <br/>
     * 2, nor should anything except this function SET fires to level 2.<br/>
     * <br/>
     * Newly created "spread" fires have a level of 1, so that they do not <br/>
     * spread in the turn they are created.  After all spreading has been <br/>
     * completed, all burning hexes are set to level 2.<br/>
     */<br/>
    private void resolveFire() {<br/>
        Board board = game.getBoard();<br/>
        int width = board.width;<br/>
        int height = board.height;<br/>
        int windDirection = game.getWindDirection();<br/>
        <br/>
        phaseReport.append("\n\nResolving fire movement \n ------------------------\n");<br/>
        // Cycle through all hexes, checking for fire.<br/>
        for (int currentXCoord = 0; currentXCoord &lt; width; currentXCoord++ ) {<br/>
            <br/>
            for (int currentYCoord = 0; currentYCoord &lt; height;<br/>
                 currentYCoord++) {<br/>
                Coords currentCoords = new Coords(currentXCoord,<br/>
                                                  currentYCoord);<br/>
                Hex currentHex = board.getHex(currentXCoord, currentYCoord);<br/>
                boolean infernoBurning = board.burnInferno( currentCoords );<br/>
<br/>
                // If the woods has been cleared, put non-inferno fires out.<br/>
                if ( currentHex.contains(Terrain.FIRE) &amp;&amp; !infernoBurning &amp;&amp;<br/>
                     !(currentHex.contains(Terrain.WOODS))) {<br/>
                    removeFire(currentXCoord, currentYCoord, currentHex);<br/>
                }<br/>
<br/>
                // Was the fire was started on a previous turn?<br/>
                else if (currentHex.levelOf(Terrain.FIRE) == 2)<br/>
                {<br/>
                    if ( infernoBurning ) {<br/>
                        phaseReport.append( "Inferno fire at " );<br/>
                    } else {<br/>
                        phaseReport.append( "Fire at " );<br/>
                    }<br/>
                    phaseReport.append( currentCoords.getBoardNum() )<br/>
                        .append( " is burning brightly.\n" );<br/>
                    spreadFire(currentXCoord, currentYCoord, windDirection);<br/>
                }  // End the Else If Hex was on fire previously<br/>
            }  // end the loop through Y coordinates<br/>
        }  // end the loop through X coordinates<br/>
        //  Loop a second time, to set all fires to level 2 before next turn, and add smoke.<br/>
        for (int currentXCoord = 0; currentXCoord &lt; width; currentXCoord++ ) {<br/>
            <br/>
            for (int currentYCoord = 0; currentYCoord &lt; height; currentYCoord++) {<br/>
                Coords currentCoords = new Coords(currentXCoord, currentYCoord);<br/>
                Hex currentHex = board.getHex(currentXCoord,currentYCoord);<br/>
                // if the fire in the hex was started this turn<br/>
                if (currentHex.levelOf(Terrain.FIRE) == 1) {<br/>
                    currentHex.removeTerrain(Terrain.FIRE);<br/>
                    currentHex.addTerrain(new Terrain(Terrain.FIRE, 2));<br/>
                    sendChangedHex(currentCoords);<br/>
                    phaseReport.append( "Fire at " )<br/>
                        .append( currentCoords.getBoardNum() )<br/>
                        .append( " was started this round.\n" );<br/>
                }<br/>
                if (currentHex.contains(Terrain.FIRE)) {<br/>
                    addSmoke(currentXCoord, currentYCoord, windDirection);<br/>
                    addSmoke(currentXCoord, currentYCoord, (windDirection+1)%6);<br/>
                    addSmoke(currentXCoord, currentYCoord, (windDirection+5)%6);<br/>
                    board.initializeAround(currentXCoord,currentYCoord);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }  // End the ResolveFire() method<br/>
    <br/>
    /**<br/>
     * Spreads the fire around the specified coordinates.<br/>
     */<br/>
    public void spreadFire(int x, int y, int windDir) {<br/>
        Coords src = new Coords(x, y);<br/>
        Coords nextCoords = src.translated(windDir);<br/>
        <br/>
        spreadFire(nextCoords, 9);<br/>
        <br/>
        // Spread to the next hex downwind on a 12 if the first hex wasn't burning...<br/>
        Hex nextHex = game.getBoard().getHex(nextCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.contains(Terrain.FIRE))) {<br/>
            // we've already gone one step in the wind direction, now go another<br/>
            spreadFire(nextCoords.translated(windDir), 12);<br/>
        }<br/>
        <br/>
        // spread fire 60 degrees clockwise....<br/>
        spreadFire(src.translated((windDir + 1) % 6), 11);<br/>
        <br/>
        // spread fire 60 degrees counterclockwise<br/>
        spreadFire(src.translated((windDir + 5) % 6), 11);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Spreads the fire, and reports the spread, to the specified hex, if<br/>
     * possible and the fire roll is made.<br/>
     */<br/>
    public void spreadFire(Coords coords, int roll) {<br/>
        Hex hex = game.getBoard().getHex(coords);<br/>
        if (burn(hex, roll)) {<br/>
            sendChangedHex(coords);<br/>
            phaseReport.append("Fire spreads to " ).append( coords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     */<br/>
    public boolean burn(Hex hex, int roll, boolean bAnyTerrain) {<br/>
        if (!game.getOptions().booleanOption("fire") || null == hex <br/>
                || hex.contains(Terrain.FIRE)) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        if (!bAnyTerrain &amp;&amp; !(hex.contains(Terrain.WOODS))) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        int fireRoll = Compute.d6(2);<br/>
        if (fireRoll &gt;= roll) {<br/>
            hex.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
            return true;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
    }<br/>
    <br/>
    // default signature, assuming only woods can burn<br/>
    public boolean burn(Hex hex, int roll) {<br/>
        return burn(hex, roll, false);<br/>
    }<br/>
    <br/>
    <br/>
    public void removeFire(int x, int y, Hex hex) {<br/>
        Coords fireCoords = new Coords(x, y);<br/>
        int windDir = game.getWindDirection();<br/>
        hex.removeTerrain(Terrain.FIRE);<br/>
        sendChangedHex(fireCoords);<br/>
        removeSmoke(x, y, windDir);<br/>
        removeSmoke(x, y, (windDir + 1) % 6);<br/>
        removeSmoke(x, y, (windDir + 5) % 6);<br/>
        phaseReport.append("Fire at " ).append( fireCoords.getBoardNum() ).append( " goes out due to lack of fuel!\n");<br/>
    }<br/>
    <br/>
    // called when a fire is burning.  Adds smoke to hex in the direction specified.  Called 3 times per fire hex,<br/>
    public void addSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        Hex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.contains(Terrain.SMOKE))) {<br/>
            nextHex.addTerrain(new Terrain(Terrain.SMOKE, 1));<br/>
            sendChangedHex(smokeCoords);<br/>
            phaseReport.append("Smoke fills " ).append( smokeCoords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    public void removeSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        Hex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; nextHex.contains(Terrain.SMOKE)) {<br/>
            nextHex.removeTerrain(Terrain.SMOKE);<br/>
            sendChangedHex(smokeCoords);<br/>
            phaseReport.append("Smoke clears from " ).append( smokeCoords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Scans the boards directory for map boards of the appropriate size<br/>
     * and returns them.<br/>
     */<br/>
    private Vector scanForBoards(int boardWidth, int boardHeight) {<br/>
        Vector boards = new Vector();<br/>
        <br/>
        File boardDir = new File("data/boards");<br/>
        <br/>
        // just a check...<br/>
        if (!boardDir.isDirectory()) {<br/>
            return boards;<br/>
        }<br/>
        <br/>
        // scan files<br/>
        String[] fileList = boardDir.list();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(fileList[i], boardWidth, boardHeight)) {<br/>
                boards.addElement(fileList[i].substring(0, fileList[i].lastIndexOf(".board")));<br/>
            }<br/>
        }<br/>
        <br/>
        // if there are any boards, add these:<br/>
        if (boards.size() &gt; 0) {<br/>
            boards.insertElementAt(MapSettings.BOARD_RANDOM, 0);<br/>
            boards.insertElementAt(MapSettings.BOARD_SURPRISE, 1);<br/>
        }<br/>
        <br/>
        //TODO: alphabetize files?<br/>
        <br/>
        return boards;<br/>
    }<br/>
    <br/>
    private boolean doBlind() {<br/>
        return (game.getOptions().booleanOption("double_blind") &amp;&amp;<br/>
        game.phase &gt;= Game.PHASE_INITIATIVE);<br/>
    }<br/>
    <br/>
    /**<br/>
     * In a double-blind game, update only visible entities.  Otherwise,<br/>
     * update everyone<br/>
     */<br/>
    private void entityUpdate(int nEntityID) {<br/>
        if (doBlind()) {<br/>
            Entity eTarget = game.getEntity(nEntityID);<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            Vector vCanSee = new Vector();<br/>
            vCanSee.addElement(eTarget.getOwner());<br/>
            Vector vEntities = game.getEntitiesVector();<br/>
            for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
                Entity e = (Entity)vEntities.elementAt(x);<br/>
                if (vCanSee.contains(e.getOwner()) || !e.isActive()) {<br/>
                    continue;<br/>
                }<br/>
                if (Compute.canSee(game, e, eTarget)) {<br/>
                    vCanSee.addElement(e.getOwner());<br/>
                }<br/>
            }<br/>
            // send an entity update to everyone who can see<br/>
            Packet pack = createEntityPacket(nEntityID);<br/>
            for (int x = 0; x &lt; vCanSee.size(); x++) {<br/>
                Player p = (Player)vCanSee.elementAt(x);<br/>
                send(p.getId(), pack);<br/>
            }<br/>
            // send an entity delete to everyone else<br/>
            pack = createRemoveEntityPacket(nEntityID);<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                if (!vCanSee.contains(vPlayers.elementAt(x))) {<br/>
                    Player p = (Player)vPlayers.elementAt(x);<br/>
                    send(p.getId(), pack);<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // everyone can see<br/>
            send(createEntityPacket(nEntityID));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send the complete list of entities to the players.<br/>
     * If double_blind is in effect, enforce it by filtering the entities<br/>
     */<br/>
    private void entityAllUpdate() {<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                Player p = (Player)vPlayers.elementAt(x);<br/>
                send(p.getId(), createFilteredEntitiesPacket(p));<br/>
            }<br/>
        }<br/>
        else {<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Filters an entity vector according to LOS<br/>
     */<br/>
    private Vector filterEntities(Player pViewer, Vector vEntities) {<br/>
        Vector vCanSee = new Vector();<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        Vector vMyEntities = new Vector();<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            if (e.getOwner() == pViewer) {<br/>
                vMyEntities.addElement(e);<br/>
            }<br/>
        }<br/>
        <br/>
        for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
            Entity e = (Entity)vEntities.elementAt(x);<br/>
            if (vMyEntities.contains(e)) {<br/>
                vCanSee.addElement(e);<br/>
                continue;<br/>
            }<br/>
            for (int y = 0; y &lt; vMyEntities.size(); y++) {<br/>
                Entity e2 = (Entity)vMyEntities.elementAt(y);<br/>
                if (Compute.canSee(game, e2, e)) {<br/>
                    vCanSee.addElement(e);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets an entity ready status to false<br/>
     */<br/>
    private void receiveEntityReady(Packet pkt, int connIndex) {<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveLast = game.getOptions().booleanOption("inf_move_last");<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getTurn().getPlayerNum() == connIndex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // If "inf_move_mutli" option is selected, and we're in the middle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // of a block of Infantry fires, entity had better be an Infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // platoon owned by the most recent player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMoveMulti &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( !(entity instanceof Infantry) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   entity.getOwnerId() != turnLastPlayerId ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }        <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // We passed the cheat checks.<br/>
            entity.setDone(true);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Is the entity Infantry?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Increment the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Record the player moving the infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do infantry move in blocks?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( infMoveMulti ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Are we at the end of a block?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  Reset the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nope.  Decrement the turn index.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnIndex--;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End inf_move_multi<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } // End entity-is-infantry<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
            System.out.println("server.receiveEntityReady: got an invalid ready message");<br/>
        }<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
     */<br/>
    private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        <br/>
        entity.restore();<br/>
        entity.setOwner(getPlayer(connIndex));<br/>
<br/>
        // Only assign an entity ID when the client hasn't.<br/>
        if ( Entity.NONE == entity.getId() ) { <br/>
            entity.setId(entityCounter++); <br/>
        }<br/>
        game.addEntity(entity.getId(), entity);<br/>
        <br/>
        send(createAddEntityPacket(entity.getId()));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Updates an entity with the info from the client.  Only valid to do this<br/>
     * durring the lounge phase.<br/>
     */<br/>
    private void receiveEntityUpdate(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        Entity oldEntity = game.getEntity(entity.getId());<br/>
        if (oldEntity != null &amp;&amp; oldEntity.getOwner() == getPlayer(connIndex)) {<br/>
            entity.restore();<br/>
            entity.setOwner(getPlayer(connIndex));<br/>
            game.setEntity(entity.getId(), entity);<br/>
            <br/>
            send(createEntitiesPacket());<br/>
        } else {<br/>
            // hey!<br/>
        }<br/>
    }<br/>
    <br/>
    private void receiveEntityModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        Mounted m = e.getEquipment(equipId);<br/>
        <br/>
        // a mode change for ammo means dumping<br/>
        if (m.getType() instanceof AmmoType) {<br/>
            m.setPendingDump(mode == 1);<br/>
        }<br/>
        else {<br/>
            m.setMode(mode);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        Entity entity = game.getEntity(entityId);<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)) {<br/>
            game.removeEntity(entityId);<br/>
            send(createRemoveEntityPacket(entityId, Game.UNIT_NEVER_JOINED));<br/>
        } else {<br/>
            // hey! that's not your entity<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerDone(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        getPlayer(connIndex).setDone(ready);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets game options, providing that the player has specified the password<br/>
     * correctly.<br/>
     *<br/>
     * @returns true if any options have been successfully changed.<br/>
     */<br/>
    private boolean receiveGameOptions(Packet packet, int connId) {<br/>
        // check password<br/>
        if (password != null &amp;&amp; password.length() &gt; 0 &amp;&amp; !password.equals(packet.getObject(0))) {<br/>
            sendServerChat(connId, "The password you specified to change game options is incorrect.");<br/>
            return false;<br/>
        }<br/>
        <br/>
        int changed = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infLastValue =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_last").booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMultiValue =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_multi").booleanValue();<br/>
        <br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            GameOption option = (GameOption)i.nextElement();<br/>
            GameOption originalOption = game.getOptions().getOption(option.getShortName());<br/>
            <br/>
            if (originalOption == null) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            sendServerChat("Player " + getPlayer(connId).getName() + " changed option \"" + originalOption.getFullName() + "\" to " + option.stringValue() + ".");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Record mutually-exclusive infantry move options.<br/>
            if ( option.getShortName().equals("inf_move_last") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infLastValue = option.booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    else if ( option.getShortName().equals("inf_move_multi") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infMultiValue = option.booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
            originalOption.setValue(option.getValue());<br/>
            changed++;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Infantry move options can't BOTH be on!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( infLastValue &amp;&amp; (infLastValue == infMultiValue) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    sendServerChat("Player " + getPlayer(connId).getName() + " tried to set BOTH \"" + game.getOptions().getOption("inf_move_last").getFullName() + "\" and \""  + game.getOptions().getOption("inf_move_multi").getFullName() + "\" to true.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    sendServerChat("Clearing *BOTH* options.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_last").setValue(false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_multi").setValue(false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    changed += 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        return changed &gt; 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    <br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerDones() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(createPlayerDonePacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerDonePacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isDone());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the map settings<br/>
     */<br/>
    private Packet createMapSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing temporary map settings as a response to a<br/>
     * client query<br/>
     */<br/>
    private Packet createMapQueryPacket(MapSettings temp) {<br/>
        return new Packet(Packet.COMMAND_QUERY_MAP_SETTINGS, temp);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createGameSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, game.getOptions());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.board);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Creates a packet containing the round report<br/>
     */<br/>
    private Packet createReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORT, roundReport.toString());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing all entities visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredEntitiesPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, filterEntities(p, game.getEntitiesVector()));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the addition of an entity<br/>
     */<br/>
    private Packet createAddEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_ADD, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     * Maintained for backwards compatability.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId) {<br/>
        return this.createRemoveEntityPacket(entityId, Game.UNIT_SALVAGEABLE);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @param   condition - the &lt;code&gt;int&lt;/code&gt; condition the unit was in.<br/>
     *          This value must be one of &lt;code&gt;Game.UNIT_IN_RETREAT&lt;/code&gt;,<br/>
     *          &lt;code&gt;Game.UNIT_SALVAGEABLE&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_DEVASTATED&lt;/code&gt; or an<br/>
     *          &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId, int condition) {<br/>
        if ( condition != Game.UNIT_NEVER_JOINED &amp;&amp;<br/>
             condition != Game.UNIT_IN_RETREAT &amp;&amp;<br/>
             condition != Game.UNIT_SALVAGEABLE &amp;&amp;<br/>
             condition != Game.UNIT_DEVASTATED ) {<br/>
            throw new IllegalArgumentException( "Unknown unit condition: " +<br/>
                                                condition );<br/>
        }<br/>
        Object[] array = new Object[2];<br/>
        array[0] = new Integer(entityId);<br/>
        array[1] = new Integer(condition);<br/>
        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet indicating end of game, including detailed unit status<br/>
     */<br/>
    private Packet createEndOfGamePacket() {<br/>
        return new Packet(Packet.COMMAND_END_OF_GAME, getDetailedVictoryReport());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(int connId, String origin, String message) {<br/>
        send(connId, new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(String origin, String message) {<br/>
        String chat = origin + ": " + message;<br/>
        send(new Packet(Packet.COMMAND_CHAT, chat));<br/>
        log.append(chat);<br/>
    }<br/>
    <br/>
    public void sendServerChat(int connId, String message) {<br/>
        sendChat(connId, "***Server", message);<br/>
    }<br/>
    <br/>
    public void sendServerChat(String message) {<br/>
        sendChat("***Server", message);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing a hex, and the coordinates it goes at.<br/>
     */<br/>
    private Packet createHexChangePacket(Coords coords, Hex hex) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = coords;<br/>
        data[1] = hex;<br/>
        return new Packet(Packet.COMMAND_CHANGE_HEX, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends notification to clients that the specified hex has changed.<br/>
     */<br/>
    public void sendChangedHex(Coords coords) {<br/>
        send(createHexChangePacket(coords, game.board.getHex(coords)));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(Vector vector) {<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, vector);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
        packet.zipData();<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        packet.zipData();<br/>
        getClient(connId).send(packet);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        getPendingConnection(connId).send(packet);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process an in-game command<br/>
     */<br/>
    private void processCommand(int connId, String commandString) {<br/>
        String[] args;<br/>
        String commandName;<br/>
        // all tokens are read as strings; if they're numbers, string-ize 'em.<br/>
        StringTokenizer st = new StringTokenizer(commandString);<br/>
        args = new String[st.countTokens()];<br/>
        for (int i = 0; i &lt; args.length; i++) {<br/>
            args[i] = st.nextToken();<br/>
        }<br/>
        <br/>
        // figure out which command this is<br/>
        commandName = args[0].substring(1);<br/>
        <br/>
        // process it<br/>
        ServerCommand command = getCommand(commandName);<br/>
        if (command != null) {<br/>
            command.run(connId, args);<br/>
        } else {<br/>
            sendServerChat(connId, "Command not recognized.  Type /help for a list of commands.");<br/>
        }<br/>
    }<br/>
 <br/>
    /**<br/>
     * Calculate the piloting skill roll modifier, based upon the number<br/>
     * of hexes moved this phase.<br/>
     */<br/>
    private int getMovementPSRModifier( int distance ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( distance &gt; 10 ) // 11+ hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 7 ) // 8-10 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 4 ) // 5-7 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 2 ) // 3-4 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return -1; // 0-2 hexes<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a packet<br/>
     */<br/>
    synchronized void handle(int connId, Packet packet) {<br/>
        //System.out.println("s(" + cn + "): received command");<br/>
        if (packet == null) {<br/>
            System.out.println("server.connection.handle: got null packet");<br/>
            return;<br/>
        }<br/>
        // act on it<br/>
        switch(packet.getCommand()) {<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receivePlayerName(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(packet, connId);<br/>
                validatePlayerInfo(connId);<br/>
                send(createPlayerUpdatePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerDone(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)packet.getObject(0);<br/>
                if (chat.startsWith("/")) {<br/>
                    processCommand(connId, chat);<br/>
                } else {<br/>
                    sendChat(getPlayer(connId).getName(), chat);<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                receiveMovement(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_DEPLOY :<br/>
                receiveDeployment(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_UPDATE :<br/>
                receiveEntityUpdate(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MODECHANGE :<br/>
                receiveEntityModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                if (receiveGameOptions(packet, connId)) {<br/>
                    resetPlayersDone();<br/>
                    transmitAllPlayerDones();<br/>
                    send(createGameSettingsPacket());<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_MAP_SETTINGS :<br/>
                mapSettings = (MapSettings)packet.getObject(0);<br/>
                mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case Packet.COMMAND_QUERY_MAP_SETTINGS :<br/>
                MapSettings temp = (MapSettings)packet.getObject(0);<br/>
                temp.setBoardsAvailableVector(scanForBoards(temp.getBoardWidth(), temp.getBoardHeight()));<br/>
                temp.removeUnavailable();<br/>
                temp.setNullBoards(DEFAULT_BOARD);<br/>
                temp.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                temp.removeUnavailable();<br/>
                send(connId, createMapQueryPacket(temp));<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
                <br/>
                int id = connectionCounter++;<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
                <br/>
                connectionsPending.addElement(new Connection(this, s, id));<br/>
                <br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
                ;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of inferno ammo, determined<br/>
     * by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeInfernoAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        StringBuffer result = new StringBuffer();<br/>
<br/>
        // Find the most destructive Inferno ammo.<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                // Ignore empty, destroyed, hit, and structure slots.<br/>
                if ( cs == null || cs.isDestroyed() || cs.isHit() ||<br/>
                     cs.getType() != CriticalSlot.TYPE_EQUIPMENT ) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but weapons slots.<br/>
                Mounted mounted = entity.getEquipment<br/>
                    ( entity.getCritical(j, k).getIndex() );<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but Inferno ammo.<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if ( !atype.isExplosive() ||<br/>
                     atype.getMunitionType() != AmmoType.M_INFERNO) {<br/>
                    continue;<br/>
                }<br/>
                // Find the most destructive undamaged ammo.<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds. <br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        // Did we find anything to explode?<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            // We've allocated heatBuildup to heat in resolveHeat(),<br/>
            // so need to add to the entity's heat instead.<br/>
            result.append( explodeEquipment(entity, boomloc, boomslot) );<br/>
            entity.heat += 30;<br/>
            result.append( "   Gains 30 heat and is now at " )<br/>
                .append( entity.heat )<br/>
                .append( " heat.\n" );<br/>
            entity.heatBuildup = 0;<br/>
        } else {<br/>
            result.append("  Luckily, there is no inferno ammo to explode.\n");<br/>
        }<br/>
        return result.toString();<br/>
    }<br/>
<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_Server_1.228.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek - Copyright (C) 2000-2002 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.net.*;<br/>
import java.io.*;<br/>
import java.util.*;<br/>
<br/>
import megamek.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.common.options.*;<br/>
import megamek.server.commands.*;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server<br/>
implements Runnable {<br/>
    //    public final static String  LEGAL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-";<br/>
    public final static String  DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;<br/>
    <br/>
    // server setup<br/>
    private String              password;<br/>
    private ServerSocket        serverSocket;<br/>
    private ServerLog           log = new ServerLog();<br/>
    private String              motd;<br/>
    <br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
    <br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
    <br/>
    private Game                game = new Game();<br/>
    <br/>
    private MapSettings         mapSettings = new MapSettings();<br/>
    <br/>
    // list of turns and whose turn it is<br/>
    private int                 roundCounter = 0;<br/>
    private Vector              turns = new Vector();<br/>
    private int                 turnIndex = 0;<br/>
    private int                 turnInfMoved = 0;<br/>
    private int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = -1;<br/>
    <br/>
    // stuff for the current turn<br/>
    private Vector              attacks = new Vector();<br/>
    private Vector              pendingCharges = new Vector();<br/>
    private Vector              pilotRolls = new Vector();<br/>
    <br/>
    private StringBuffer        roundReport = new StringBuffer();<br/>
    private StringBuffer        phaseReport = new StringBuffer();<br/>
    <br/>
    private boolean             forceVictory = false;<br/>
    <br/>
    // commands<br/>
    private Hashtable           commandsHash = new Hashtable();<br/>
    <br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
    <br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     */<br/>
    public Server(String password, int port) {<br/>
        this.password = password.length() &gt; 0 ? password : null;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port " + port);<br/>
        }<br/>
        <br/>
        motd = createMotd();<br/>
        <br/>
        game.getOptions().initialize();<br/>
        <br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
        <br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
        System.out.println("s: address = " + serverSocket.getInetAddress().getHostAddress() + " port = " + serverSocket.getLocalPort());<br/>
        try {<br/>
            System.out.println("s: address = " + InetAddress.getByName("127.0.0.1").getHostAddress());<br/>
        } catch(UnknownHostException ex) {}<br/>
        System.out.println("s: password = " + this.password);<br/>
        <br/>
        connector = new Thread(this);<br/>
        connector.start();<br/>
        <br/>
        // register commands<br/>
        registerCommand(new HelpCommand(this));<br/>
        registerCommand(new KickCommand(this));<br/>
        registerCommand(new ResetCommand(this));<br/>
        registerCommand(new RollCommand(this));<br/>
        registerCommand(new VictoryCommand(this));<br/>
        registerCommand(new WhoCommand(this));<br/>
    }<br/>
    <br/>
    public void setGame(Game g) {<br/>
        game = g;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Make a default message o' the day containing the version string, and<br/>
     * if it was found, the build timestamp<br/>
     */<br/>
    private String createMotd() {<br/>
        StringBuffer buf = new StringBuffer();<br/>
        buf.append("Welcome to MegaMek.  Server is running version ");<br/>
        buf.append(MegaMek.VERSION);<br/>
        buf.append(", build date ");<br/>
        if (MegaMek.TIMESTAMP &gt; 0L) {<br/>
            buf.append(new Date(MegaMek.TIMESTAMP).toString());<br/>
        } else {<br/>
            buf.append("unknown");<br/>
        }<br/>
        buf.append(".");<br/>
        <br/>
        return buf.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * @return true if the server has a password<br/>
     */<br/>
    public boolean isPassworded() {<br/>
        return password != null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * @return true if the password matches<br/>
     */<br/>
    public boolean isPassword(Object guess) {<br/>
        return password.equals(guess);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Registers a new command in the server command table<br/>
     */<br/>
    private void registerCommand(ServerCommand command) {<br/>
        commandsHash.put(command.getName(), command);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the command associated with the specified name<br/>
     */<br/>
    public ServerCommand getCommand(String name) {<br/>
        return (ServerCommand)commandsHash.get(name);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shuts down the server.<br/>
     */<br/>
    public void die() {<br/>
        // kill thread accepting new connections<br/>
        connector = null;<br/>
        <br/>
        // close socket<br/>
        try {<br/>
            serverSocket.close();<br/>
        } catch(IOException ex) { ; }<br/>
        <br/>
        // kill pending connnections<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.die();<br/>
        }<br/>
        connectionsPending = null;<br/>
        <br/>
        // kill active connnections<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.die();<br/>
        }<br/>
        connections = null;<br/>
        connectionIds = null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns an enumeration of all the command names<br/>
     */<br/>
    public Enumeration getAllCommandNames() {<br/>
        return commandsHash.keys();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sent when a clients attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server greeting -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Allow the player to set whatever parameters he is able to<br/>
     */<br/>
    private void receivePlayerInfo(Packet packet, int connId) {<br/>
        Player player = (Player)packet.getObject(0);<br/>
        game.getPlayer(connId).setColorIndex(player.getColorIndex());<br/>
        game.getPlayer(connId).setStartingPos(player.getStartingPos());<br/>
        game.getPlayer(connId).setTeam(player.getTeam());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recieves a player name, sent from a pending connection, and connects<br/>
     * that connection.<br/>
     */<br/>
    private void receivePlayerName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
        String name = (String)packet.getObject(0);<br/>
        boolean returning = false;<br/>
        <br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending connection");<br/>
            return;<br/>
        }<br/>
        <br/>
        // check if they're connecting with the same name as a ghost player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.isGhost() &amp;&amp; player.getName().equals(name)) {<br/>
                returning = true;<br/>
                player.setGhost(false);<br/>
                // switch id<br/>
                connId = player.getId();<br/>
                conn.setId(connId);<br/>
            }<br/>
        }<br/>
        <br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
        <br/>
        // add and validate the player info<br/>
        if (!returning) {<br/>
            game.addPlayer(connId, new Player(connId, name));<br/>
            validatePlayerInfo(connId);<br/>
        }<br/>
        <br/>
        // if it is not the lounge phase, this player becomes an observer<br/>
        if (game.phase != Game.PHASE_LOUNGE<br/>
        &amp;&amp; game.getEntitiesOwnedBy(getPlayer(connId)) &lt; 1) {<br/>
            getPlayer(connId).setObserver(true);<br/>
        }<br/>
        <br/>
        // send the player the motd<br/>
        sendServerChat(connId, motd);<br/>
        <br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
        <br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
        <br/>
        // send current game info<br/>
        sendCurrentInfo(connId);<br/>
        <br/>
        System.out.println("s: player " + connId<br/>
        + " (" + getPlayer(connId).getName() + ") connected from "<br/>
        + getClient(connId).getSocket().getInetAddress());<br/>
        sendServerChat(getPlayer(connId).getName() + " connected from "<br/>
        + getClient(connId).getSocket().getInetAddress());<br/>
        <br/>
        // there is more than one player, uncheck the friendly fire option<br/>
        if (game.getNoOfPlayers() &gt; 1 &amp;&amp; game.getOptions().booleanOption("friendly_fire")) {<br/>
            game.getOptions().getOption("friendly_fire").setValue(false);<br/>
            send(createGameSettingsPacket());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends a player the info they need to look at the current phase<br/>
     */<br/>
    private void sendCurrentInfo(int connId) {<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(createGameSettingsPacket());<br/>
        if (doBlind()) {<br/>
            send(connId, createFilteredEntitiesPacket(getPlayer(connId)));<br/>
        }<br/>
        else {<br/>
            send(connId, createEntitiesPacket());<br/>
        }<br/>
        switch (game.phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                send(connId, createMapSettingsPacket());<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
            case Game.PHASE_END :<br/>
            case Game.PHASE_VICTORY :<br/>
                send(createReportPacket());<br/>
            default :<br/>
                getPlayer(connId).setDone(game.getEntitiesOwnedBy(getPlayer(connId)) &lt;= 0);<br/>
                send(connId, createBoardPacket());<br/>
                break;<br/>
        }<br/>
        send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(game.phase)));<br/>
        if (game.phaseHasTurns(game.getPhase())) {<br/>
            send(new Packet(Packet.COMMAND_TURN, game.getTurn()));<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    <br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        final Player player = getPlayer(playerId);<br/>
        <br/>
        //        maybe this isn't actually useful<br/>
        //        // replace characters we don't like with "X"<br/>
        //        StringBuffer nameBuff = new StringBuffer(player.getName());<br/>
        //        for (int i = 0; i &lt; nameBuff.length(); i++) {<br/>
        //            int chr = nameBuff.charAt(i);<br/>
        //            if (LEGAL_CHARS.indexOf(chr) == -1) {<br/>
        //                nameBuff.setCharAt(i, 'X');<br/>
        //            }<br/>
        //        }<br/>
        //        player.setName(nameBuff.toString());<br/>
        <br/>
        //TODO: check for duplicate or reserved names<br/>
        <br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player otherPlayer = (Player)i.nextElement();<br/>
            if (otherPlayer.getId() != playerId) {<br/>
                colorUsed[otherPlayer.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (colorUsed[player.getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    player.setColorIndex(i);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when it is sensed that a connection has terminated.<br/>
     */<br/>
    public void disconnected(int connId) {<br/>
        final Connection conn = getClient(connId);<br/>
        final Player player = getPlayer(connId);<br/>
        <br/>
        // if the connection's even still there, remove it<br/>
        if (conn != null) {<br/>
            conn.die();<br/>
            connections.removeElement(conn);<br/>
            connectionIds.remove(new Integer(connId));<br/>
        }<br/>
        <br/>
        // in the lounge, just remove all entities for that player<br/>
        if (game.phase == Game.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
            //send(createEntitiesPacket());<br/>
            entityAllUpdate();<br/>
        }<br/>
        <br/>
        // if a player has active entities, he becomes a ghost<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0) {<br/>
            player.setGhost(true);<br/>
            player.setDone(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, new Integer(player.getId())));<br/>
        }<br/>
        <br/>
        // make sure the game advances<br/>
        if (game.phaseHasTurns(game.getPhase())) {<br/>
            if (game.getTurn().getPlayerNum() == player.getId()) {<br/>
                endCurrentTurn();<br/>
            }<br/>
        } else {<br/>
            checkReady();<br/>
        }<br/>
        <br/>
        System.out.println("s: player " + connId + " disconnected");<br/>
        sendServerChat(player.getName() + " disconnected.");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks each player to see if he has no entities, and if true, sets the<br/>
     * observer flag for that player.  An exception is that there are no<br/>
     * observers during the lounge phase.<br/>
     */<br/>
    public void checkForObservers() {<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setObserver(game.getEntitiesOwnedBy(p) &lt; 1 &amp;&amp; game.phase != Game.PHASE_LOUNGE);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Reset the game back to the lounge.<br/>
     *<br/>
     * TODO: couldn't this be a hazard if there are other things executing at<br/>
     *  the same time?<br/>
     */<br/>
    public void resetGame() {<br/>
        // remove all entities<br/>
        game.reset();<br/>
        send(createEntitiesPacket());<br/>
        <br/>
        //TODO: remove ghosts<br/>
        <br/>
        // reset all players<br/>
        resetPlayersDone();<br/>
        transmitAllPlayerDones();<br/>
        <br/>
        pilotRolls.removeAllElements();<br/>
        <br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
    }<br/>
    <br/>
    public void autoSave()<br/>
    {<br/>
        saveGame("autosave");<br/>
    }<br/>
    <br/>
    public void saveGame(String sFile) {<br/>
        String sFinalFile = sFile + ".sav";<br/>
        try {<br/>
            ObjectOutputStream oos = new ObjectOutputStream(<br/>
                    new FileOutputStream(sFinalFile));<br/>
            oos.writeObject(game);<br/>
            oos.flush();<br/>
            oos.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to save file: " + sFinalFile);<br/>
            e.printStackTrace();<br/>
        }<br/>
        sendChat("MegaMek", "Game saved to " + sFinalFile);<br/>
    }<br/>
    <br/>
    public boolean loadGame(File f) {<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                    new FileInputStream(f));<br/>
            game = (Game)ois.readObject();<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
            return false;<br/>
        }<br/>
        <br/>
        // reattach the transient fields and ghost the players<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements(); ) {<br/>
            Entity ent = (Entity)e.nextElement();<br/>
            ent.setOwner(game.getPlayer(ent.getOwnerId()));<br/>
            ent.setGame(game);<br/>
            ent.restore();<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setGame(game);<br/>
            p.setGhost(true);<br/>
        }<br/>
        <br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Counts up how many non-ghost, non-observer players are connected.<br/>
     */<br/>
    private int countActivePlayers() {<br/>
        int count = 0;<br/>
        <br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver()) {<br/>
                count++;<br/>
            }<br/>
        }<br/>
        <br/>
        return count;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
        <br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            game.removeEntity(entity.getId());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Enumeration getConnections() {<br/>
        return connections.elements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            <br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Are we out of turns (done with the phase?)<br/>
     */<br/>
    private boolean areMoreTurns() {<br/>
        return turnIndex &lt; turns.size();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the next turn object or null if we're done with this phase<br/>
     */<br/>
    private GameTurn nextTurn() {<br/>
        return (GameTurn)turns.elementAt(turnIndex++);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this entity<br/>
     * that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            entity.newRound();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase() {<br/>
        // first, mark doomed entities as destroyed and move them to the graveyard<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
            if (entity.isDestroyed() || entity.getCrew().isDead()) {<br/>
                int condition = Game.UNIT_SALVAGEABLE;<br/>
                if ( !entity.isSalvage() ) {<br/>
                    condition = Game.UNIT_DEVASTATED;<br/>
                }<br/>
                game.removeEntity(entity.getId(), condition);<br/>
                send( createRemoveEntityPacket(entity.getId(), condition) );<br/>
            }<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            <br/>
            entity.applyDamage();<br/>
            <br/>
            entity.reloadEmptyWeapons();<br/>
            <br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
            <br/>
            // reset done to false<br/>
            entity.setDone(!entity.isActive());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.setDone(false);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
            <br/>
        }<br/>
        transmitAllPlayerDones();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Writes the victory report<br/>
     */<br/>
    private void prepareVictoryReport() {<br/>
        roundReport = new StringBuffer();<br/>
        <br/>
        roundReport.append("\nVictory!\n-------------------\n\n");<br/>
<br/>
        Enumeration survivors = game.getEntities();<br/>
        if ( survivors.hasMoreElements() ) {<br/>
            roundReport.append("Survivors are:\n");<br/>
            while ( survivors.hasMoreElements() ) {<br/>
                Entity entity = (Entity) survivors.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration retreat = game.getRetreatedEntities();<br/>
        if ( retreat.hasMoreElements() ) {<br/>
            roundReport.append("\nThe following units are in retreat:\n");<br/>
            while ( retreat.hasMoreElements() ) {<br/>
                Entity entity = (Entity) retreat.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration graveyard = game.getGraveyardEntities();<br/>
        if ( graveyard.hasMoreElements() ) {<br/>
            roundReport.append("\nGraveyard contains:\n");<br/>
            while ( graveyard.hasMoreElements() ) {<br/>
                Entity entity = (Entity) graveyard.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        Enumeration devastated = game.getDevastatedEntities();<br/>
        if ( devastated.hasMoreElements() ) {<br/>
            roundReport.append("\nThe following utterly destroyed units are not available for salvage:\n");<br/>
            while ( devastated.hasMoreElements() ) {<br/>
                Entity entity = (Entity) devastated.nextElement();<br/>
                roundReport.append(entity.victoryReport());<br/>
                roundReport.append('\n');<br/>
            }<br/>
        }<br/>
        roundReport.append("\nDetailed unit status saved to entitystatus.txt\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Generates a detailed report for campaign use<br/>
     */<br/>
    private String getDetailedVictoryReport() {<br/>
        StringBuffer sb = new StringBuffer();<br/>
        <br/>
        Vector vAllUnits = new Vector();<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
        <br/>
        for ( Enumeration i = game.getRetreatedEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getGraveyardEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
        <br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
<br/>
            // Record the player.<br/>
            Player p = (Player)i.nextElement();<br/>
            sb.append("++++++++++ " )<br/>
                .append( p.getName() )<br/>
                .append( " ++++++++++\n");<br/>
<br/>
            // Record the player's alive, retreated, or salvageable units.<br/>
            for (int x = 0; x &lt; vAllUnits.size(); x++) {<br/>
                Entity e = (Entity)vAllUnits.elementAt(x);<br/>
                if (e.getOwner() == p) {<br/>
                    sb.append(UnitStatusFormatter.format(e));<br/>
                }<br/>
            }<br/>
<br/>
            // Record the player's devastated units.<br/>
            Enumeration devastated = game.getDevastatedEntities();<br/>
            if ( devastated.hasMoreElements() ) {<br/>
                sb.append("=============================================================\n");<br/>
                sb.append("The following utterly destroyed units are not available for salvage:\n");<br/>
                while ( devastated.hasMoreElements() ) {<br/>
                    Entity e = (Entity) devastated.nextElement();<br/>
                    if (e.getOwner() == p) {<br/>
                        sb.append( e.getShortName() )<br/>
                            .append( ", Pilot: " )<br/>
                            .append( e.getCrew().getName() )<br/>
                            .append( " (" )<br/>
                            .append( e.getCrew().getGunnery() )<br/>
                            .append( "/" )<br/>
                            .append( e.getCrew().getPiloting() )<br/>
                            .append( ")\n" );<br/>
                    }<br/>
                } // Handle the next unsalvageable unit for the player<br/>
                sb.append("=============================================================\n");<br/>
            }<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        return sb.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Forces victory at then end of the turn.<br/>
     */<br/>
    public void forceVictory() {<br/>
        forceVictory = true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when a player declares that he is "done."  Checks to see if all<br/>
     * players are done, and if so, moves on to the next phase.<br/>
     */<br/>
    private void checkReady() {<br/>
        // are there any active players?<br/>
        boolean allAboard = countActivePlayers() &gt; 0;<br/>
        // check if all active players are done<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver() &amp;&amp; !player.isDone()) {<br/>
                allAboard = false;<br/>
            }<br/>
        }<br/>
        // need at least one entity in the game for the lounge phase to end<br/>
        if (allAboard &amp;&amp; !game.phaseHasTurns(game.phase)<br/>
        &amp;&amp; (game.phase != Game.PHASE_LOUNGE || game.getNoOfEntities() &gt; 0)) {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Called when the current player has done his current turn and the turn<br/>
     * counter needs to be advanced.<br/>
     */<br/>
    private void endCurrentTurn() {<br/>
        changeToNextTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.phase = phase;<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
        <br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
            <br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                mapSettings.setBoardsAvailableVector(scanForBoards(mapSettings.getBoardWidth(), mapSettings.getBoardHeight()));<br/>
                mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
                // remove the last traces of last round<br/>
                attacks.removeAllElements();<br/>
                roundReport = new StringBuffer();<br/>
                resetEntityRound();<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                // roll 'em<br/>
                resetActivePlayersDone();<br/>
                rollInitiative();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder();<br/>
                writeInitiativeReport();<br/>
                send(createReportPacket());<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder();<br/>
                resetActivePlayersDone();<br/>
                //send(createEntitiesPacket());<br/>
                entityAllUpdate();<br/>
                phaseReport = new StringBuffer();<br/>
                break;<br/>
            case Game.PHASE_END :<br/>
                phaseReport = new StringBuffer();<br/>
                resetEntityPhase();<br/>
                checkForObservers();<br/>
                resolveHeat();<br/>
                checkForSuffocation();<br/>
                resolveCrewDamage();<br/>
                resolveCrewWakeUp();<br/>
                resolveFire();<br/>
                autoSave();<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                }<br/>
                log.append( "\n" );<br/>
                log.append( roundReport.toString() );<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
                resetActivePlayersDone();<br/>
                send(createReportPacket());<br/>
                break;<br/>
            case Game.PHASE_VICTORY :<br/>
                prepareVictoryReport();<br/>
                send(createReportPacket());<br/>
                send(createEndOfGamePacket());<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Should we play this phase or skip it?  The only phases we'll skip<br/>
     * are the firing or the physical phase if no entities are eligible.<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                return areMoreTurns();<br/>
            default :<br/>
                return true;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_EXCHANGE :<br/>
                resetPlayersDone();<br/>
                applyBoardSettings();<br/>
                game.setHasDeployed(false);<br/>
                game.determineWindDirection();<br/>
                // If we add transporters for any Magnetic Clamp<br/>
                // equiped squads, then update the clients' entities.<br/>
                if ( game.checkForMagneticClamp() ) {<br/>
                    send(createEntitiesPacket());<br/>
                }<br/>
                // transmit the board to everybody<br/>
                send(createBoardPacket());<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
            case Game.PHASE_MOVEMENT :<br/>
            case Game.PHASE_FIRING :<br/>
            case Game.PHASE_PHYSICAL :<br/>
                // set turn<br/>
                turnIndex = 0;<br/>
                changeToNextTurn();<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.phase) {<br/>
            case Game.PHASE_LOUNGE :<br/>
                changePhase(Game.PHASE_EXCHANGE);<br/>
                break;<br/>
            case Game.PHASE_EXCHANGE :<br/>
                changePhase(Game.PHASE_INITIATIVE);<br/>
                break;<br/>
            case Game.PHASE_DEPLOYMENT :<br/>
                game.setHasDeployed(true);<br/>
                changePhase(Game.PHASE_INITIATIVE);<br/>
                break;<br/>
            case Game.PHASE_INITIATIVE :<br/>
                if (game.hasDeployed()) {<br/>
                    changePhase(Game.PHASE_MOVEMENT);<br/>
                }<br/>
                else {<br/>
                    changePhase(Game.PHASE_DEPLOYMENT);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_MOVEMENT :<br/>
                roundReport.append("\nMovement Phase\n-------------------\n");<br/>
                addMovementHeat();<br/>
                resolveCrewDamage();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolvePilotingRolls(); // Skids cause damage in movement phase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveCrewDamage(); // again, I guess<br/>
                checkForFlamingDeath();<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                    changePhase(Game.PHASE_MOVEMENT_REPORT);<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                    changePhase(Game.PHASE_FIRING);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_MOVEMENT_REPORT :<br/>
                changePhase(Game.PHASE_FIRING);<br/>
                break;<br/>
            case Game.PHASE_FIRING :<br/>
                assignAMS();<br/>
                resolveWeaponAttacks();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                    changePhase(Game.PHASE_FIRING_REPORT);<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                    changePhase(Game.PHASE_PHYSICAL);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_FIRING_REPORT :<br/>
                changePhase(Game.PHASE_PHYSICAL);<br/>
                break;<br/>
            case Game.PHASE_PHYSICAL :<br/>
                resolvePhysicalAttacks();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (phaseReport.length() &gt; 0) {<br/>
                    roundReport.append(phaseReport.toString());<br/>
                } else {<br/>
                    roundReport.append("&lt;nothing&gt;\n");<br/>
                }<br/>
                changePhase(Game.PHASE_END);<br/>
                break;<br/>
            case Game.PHASE_END :<br/>
                if (victory()) {<br/>
                    changePhase(Game.PHASE_VICTORY);<br/>
                } else {<br/>
                    changePhase(Game.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case Game.PHASE_VICTORY :<br/>
                forceVictory = false;<br/>
                resetGame();<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Tries to change to the next turn.  If there are no more turns, ends the<br/>
     * current phase.  If the player whose turn it is next is not connected,<br/>
     * we skip that player.<br/>
     */<br/>
    private void changeToNextTurn() {<br/>
        // if there aren't any more turns, end the phase<br/>
        if (!areMoreTurns()) {<br/>
            endCurrentPhase();<br/>
            return;<br/>
        }<br/>
        GameTurn nextTurn = nextTurn();<br/>
        if (getPlayer(nextTurn.getPlayerNum()).isGhost()) {<br/>
            changeToNextTurn();<br/>
            return;<br/>
        }<br/>
        changeTurn(nextTurn);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Changes it to make it the specified player's turn.<br/>
     */<br/>
    private void changeTurn(GameTurn turn) {<br/>
        final Player player = getPlayer(turn.getPlayerNum());<br/>
        game.setTurn(turn);<br/>
        if (player != null) {<br/>
            player.setDone(false);<br/>
        }<br/>
        send(new Packet(Packet.COMMAND_TURN, turn));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns true if victory conditions have been met.  Victory conditions<br/>
     * are when there is only one player left with mechs or only one team.<br/>
     */<br/>
    public boolean victory() {<br/>
        if (forceVictory) {<br/>
            return true;<br/>
        }<br/>
        <br/>
        if (!game.getOptions().booleanOption("check_victory")) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        // is there only one player left with mechs?<br/>
        int playersAlive = 0;<br/>
        int teamsAlive = 0;<br/>
        boolean teamKnownAlive[] = new boolean[Player.MAX_TEAMS];<br/>
        boolean unteamedAlive = false;<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements();) {<br/>
            Player player = (Player)e.nextElement();<br/>
            int team = player.getTeam();<br/>
            if (game.getLiveEntitiesOwnedBy(player) &gt; 0) {<br/>
                playersAlive++;<br/>
                if (team == Player.TEAM_NONE) {<br/>
                    unteamedAlive = true;<br/>
                } else if (!teamKnownAlive[team]) {<br/>
                    teamsAlive++;<br/>
                    teamKnownAlive[team] = true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return playersAlive &lt;= 1 || (teamsAlive == 1 &amp;&amp; !unteamedAlive);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Applies board settings.  This loads and combines all the boards that<br/>
     * were specified into one mega-board and sets that board as current.<br/>
     */<br/>
    public void applyBoardSettings() {<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);<br/>
        Board[] sheetBoards = new Board[mapSettings.getMapWidth() * mapSettings.getMapHeight()];<br/>
        for (int i = 0; i &lt; mapSettings.getMapWidth() * mapSettings.getMapHeight(); i++) {<br/>
            sheetBoards[i] = new Board();<br/>
            String name = (String)mapSettings.getBoardsSelectedVector().elementAt(i);<br/>
            boolean isRotated = false;<br/>
            if ( name.startsWith( Board.BOARD_REQUEST_ROTATION ) ) {<br/>
                isRotated = true;<br/>
                name = name.substring( Board.BOARD_REQUEST_ROTATION.length() );<br/>
            }<br/>
            sheetBoards[i].load( name + ".board");<br/>
            sheetBoards[i].flip( isRotated, isRotated );<br/>
        }<br/>
        game.board.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(),<br/>
        mapSettings.getMapWidth(), mapSettings.getMapHeight(), sheetBoards);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deploys an entity near a selected point on the board.<br/>
     *<br/>
     * @param entity the entity to deploy<br/>
     * @param pos the point to deploy near<br/>
     * @param towards another point that the deployed mechs will face towards<br/>
     */<br/>
    private boolean deploy(Entity entity, Coords pos, Coords towards, int recurse) {<br/>
        if (game.board.contains(pos) &amp;&amp; game.getFirstEntity(pos) == null<br/>
        &amp;&amp; !entity.isHexProhibited(game.board.getHex(pos))) {<br/>
            placeEntity(entity, pos, pos.direction(towards));<br/>
            return true;<br/>
        }<br/>
        <br/>
        // if pos is filled, try some different positions<br/>
        for (int j = 0; j &lt; recurse; j++) {<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                Coords deployPos = pos.translated(i);<br/>
                if (deploy(entity, deployPos, towards, j)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return false;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Places a mech on the board<br/>
     */<br/>
    private void placeEntity(Entity entity, Coords pos, int facing) {<br/>
        entity.setPosition(pos);<br/>
        entity.setFacing(facing);<br/>
        entity.setSecondaryFacing(facing);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the starting point for the specified player<br/>
     */<br/>
    private Coords getStartingCoords(int startingPos) {<br/>
        switch (startingPos) {<br/>
            default :<br/>
            case 0 :<br/>
                return new Coords(1, 1);<br/>
            case 1 :<br/>
                return new Coords(game.board.width / 2, 1);<br/>
            case 2 :<br/>
                return new Coords(game.board.width - 2, 1);<br/>
            case 3 :<br/>
                return new Coords(game.board.width - 2, game.board.height / 2);<br/>
            case 4 :<br/>
                return new Coords(game.board.width - 2, game.board.height - 2);<br/>
            case 5 :<br/>
                return new Coords(game.board.width / 2, game.board.height - 2);<br/>
            case 6 :<br/>
                return new Coords(1, game.board.height - 2);<br/>
            case 7 :<br/>
                return new Coords(1, game.board.height / 2);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        roundCounter++;<br/>
        <br/>
        // roll the dice for each player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.getInitiative().clear();<br/>
        }<br/>
        <br/>
        // roll off all ties<br/>
        resolveInitTies(game.getPlayersVector());<br/>
        <br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
    <br/>
    /**<br/>
     * This goes thru and adds a roll on to the end of the intiative "stack"<br/>
     * for all players involved.  Then it checks the list again for ties, and<br/>
     * recursively resolves all further ties.<br/>
     */<br/>
    private void resolveInitTies(Vector players) {<br/>
        // add a roll for all players<br/>
        for (Enumeration i = players.elements(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.getInitiative().addRoll();<br/>
        }<br/>
        // check for further ties<br/>
        Vector ties = new Vector();<br/>
        for (Enumeration i = players.elements(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            ties.removeAllElements();<br/>
            ties.addElement(player);<br/>
            for (Enumeration j = game.getPlayers(); j.hasMoreElements();) {<br/>
                final Player other = (Player)j.nextElement();<br/>
                if (player != other &amp;&amp; player.getInitiative().equals(other.getInitiative())) {<br/>
                    ties.addElement(other);<br/>
                }<br/>
            }<br/>
            if (ties.size() &gt; 1) {<br/>
                resolveInitTies(ties);<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Determine turn order by number of entities that are selectable this phase<br/>
     *<br/>
     * TODO: this is a real mess<br/>
     */<br/>
    private void determineTurnOrder() {<br/>
        // sort players<br/>
        com.sun.java.util.collections.ArrayList plist = new com.sun.java.util.collections.ArrayList(game.getNoOfPlayers());<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            plist.add(player);<br/>
        }<br/>
        com.sun.java.util.collections.Collections.sort(plist, new com.sun.java.util.collections.Comparator() {<br/>
            public int compare(Object o1, Object o2) {<br/>
                return ((Player)o1).getInitiative().compareTo(((Player)o2).getInitiative());<br/>
            }<br/>
        });<br/>
        <br/>
        // determine turn order<br/>
        int[] order = new int[game.getNoOfPlayers()];<br/>
        int oi = 0;<br/>
        for (com.sun.java.util.collections.Iterator i = plist.iterator(); i.hasNext();) {<br/>
            final Player player = (Player)i.next();<br/>
            order[oi++] = player.getId();<br/>
        }<br/>
        <br/>
        // count how many entities each player controls, and how many turns we have to assign<br/>
        int MAX_PLAYERS = 255; //XXX HACK HACK HACK!<br/>
        int[] noe = new int[MAX_PLAYERS];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int playerId = 0;<br/>
        int noOfTurns = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int[] noi = new int[MAX_PLAYERS]; // The number of Infantry for player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int noOfInfTurns = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infLast = game.getOptions().booleanOption("inf_move_last");<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            if (entity.isSelectable()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerId = entity.getOwner().getId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Special handling for infantry for certain game options.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    noi[playerId]++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If multiple Infantry move per Mek and Vehicle and this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // is NOT the start of a new block of infantry for the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // player do NOT add a turn.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMulti &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 != (noi[playerId] % Game.INF_MOVE_MULTI) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If Infantry move after Meks and Vehicles, we'll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // delay calculating the infantry turns.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else if ( infLast ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noOfInfTurns++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                noe[playerId]++;<br/>
                noOfTurns++;<br/>
            }<br/>
        }<br/>
        <br/>
        // generate turn list<br/>
        turns.setSize(noOfTurns + noOfInfTurns);<br/>
        turnIndex = 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle all "mainline entities".  I.E. Meks, Vehicles, and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// (unless overrided by the "inf_move_last" option) Infantry.<br/>
        while (turnIndex &lt; noOfTurns) {<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoe = 1;<br/>
            int lnoe = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                if (noe[i] &gt; 0 &amp;&amp; noe[i] &lt; lnoe) {<br/>
                    lnoe = noe[i];<br/>
                }<br/>
                if (noe[i] &gt; hnoe) {<br/>
                    hnoe = noe[i];<br/>
                }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noe[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                /* if you have less than twice the next lowest,<br/>
                 * move 1, otherwise, move more.<br/>
                 * if you have less than half the maximum,<br/>
                 * move none<br/>
                 */<br/>
                int ntm = Math.max(1, (int)Math.floor(noe[order[i]] / lnoe));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns.setElementAt(new GameTurn(order[i]), turnIndex);<br/>
                    turnIndex++;<br/>
                    noe[order[i]]--;<br/>
                }<br/>
            }<br/>
        } // Handle the next "mainline entity"<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Now handle all Infantry (the "inf_move_last" option must be on).<br/>
        while (turnIndex &lt; turns.size()) {<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoi = 1;<br/>
            int lnoi = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                if (noi[i] &gt; 0 &amp;&amp; noi[i] &lt; lnoi) {<br/>
                    lnoi = noi[i];<br/>
                }<br/>
                if (noi[i] &gt; hnoi) {<br/>
                    hnoi = noi[i];<br/>
                }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noi[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                /* if you have less than twice the next lowest,<br/>
                 * move 1, otherwise, move more.<br/>
                 * if you have less than half the maximum,<br/>
                 * move none<br/>
                 */<br/>
                int ntm = Math.max(1, (int)Math.floor(noi[order[i]] / lnoi));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns.setElementAt(new GameTurn(order[i]), turnIndex);<br/>
                    turnIndex++;<br/>
                    noi[order[i]]--;<br/>
                }<br/>
            }<br/>
        } // Handle the next infantry platoon<br/>
<br/>
        // reset turn counters<br/>
        turnIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = -1;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport() {<br/>
        // write to report<br/>
        if (game.hasDeployed()) {<br/>
            roundReport.append("\nInitiative Phase for Round #").append(roundCounter);<br/>
        }<br/>
        else {<br/>
            roundReport.append("\nInitiative Phase for Deployment");<br/>
        }<br/>
        roundReport.append("\n------------------------------\n");<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            roundReport.append(player.getName() ).append( " rolls a ");<br/>
            for (int j = 0; j &lt; player.getInitiative().size(); j++) {<br/>
                if (j != 0) {<br/>
                    roundReport.append(" / ");<br/>
                }<br/>
                roundReport.append(player.getInitiative().getRoll(j));<br/>
            }<br/>
            roundReport.append(".\n");<br/>
        }<br/>
        roundReport.append("\nThe turn order is:\n  ");<br/>
        boolean firstTurn = true;<br/>
        for (Enumeration i = turns.elements(); i.hasMoreElements();) {<br/>
            GameTurn turn = (GameTurn)i.nextElement();<br/>
            roundReport.append((firstTurn ? "" : ", ") ).append( getPlayer(turn.getPlayerNum()).getName());<br/>
            firstTurn = false;<br/>
        }<br/>
        roundReport.append("\n\n");<br/>
        roundReport.append("  Wind direction is "+game.getStringWindDirection()+"\n");<br/>
        <br/>
        // reset turn index<br/>
        turnIndex = 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            if (!isEligibleFor(entity, phase)) {<br/>
                entity.setDone(true);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if an entity is eligible for a phase.<br/>
     */<br/>
    private boolean isEligibleFor(Entity entity, int phase) {<br/>
        switch (phase) {<br/>
            case Game.PHASE_FIRING :<br/>
                return isEligibleForFiring(entity, phase);<br/>
            case Game.PHASE_PHYSICAL :<br/>
                if (entity instanceof Mech) {<br/>
                    return isEligibleForPhysical(entity, phase);<br/>
                }<br/>
                else {<br/>
                    return false;<br/>
                }<br/>
            default:<br/>
                return true;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * An entity is eligible if its to-hit number is anything but impossible.<br/>
     * This is only really an issue if friendly fire is turned off.<br/>
     */<br/>
    private boolean isEligibleForFiring(Entity entity, int phase) {<br/>
        // if you're charging, no shooting<br/>
        if (entity.isUnjammingRAC()) return false;<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        //        // check game options<br/>
        //        if (!game.getOptions().booleanOption("skip_ineligable_firing")) {<br/>
        //            return true;<br/>
        //        }<br/>
        <br/>
        // TODO: check for any weapon attacks<br/>
        <br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Check if the entity has any valid targets for physical attacks.<br/>
     */<br/>
    private boolean isEligibleForPhysical(Entity entity, int phase) {<br/>
        boolean canHit = false;<br/>
        boolean friendlyFire = game.getOptions().booleanOption("friendly_fire");<br/>
        <br/>
        // dead mek walking<br/>
        if (!entity.isActive()) return false;<br/>
        <br/>
        // if you're charging or finding a club, it's already declared<br/>
        if (entity.isUnjammingRAC()) return false;<br/>
        if (entity.isCharging() || entity.isMakingDfa() || entity.isFindingClub()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        // check game options<br/>
        if (!game.getOptions().booleanOption("skip_ineligable_physical")) {<br/>
            return true;<br/>
        }<br/>
        <br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity target = (Entity)e.nextElement();<br/>
            <br/>
            // don't shoot at friendlies unless you are into that sort of thing<br/>
            // and do not shoot yourself even then<br/>
            if (!(entity.isEnemyOf(target) || (friendlyFire &amp;&amp; entity.getId() != target.getId() ))) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
            PunchAttackAction.LEFT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
            PunchAttackAction.RIGHT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
            KickAttackAction.LEFT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
            <br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
            KickAttackAction.RIGHT).getValue()<br/>
            != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitBrushOff<br/>
                ( game, entity.getId(), target.getId(),<br/>
                  BrushOffAttackAction.LEFT ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitBrushOff<br/>
                ( game, entity.getId(), target.getId(),<br/>
                  BrushOffAttackAction.RIGHT ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitThrash<br/>
                ( game, entity.getId(), target.getId() ).getValue()<br/>
                != ToHitData.IMPOSSIBLE;<br/>
        }<br/>
        <br/>
        return canHit;<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the loader load the indicated unit.<br/>
     * The unit being loaded loses its turn.<br/>
     *<br/>
     * @param   loader - the &lt;code&gt;Entity&lt;/code&gt; that is loading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being loaded.<br/>
     */<br/>
    private void loadUnit( Entity loader, Entity unit ) {<br/>
<br/>
        // Remove the loaded unit from the screen.<br/>
        unit.setPosition( null );<br/>
<br/>
        // Remove the *last* friendly turn (removing the *first* penalizes<br/>
        // the opponent too much, and re-calculating moves is too hard).<br/>
        for ( int index = this.turns.size() - 1;<br/>
              index &gt;= this.turnIndex; index-- ) {<br/>
<br/>
            // If the index-th turn is for the loaded unit's<br/>
            // player, remove it and stop looking.<br/>
            if ( unit.getOwnerId()  == <br/>
                 ( (GameTurn)turns.elementAt(index) ).getPlayerNum() ) {<br/>
                this.turns.removeElementAt( index );<br/>
                break;<br/>
            }<br/>
<br/>
        } // Check the next turn<br/>
<br/>
        // Load the unit.<br/>
        loader.load( unit );<br/>
<br/>
        // The loaded unit is being carried by the loader.<br/>
        unit.setTransportId( loader.getId() );<br/>
<br/>
        // Update the loaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the unloader unload the indicated unit.<br/>
     * The unit being unloaded does *not* gain a turn.<br/>
     *<br/>
     * @param   unloader - the &lt;code&gt;Entity&lt;/code&gt; that is unloading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being unloaded.<br/>
     * @param   pos - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if the unit isn't carried in unloader.<br/>
     */<br/>
    private boolean unloadUnit( Entity unloader, Entity unit,<br/>
                             Coords pos, int facing ) {<br/>
<br/>
        // Unload the unit.<br/>
        if ( !unloader.unload( unit ) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The unloaded unit is no longer being carried.<br/>
        unit.setTransportId( Entity.NONE );<br/>
<br/>
        // Place the unloaded unit onto the screen.<br/>
        unit.setPosition( pos );<br/>
<br/>
        // Point the unloaded unit in the given direction.<br/>
        unit.setFacing( facing );<br/>
        unit.setSecondaryFacing( facing );<br/>
<br/>
        // Update the unloaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
<br/>
        // Unloaded successfully.<br/>
        return true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receives an entity movement packet, and if valid, executes it and ends<br/>
     * the current turn.<br/>
     */<br/>
    private void receiveMovement(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        MovementData md = (MovementData)packet.getObject(1);<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_MOVEMENT) {<br/>
            System.err.println("error: server got movement packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)) {<br/>
            System.err.println("error: server got invalid movement packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processMovement(entity, md);<br/>
        endCurrentTurn();<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps thru an entity movement packet, executing it.<br/>
     */<br/>
    private void processMovement(Entity entity, MovementData md) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveLast = game.getOptions().booleanOption("inf_move_last");<br/>
<br/>
        // Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If "inf_move_mutli" option is selected, and we're in the middle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// of a block of Infantry moves, entity had better be an Infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// platoon owned by the most recent player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( infMoveMulti &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;     ( !(entity instanceof Infantry) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;       entity.getOwnerId() != turnLastPlayerId ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If "inf_move_last" option is selected, player can't move<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// a Mek or Vehicle after Infantry have started to move.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( infMoveLast &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  !(entity instanceof Infantry) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// check for fleeing<br/>
        if (md.contains(MovementData.STEP_FLEE)) {<br/>
            // Unit has fled the battlefield.<br/>
            phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
            ).append( " flees the battlefield.\n");<br/>
            // Is the unit carrying passengers?<br/>
            final Vector passengers = entity.getLoadedUnits();<br/>
            if ( !passengers.isEmpty() ) {<br/>
                final Enumeration iter = passengers.elements();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    final Entity passenger = (Entity) iter.nextElement();<br/>
                    // Unit has fled the battlefield.<br/>
                    phaseReport.append( "   It carries " )<br/>
                        .append( passenger.getDisplayName() )<br/>
                        .append( " with it.\n" );<br/>
                    game.removeEntity( passenger.getId(),<br/>
                                       Game.UNIT_IN_RETREAT );<br/>
                    send( createRemoveEntityPacket(passenger.getId(),<br/>
                                                   Game.UNIT_IN_RETREAT) );<br/>
                }<br/>
            }<br/>
            // Is the unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                // Unit has fled the battlefield.<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                phaseReport.append( "   It takes " )<br/>
                    .append( swarmer.getDisplayName() )<br/>
                    .append( " with it.\n" );<br/>
                game.removeEntity( swarmerId, Game.UNIT_IN_RETREAT );<br/>
                send( createRemoveEntityPacket(swarmerId,<br/>
                                               Game.UNIT_IN_RETREAT) );<br/>
            }<br/>
            <br/>
            game.removeEntity( entity.getId(), Game.UNIT_IN_RETREAT );<br/>
            send( createRemoveEntityPacket(entity.getId(),<br/>
                                           Game.UNIT_IN_RETREAT) );<br/>
            return;<br/>
        }<br/>
        <br/>
        // check for MASC failure<br/>
        if (entity instanceof Mech) {<br/>
            if (((Mech)entity).checkForMASCFailure(phaseReport)) {<br/>
                // no movement after that<br/>
                return;<br/>
            }<br/>
        }<br/>
                <br/>
        <br/>
        // okay, proceed with movement calculations<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int distance = 0;<br/>
        int mpUsed = 0;<br/>
        int moveType = Entity.MOVE_NONE;<br/>
        int overallMoveType = Entity.MOVE_NONE;<br/>
        boolean firstStep;<br/>
        boolean wasProne;<br/>
        boolean fellDuringMovement;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int prevFacing = curFacing;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Hex prevHex = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;final boolean isInfantry = (entity instanceof Infantry);<br/>
        <br/>
        // Compile the move<br/>
        Compute.compile(game, entity.getId(), md);<br/>
        <br/>
        // get last step's movement type<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            } else {<br/>
                overallMoveType = step.getMovementType();<br/>
            }<br/>
        }<br/>
        <br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        fellDuringMovement = false;<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            wasProne = entity.isProne();<br/>
            <br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
            <br/>
            // check piloting skill for getting up<br/>
            if (step.getType() == MovementData.STEP_GET_UP) {<br/>
                entity.heatBuildup += 1;<br/>
                entity.setProne(false);<br/>
                wasProne = false;<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "getting up"), true);<br/>
            } else if (firstStep) {<br/>
                // running with destroyed hip or gyro needs a check<br/>
                if (overallMoveType == Entity.MOVE_RUN &amp;&amp; !entity.isProne()<br/>
                &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                || entity.hasHipCrit())) {<br/>
                    doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "running with damaged hip actuator or gyro"), false);<br/>
                }<br/>
                firstStep = false;<br/>
            }<br/>
            <br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                moveType = step.getMovementType();<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
             <br/>
            if (step.getType() == MovementData.STEP_UNJAM_RAC) {<br/>
                entity.setUnjammingRAC(true);<br/>
                attacks.addElement(new UnjamAction(entity.getId()));<br/>
<br/>
                break;<br/>
            }<br/>
<br/>
            // set most step parameters<br/>
            moveType = step.getMovementType();<br/>
            distance = step.getDistance();<br/>
            mpUsed = step.getMpUsed();<br/>
<br/>
            // check for charge<br/>
            if (step.getType() == MovementData.STEP_CHARGE) {<br/>
                Entity target = step.getTarget( game );<br/>
                ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getId(), target.getPosition());<br/>
                entity.setDisplacementAttack(caa);<br/>
                pendingCharges.addElement(caa);<br/>
                break;<br/>
            }<br/>
            <br/>
            // check for dfa<br/>
            if (step.getType() == MovementData.STEP_DFA) {<br/>
                Entity target = step.getTarget( game );<br/>
                DfaAttackAction daa = new DfaAttackAction(entity.getId(), target.getId(), target.getPosition());<br/>
                entity.setDisplacementAttack(daa);<br/>
                pendingCharges.addElement(daa);<br/>
                break;<br/>
            }<br/>
<br/>
            // set last step parameters<br/>
            curPos = step.getPosition();<br/>
            curFacing = step.getFacing();<br/>
<br/>
            final Hex curHex = game.board.getHex(curPos);<br/>
<br/>
            // Check for skid.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( moveType != Entity.MOVE_JUMP<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevHex != null<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevHex.contains(Terrain.PAVEMENT)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; overallMoveType == Entity.MOVE_RUN<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; prevFacing != curFacing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !lastPos.equals(curPos)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !isInfantry ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Have an entity-meaningful PSR message.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PilotingRollData psr = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    psr = new PilotingRollData<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(entity.getId(), getMovementPSRModifier(distance),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "running &amp; turning on pavement", true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    psr = new PilotingRollData<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(entity.getId(), getMovementPSRModifier(distance),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "reckless driving on pavement", true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the entity skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !doSkillCheckWhileMoving(entity, lastPos, lastPos, psr) ){<br/>
<br/>
                    curPos = lastPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Coords nextPos = curPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Hex    nextHex = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    skidDistance = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Enumeration targets = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Entity target = null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    curElevation;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int    nextElevation;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // All charge damage is based upon<br/>
                    // the pre-skid move distance.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.delta_distance = distance-1;<br/>
<br/>
                    // BUG: all attacks against a skidding target are at +2,<br/>
                    //          and are *NOT* based upon distance moved at all.<br/>
                    // TODO: add Entity.MOVE_SKID constant and update the<br/>
                    //          Compute#getTargetMovementModifier methods.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // What is the first hex in the skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos = curPos.translated( prevFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextHex = game.board.getHex( nextPos );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Move the entity a number hexes from curPos in the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // prevFacing direction equal to half the distance moved<br/>
                    // this turn (rounded up), unless something intervenes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for ( skidDistance = 0;<br/>
                          skidDistance &lt; (int) Math.ceil(entity.delta_distance / 2.0); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  skidDistance++ ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Is the next hex off the board?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !game.board.contains(nextPos) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Can the entity skid off the map?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( game.getOptions().booleanOption("push_off_board") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  One dead entity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.removeEntity(entity.getId(),<br/>
                                                  Game.UNIT_IN_RETREAT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(entity.getId(),<br/>
                                                              Game.UNIT_IN_RETREAT));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("*** " ).append( entity.getDisplayName() ).append( " has skidded off the field. ***\n");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nope.  Update the report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Can't skid off the field.\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Can the skiding entity enter the hex?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( entity.isHexProhibited(nextHex) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "   Can't skid into hex " ).append( <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO: inflict any damage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
                        // BMRr pg. 22 - Can't skid uphill,<br/>
                        //      but can skid downhill.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curElevation = game.board.getHex(curPos).floor();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextElevation = nextHex.floor();<br/>
                        // Hovercraft can "skid" over water.<br/>
                        if ( entity instanceof Tank &amp;&amp;<br/>
                             entity.getMovementType() ==<br/>
                             Entity.MovementType.HOVER ) {<br/>
                            Terrain land = game.board.getHex(curPos).<br/>
                                getTerrain(Terrain.WATER);<br/>
                            if ( land != null ) {<br/>
                                curElevation += land.getLevel();<br/>
                            }<br/>
                            land = nextHex.getTerrain(Terrain.WATER);<br/>
                            if ( land != null ) {<br/>
                                nextElevation += land.getLevel();<br/>
                            }<br/>
                        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( curElevation &lt; nextElevation ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append<br/>
                                ( "   Can not skid uphill into hex " +<br/>
                                  nextPos.getBoardNum() ).append( ".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Stay in the current hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the next hex contain an entities?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean stopTheSkid = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets = game.getEntities( nextPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( targets.hasMoreElements() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target = (Entity) targets.nextElement();<br/>
<br/>
                            // TODO : allow ready targets to move out of way<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO : Handle targets in buildings.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Mechs and vehicles get charged.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !(target instanceof Infantry) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids into " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    " in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    "... " );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Resolve a charge against the target.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ToHitData toHit = new ToHitData();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toHit.setHitTable( target.isProne() ? <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ToHitData.HIT_NORMAL :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ToHitData.HIT_KICK );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toHit.setSideTable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (Compute.targetSideTable(entity, target));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveChargeDamage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (entity, target, toHit, prevFacing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The skid ends here if the target lives.<br/>
                                // TODO : do we keep skiding if the target<br/>
                                //      is pushed off the board?<br/>
                                if ( !target.isDoomed() &amp;&amp;<br/>
                                     !target.isDestroyed() ) {<br/>
                                    stopTheSkid = true;<br/>
                                }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Resolve "move-through" damage on infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids through " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    " in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    "... " );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry don't have different<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tables for punches and kicks<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HitData hit = target.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Compute.targetSideTable(entity, target)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Damage equals tonnage, divided by 5.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( damageEntity(target, hit, (int)Math.round(entity.getWeight()/5)) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // End handle-infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Has the target been destroyed?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( target.isDoomed() ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Has the target taken a turn?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !target.isDone() ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Dead entities don't take turns.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int targetOwnerId = target.getOwner().getId();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for ( int loop = turnIndex + 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  loop &lt; turns.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  loop++ ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Is the loop-th turn for the <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// destroyed target's player?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( targetOwnerId == ( (GameTurn)turns.elementAt(loop) ).getPlayerNum() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Yup. Remove the turn and stop looping.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turns.removeElementAt( loop );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // Check the next turn<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End target-still-to-move<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  Clean out the entity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.setDestroyed(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.moveToGraveyard(target.getId());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(target.getId()));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the target's position,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // unless it is off the game map.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !game.isInGraveyard(target) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityUpdate( target.getId() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End someone's-in-the-way<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do we stay in the current hex and stop skidding?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( stopTheSkid ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Did we skid into a building?<br/>
                        // TODO : BMRr pg. 22, only count buildings that are<br/>
                        //      higher than our starting terrain height.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( nextHex.contains(Terrain.BUILDING) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update report.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "   Skids into building in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // TODO : Damage the building and the skidding entity.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Skid into the building's hex and stop skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = nextPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.setPosition( curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update the position and keep skidding.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curPos = nextPos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setPosition( curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "   Skids into hex " ).append( <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos.getBoardNum() ).append( ".\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the next hex in the skid?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos = nextPos.translated( prevFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextHex = game.board.getHex( nextPos );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } // Handle the next skid hex.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // If the skidding entity violates stacking,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // displace targets until it doesn't.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = entity.getPosition();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    target = Compute.stackingViolation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(game, entity.getId(), curPos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    while (target != null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPos = Compute.getValidDisplacement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (game, target.getId(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     target.getPosition(), prevFacing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ASSUMPTION<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// There should always be *somewhere* that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the target can go... last skid hex if<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// nothing else is available.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( null == nextPos ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // But I don't trust the assumption fully.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Report the error and try to continue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    System.err.println( "The skid of " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" should displace " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.getShortName() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" in hex " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curPos.getBoardNum() +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" but there is nowhere to go."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "    " ); // indent displacement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doEntityDisplacement(target, curPos, nextPos, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = Compute.stackingViolation( game, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.getId(), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Mechs suffer damage for every hex skidded.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate one half falling damage times skid length.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// report skid damage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("    " ).append( entity.getDisplayName() ).append( " suffers " ).append( damage ).append( " damage from the skid.");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// standard damage loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All skid damage is to the front.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (damage &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int cluster = Math.min(5, damage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append(damageEntity(entity, hit, cluster));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    damage -= cluster;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append( "\n" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Clean up the entity if it has been destroyed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity.isDoomed() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setDestroyed(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.moveToGraveyard(entity.getId());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(createRemoveEntityPacket(entity.getId()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Let the player know the ordeal is over.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    phaseReport.append( "      Skid ends.\n" );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // set entity parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curFacing = entity.getFacing();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    curPos = entity.getPosition();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.setSecondaryFacing( curFacing );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    mpUsed = entity.getRunMP(); // skid consumes all movement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entity.moved = moveType;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    fellDuringMovement = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            }<br/>
<br/>
            // check if we've moved into rubble<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; curHex.levelOf(Terrain.RUBBLE) &gt; 0) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Rubble"));<br/>
            }<br/>
            <br/>
            // check to see if we've moved OUT of fire and we are a mech<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; game.board.getHex(lastPos).contains(Terrain.FIRE)) {<br/>
                if (entity instanceof Mech) {<br/>
                    entity.heatBuildup+=2;<br/>
                    phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
                    ).append( " passes through a fire.  It will generate 2 more heat this round.\n");<br/>
                }<br/>
            }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
            <br/>
            // check to see if we've moved INTO fire and we are not a mech<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; game.board.getHex(curPos).contains(Terrain.FIRE)) {<br/>
                if (!(entity instanceof Mech)) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
            }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
            // check if we've moved into water<br/>
            if (!lastPos.equals(curPos)<br/>
            &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
            &amp;&amp; curHex.levelOf(Terrain.WATER) &gt; 0<br/>
            &amp;&amp; entity.getMovementType() != Entity.MovementType.HOVER) {<br/>
                if (curHex.levelOf(Terrain.WATER) == 1) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"));<br/>
                } else if (curHex.levelOf(Terrain.WATER) == 2) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"));<br/>
                    // Any swarming infantry will be destroyed.<br/>
                    final int swarmerId = entity.getSwarmAttackerId();<br/>
                    if ( Entity.NONE != swarmerId ) {<br/>
                        final Entity swarmer = game.getEntity( swarmerId );<br/>
                        swarmer.setSwarmTargetId( Entity.NONE );<br/>
                        entity.setSwarmAttackerId( Entity.NONE );<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append( "   The swarming unit, " )<br/>
                            .append( swarmer.getShortName() )<br/>
                            .append( ", drowns!\n" )<br/>
                            .append( destroyEntity(swarmer,<br/>
                                                   "a watery grave", false) );<br/>
                        entityUpdate( swarmerId );<br/>
                    }<br/>
                } else {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"));<br/>
                    // Any swarming infantry will be destroyed.<br/>
                    final int swarmerId = entity.getSwarmAttackerId();<br/>
                    if ( Entity.NONE != swarmerId ) {<br/>
                        final Entity swarmer = game.getEntity( swarmerId );<br/>
                        swarmer.setSwarmTargetId( Entity.NONE );<br/>
                        entity.setSwarmAttackerId( Entity.NONE );<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append( "   The swarming unit, " )<br/>
                            .append( swarmer.getShortName() )<br/>
                            .append( ", drowns!\n" )<br/>
                            .append( destroyEntity(swarmer,<br/>
                                                   "a watery grave", false) );<br/>
                        entityUpdate( swarmerId );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mech on fire with infernos can wash them off.<br/>
                // Check if enterning depth 2 water or prone in depth 1.<br/>
                if ( entity instanceof Mech &amp;&amp;<br/>
                     entity.infernos.isStillBurning() ) {<br/>
                    if ( ( 1 == curHex.levelOf(Terrain.WATER) &amp;&amp;<br/>
                           entity.isProne() ) ||<br/>
                         ( 2 &lt;= curHex.levelOf(Terrain.WATER) ) ) {<br/>
<br/>
                        // Wash off inferno from mech and add one to hex.<br/>
                        game.board.addInfernoTo<br/>
                            ( curPos, InfernoTracker.STANDARD_ROUND, 1 );<br/>
                        entity.infernos.clear();<br/>
<br/>
                        // start a fire in the hex<br/>
                        phaseReport.append( " Inferno removed from " )<br/>
                            .append( entity.getDisplayName() )<br/>
                            .append( " and fire started in hex!\n" );<br/>
                        curHex.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
                        sendChangedHex(curPos);<br/>
                    }<br/>
                }<br/>
<br/>
            }<br/>
<br/>
            // Handle loading units.<br/>
            if ( step.getType() == MovementData.STEP_LOAD ) {<br/>
<br/>
                // Find the unit being loaded.<br/>
                Entity loaded = null;<br/>
                Enumeration entities = game.getEntities( curPos );<br/>
                while ( entities.hasMoreElements() ) {<br/>
<br/>
                    // Is the other unit friendly and not the current entity?<br/>
                    loaded = (Entity)entities.nextElement();<br/>
                    if ( entity.getOwner() == loaded.getOwner() &amp;&amp;<br/>
                         !entity.equals(loaded) ) {<br/>
<br/>
                        // The moving unit should be able to load the other<br/>
                        // unit and the other should be able to have a turn.<br/>
                        if ( !entity.canLoad(loaded) ||<br/>
                             !loaded.isSelectable() ) {<br/>
                            // Something is fishy in Denmark.<br/>
                            System.err.println( entity.getShortName() +<br/>
                                                " can not load " +<br/>
                                                loaded.getShortName() );<br/>
                            loaded = null;<br/>
                        }<br/>
                        else {<br/>
                            // Have the deployed unit load the indicated unit.<br/>
                            this.loadUnit( entity, loaded );<br/>
<br/>
                            // Stop looking.<br/>
                            break;<br/>
                        }<br/>
<br/>
                    } else {<br/>
                        // Nope. Discard it.<br/>
                        loaded = null;<br/>
                    }<br/>
<br/>
                } // Handle the next entity in this hex.<br/>
<br/>
                // We were supposed to find someone to load.<br/>
                if ( loaded == null ) {<br/>
                    System.err.println( "Could not find unit for " +<br/>
                                        entity.getShortName() +<br/>
                                        " to load in " + curPos );<br/>
                }<br/>
<br/>
            } // End STEP_LOAD<br/>
<br/>
            // Handle unloading units.<br/>
            if ( step.getType() == MovementData.STEP_UNLOAD ) {<br/>
                Entity unloaded = step.getTarget( game );<br/>
                if ( !this.unloadUnit( entity, unloaded,<br/>
                                       curPos, curFacing ) ) {<br/>
                    System.err.println( "Error! Server was told to unload " +<br/>
                                        unloaded.getShortName() +<br/>
                                        " from " + entity.getShortName() +<br/>
                                        " into " + curPos.getBoardNum() );<br/>
                }<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
            <br/>
            // update lastPos, prevFacing &amp; prevHex<br/>
            lastPos = new Coords(curPos);<br/>
            if (!curHex.equals(prevHex)) {<br/>
                prevFacing = curFacing;<br/>
            }<br/>
            prevHex = curHex;<br/>
        }<br/>
        <br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
        entity.mpUsed = mpUsed;<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == Entity.MOVE_JUMP &amp;&amp; !entity.isMakingDfa()) {<br/>
            // check for damaged criticals<br/>
            if (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0 || entity.hasLegActuatorCrit()) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "landing with damaged leg actuator or gyro"), false);<br/>
            }<br/>
            // jumped into water?<br/>
            int waterLevel = game.board.getHex(curPos).levelOf(Terrain.WATER);<br/>
            if (waterLevel == 1) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"), false);<br/>
            } else if (waterLevel == 2) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"), false);<br/>
                // Any swarming infantry will be destroyed.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                if ( Entity.NONE != swarmerId ) {<br/>
                    final Entity swarmer = game.getEntity( swarmerId );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setPosition( curPos );<br/>
                    phaseReport.append( "   The swarming unit, " )<br/>
                        .append( swarmer.getShortName() )<br/>
                        .append( ", drowns!\n" )<br/>
                        .append( destroyEntity(swarmer,<br/>
                                               "a watery grave", false) );<br/>
                    entityUpdate( swarmerId );<br/>
                }<br/>
            } else if (waterLevel &gt;= 3) {<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"), false);<br/>
                // Any swarming infantry will be destroyed.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                if ( Entity.NONE != swarmerId ) {<br/>
                    final Entity swarmer = game.getEntity( swarmerId );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setPosition( curPos );<br/>
                    phaseReport.append( "   The swarming unit, " )<br/>
                        .append( swarmer.getShortName() )<br/>
                        .append( ", drowns!\n" )<br/>
                        .append( destroyEntity(swarmer,<br/>
                                               "a watery grave", false) );<br/>
                    entityUpdate( swarmerId );<br/>
                }<br/>
            }<br/>
<br/>
            // If the entity is being swarmed, jumping may dislodge the fleas.<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                final PilotingRollData roll =<br/>
                    Compute.getBasePilotingRoll(game, entity.getId());<br/>
<br/>
                // Add a +4 modifier.<br/>
                roll.addModifier( 4, "dislodge swarming infantry" );<br/>
<br/>
                // If the swarmer has Assault claws, give a 1 modifier.<br/>
                // We can stop looking when we find our first match.<br/>
                for ( Enumeration iter = swarmer.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        roll.addModifier( 1, "swarmer has assault claws" );<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // okay, print the info<br/>
                phaseReport.append("\n")<br/>
                    .append( entity.getDisplayName() )<br/>
                    .append( " tries to dislodge swarming infantry.\n" );<br/>
<br/>
                // roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
                                   ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
                                   ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
                if (diceRoll &lt; roll.getValue()) {<br/>
                    phaseReport.append("fails.\n");<br/>
                } else {<br/>
                    phaseReport.append("succeeds.\n");<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
                    // Did the infantry fall into water?<br/>
                    final Hex curHex = game.board.getHex(curPos);<br/>
                    if ( curHex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
                        // Swarming infantry die.<br/>
                        swarmer.setPosition( curPos );<br/>
                        phaseReport.append("    ")<br/>
                            .append(swarmer.getDisplayName())<br/>
                            .append(" is dislodged and drowns!")<br/>
                            .append(destroyEntity(swarmer, "a watery grave", false));<br/>
                    } else {<br/>
                        // Swarming infantry take an 11 point hit.<br/>
                        // ASSUMPTION : damage should not be doubled.<br/>
                        phaseReport.append("    ")<br/>
                            .append(swarmer.getDisplayName())<br/>
                            .append(" is dislodged and suffers 11 damage.")<br/>
                            .append( damageEntity(swarmer, <br/>
                                                  swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),<br/>
                                                  11) )<br/>
                            .append( "\n" );<br/>
                        swarmer.setPosition( curPos );<br/>
                    }<br/>
                    entityUpdate( swarmerId );<br/>
                } // End successful-PSR<br/>
<br/>
            } // End try-to-dislodge-swarmers<br/>
<br/>
        } // End entity-is-jumping<br/>
<br/>
        // should we give another turn to the entity to keep moving?<br/>
        if (fellDuringMovement &amp;&amp; entity.mpUsed &lt; entity.getRunMP() <br/>
        &amp;&amp; entity.isSelectable() &amp;&amp; !entity.isDoomed()) {<br/>
            entity.applyDamage();<br/>
            entity.setDone(false);<br/>
            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());<br/>
            turns.insertElementAt(newTurn, turnIndex);<br/>
        } else {<br/>
            entity.setDone(true);<br/>
        }<br/>
        <br/>
        // Is the entity Infantry?<br/>
        if ( entity instanceof Infantry ) {<br/>
            // Increment the counter.<br/>
            turnInfMoved++;<br/>
<br/>
            // Record the player moving the infantry.<br/>
            turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
            // Do infantry move in blocks?<br/>
            if ( infMoveMulti ) {<br/>
<br/>
                // Are we at the end of a block?<br/>
                if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
                     !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
                                // Yup.  Reset the counter.<br/>
                    turnInfMoved = 0;<br/>
                }<br/>
                else {<br/>
                                // Nope.  Decrement the turn index.<br/>
                    turnIndex--;<br/>
                }<br/>
<br/>
            } // End inf_move_multi<br/>
<br/>
        } // End entity-is-infantry<br/>
<br/>
        // If the entity is being swarmed, update the attacker's position.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            swarmer.setPosition( curPos );<br/>
            // If the hex is on fire, and the swarming infantry is<br/>
            // *not* Battle Armor, it drops off.<br/>
            if ( !(swarmer instanceof BattleArmor) &amp;&amp;<br/>
                 game.board.getHex(curPos).contains(Terrain.FIRE) ) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                phaseReport.append( "\n   " )<br/>
                    .append( swarmer.getShortName() )<br/>
                    .append( " can't stand the fire's heat and drops off.\n" );<br/>
            }<br/>
            entityUpdate( swarmerId );<br/>
        }<br/>
<br/>
        // Update the entitiy's position,<br/>
        // unless it is off the game map.<br/>
        if ( !game.isInGraveyard(entity) ) {<br/>
            entityUpdate( entity.getId() );<br/>
        }<br/>
        <br/>
        // if using double blind, update the player on new units he might see<br/>
        if (doBlind()) {<br/>
            send(entity.getOwner().getId(), createFilteredEntitiesPacket(entity.getOwner()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add heat from the movement phase<br/>
     */<br/>
    public void addMovementHeat() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            // build up heat from movement<br/>
            if (entity.moved == Entity.MOVE_WALK) {<br/>
                entity.heatBuildup += 1;<br/>
            } else if (entity.moved == Entity.MOVE_RUN) {<br/>
                entity.heatBuildup += 2;<br/>
            } else if (entity.moved == Entity.MOVE_JUMP) {<br/>
                entity.heatBuildup += Math.max(3, entity.delta_distance);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the movement phase).<br/>
     * We have a special case for getting up because quads need not roll to stand<br/>
     * if they have no damaged legs.  If a quad is short a gyro, however....<br/>
     */<br/>
    private void doSkillCheckInPlace(Entity entity, PilotingRollData reason, boolean gettingUp) {<br/>
        // non-mechs should never get here<br/>
        if (! (entity instanceof Mech) || entity.isProne()) {<br/>
            return;<br/>
        }<br/>
        <br/>
        if (gettingUp &amp;&amp; !entity.needsRollToStand() &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &lt; 2)) {<br/>
            phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " does not need to make "<br/>
            ).append( "a piloting skill check to stand up because it has all four of its legs.");<br/>
            return;<br/>
        }<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        <br/>
        // append the reason modifier<br/>
        roll.append(reason);<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
        ).append( " must make a piloting skill check (" ).append( reason.getPlainDesc() ).append( ")"<br/>
        ).append( ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
        ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
        ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFall(entity, roll);<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
        <br/>
    }<br/>
    <br/>
    /**<br/>
     * Do a piloting skill check while moving<br/>
     *<br/>
     * @return &lt;code&gt;true&lt;/code&gt; if the pilot passes the skill check.<br/>
     */<br/>
    private boolean doSkillCheckWhileMoving(Entity entity, Coords src, Coords dest,<br/>
    PilotingRollData reason) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean result = true;<br/>
<br/>
        // Non mechs should never get here, unless we're avoiding skids.<br/>
        if (! (entity instanceof Mech) &amp;&amp; !reason.isForSkid() ) {<br/>
            return result;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        boolean fallsInPlace;<br/>
        int fallElevation;<br/>
        <br/>
        // append the reason modifier<br/>
        roll.append(reason);<br/>
        <br/>
        // will the entity fall in the source or destination hex?<br/>
        if ( src.equals(dest) ) {<br/>
            fallsInPlace = true;<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
        }<br/>
        <br/>
        // how far down did it fall?<br/>
        fallElevation = Math.abs(destHex.floor() - srcHex.floor());<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" ).append( entity.getDisplayName()<br/>
        ).append( " must make a piloting skill check"<br/>
        ).append( " while moving from hex " ).append( src.getBoardNum()<br/>
        ).append( " to hex " ).append( dest.getBoardNum()<br/>
        ).append( " (" ).append( reason.getPlainDesc() ).append( ")" ).append( ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " ).append( roll.getValueAsString()<br/>
        ).append( " [" ).append( roll.getDesc() ).append( "]"<br/>
        ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Vehicles don't fall, they fail<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("falls.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doEntityFallsInto(entity, (fallsInPlace ? dest : src), (fallsInPlace ? src : dest), roll);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phaseReport.append("fails.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.setPosition( fallsInPlace ? src : dest );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    result = false;<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return result;<br/>
    }<br/>
    <br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int fallElevation = Math.abs(destHex.floor() - srcHex.floor());<br/>
        int direction = src.direction(dest);<br/>
        // check entity in target hex<br/>
        Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
        // check if we can fall in that hex<br/>
        if (violation != null<br/>
        &amp;&amp; !Compute.isValidDisplacement(game, violation.getId(), src, dest)) {<br/>
            // if target can't be displaced, fall in source hex.<br/>
            // NOTE: source hex should never contain a non-displacable entity<br/>
            Coords temp = dest;<br/>
            dest = src;<br/>
            src = temp;<br/>
            violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
        }<br/>
        <br/>
        // falling mech falls<br/>
        phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
        ).append( fallElevation ).append( " level(s) into hex "<br/>
        ).append( dest.getBoardNum() ).append( ".\n");<br/>
        <br/>
        // if hex was empty, deal damage and we're done<br/>
        if (violation == null) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
        <br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2) {<br/>
            // accidental death from above<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            // target gets displaced<br/>
            doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
    PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
        // Handle null hexes.<br/>
        if ( srcHex == null || destHex == null ) {<br/>
            System.err.println( "Can not displace " + entity.getShortName() +<br/>
                                " from " + src + <br/>
                                " to " + dest + "." );<br/>
        }<br/>
        int fallElevation = entity.elevationOccupied(srcHex) - entity.elevationOccupied(destHex);<br/>
        Entity violation =Compute.stackingViolation(game, entity.getId(), dest);<br/>
        <br/>
        // can't fall upwards<br/>
        if (fallElevation &lt; 0) {<br/>
            fallElevation = 0;<br/>
        }<br/>
        <br/>
        // if destination is empty, this could be easy...<br/>
        if (violation == null) {<br/>
            if (fallElevation &lt; 2) {<br/>
                // no cliff: move and roll normally<br/>
                phaseReport.append(entity.getDisplayName()<br/>
                ).append( " is displaced into hex "<br/>
                ).append( dest.getBoardNum() ).append( ".\n");<br/>
                entity.setPosition(dest);<br/>
                if (roll != null) {<br/>
                    pilotRolls.addElement(roll);<br/>
                }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update the entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityUpdate( entity.getId() );<br/>
                return;<br/>
            } else {<br/>
                // cliff: fall off it, deal damage, prone immediately<br/>
                phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
                ).append( fallElevation ).append( " levels into hex "<br/>
                ).append( dest.getBoardNum() ).append( ".\n");<br/>
                // only given a modifier, so flesh out into a full piloting roll<br/>
                PilotingRollData pilotRoll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
                if (roll != null) {<br/>
                    pilotRoll.append(roll);<br/>
                }<br/>
                doEntityFall(entity, dest, fallElevation, pilotRoll);<br/>
                return;<br/>
            }<br/>
        }<br/>
        <br/>
        // okay, destination occupied.  hmmm...<br/>
        System.err.println("server.doEntityDisplacement: destination occupied");<br/>
        if (fallElevation &lt; 2) {<br/>
            // domino effect: move &amp; displace target<br/>
            phaseReport.append(entity.getDisplayName()<br/>
            ).append( " is displaced into hex "<br/>
            ).append( dest.getBoardNum() ).append( ", violating stacking with "<br/>
            ).append( violation.getDisplayName() ).append( ".\n");<br/>
            entity.setPosition(dest);<br/>
            if (roll != null) {<br/>
                pilotRolls.addElement(roll);<br/>
            }<br/>
            doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
            return;<br/>
        } else {<br/>
            // accidental fall from above: havoc!<br/>
            phaseReport.append(entity.getDisplayName() ).append( " falls "<br/>
            ).append( fallElevation ).append( " levels into hex "<br/>
            ).append( dest.getBoardNum() ).append( ", violating stacking with "<br/>
            ).append( violation.getDisplayName() ).append( ".\n");<br/>
            <br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "base");<br/>
            toHit.append(Compute.getTargetMovementModifier(game, violation.getId()));<br/>
            toHit.append(Compute.getTargetTerrainModifier(game, violation));<br/>
            <br/>
            // roll dice<br/>
            final int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("Collision occurs on a " ).append( toHit.getValue()<br/>
            ).append( " or greater.  Rolls " ).append( diceRoll);<br/>
            if (diceRoll &gt;= toHit.getValue()) {<br/>
                phaseReport.append(", hits!\n");<br/>
                // deal damage to target<br/>
                int damage = (int)Math.ceil(entity.getWeight() / 10);<br/>
                phaseReport.append(violation.getDisplayName() ).append( " takes "<br/>
                ).append( damage ).append( " from the collision.");<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = violation.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                    phaseReport.append(damageEntity(violation, hit, cluster));<br/>
                    damage -= cluster;<br/>
                }<br/>
                phaseReport.append("\n");<br/>
                <br/>
                // attacker falls as normal, on his back<br/>
                // only given a modifier, so flesh out into a full piloting roll<br/>
                PilotingRollData pilotRoll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
                pilotRoll.append(roll);<br/>
                doEntityFall(entity, dest, fallElevation, 3, pilotRoll);<br/>
                <br/>
                // defender pushed away, or destroyed<br/>
                Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(violation, dest, targetDest, new PilotingRollData(violation.getId(), 2, "fallen on"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the violating entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( violation.getId() );<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append(destroyEntity(violation, "impossible displacement", false));<br/>
                }<br/>
            } else {<br/>
                phaseReport.append(", misses.\n");<br/>
                //TODO: this is not quite how the rules go<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.IMPOSSIBLE, "pushed off a cliff"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Update the entity's postion on the client.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    entityUpdate( entity.getId() );<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append(destroyEntity(entity, "impossible displacement", false));<br/>
                }<br/>
            }<br/>
            return;<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receive a deployment packet.  If valid, execute it and end the current<br/>
     * turn.<br/>
     */<br/>
    private void receiveDeployment(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Coords coords = (Coords)packet.getObject(1);<br/>
        int nFacing = packet.getIntValue(2);<br/>
        <br/>
        // Handle units that deploy loaded with other units.<br/>
        int loadedCount = packet.getIntValue(3);<br/>
        Vector loadVector = new Vector();<br/>
        for ( int i = 0; i &lt; loadedCount; i++ ){<br/>
            int loadedId = packet.getIntValue( 4 + i );<br/>
            loadVector.<span class="upd">addElement</span>(game.getEntity( loadedId ));<br/>
        }<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_DEPLOYMENT) {<br/>
            System.err.println("error: server got deployment packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)<br/>
        || !game.board.isLegalDeployment(coords, entity.getOwner())) {<br/>
            System.err.println("error: server got invalid deployment packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processDeployment(entity, coords, nFacing, loadVector);<br/>
        endCurrentTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process a deployment packet by... deploying the entity!  We load any<br/>
     * other specified entities inside of it too.  Also, check that the<br/>
     * deployment is valid.<br/>
     */<br/>
    private void processDeployment(Entity entity, Coords coords, int nFacing, Vector loadVector) {<br/>
        for (Enumeration i = loadVector.elements(); i.hasMoreElements();) {<br/>
            Entity loaded = (Entity)i.nextElement();<br/>
            if ( loaded == null || loaded.getPosition() != null ||<br/>
                 loaded.getTransportId() != Entity.NONE ) {<br/>
                // Something is fishy in Denmark.<br/>
                System.err.println("error: " + entity + " can not load entity #" + loaded );<br/>
                break;<br/>
            }<br/>
            else {<br/>
                // Have the deployed unit load the indicated unit.<br/>
                this.loadUnit( entity, loaded );<br/>
            }<br/>
        }<br/>
<br/>
        entity.setPosition(coords);<br/>
        entity.setFacing(nFacing);<br/>
        entity.setSecondaryFacing(nFacing);<br/>
        entity.setDone(true);<br/>
        entityUpdate(entity.getId());<br/>
        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Is the entity Infantry?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Increment the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    turnInfMoved++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Record the player moving the infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Do infantry move in blocks?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMoveMulti ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Are we at the end of a block?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Yup.  Reset the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Nope.  Decrement the turn index.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    turnIndex--;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } // End inf_move_multi<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} // End entity-is-infantry<br/>
    }<br/>
    <br/>
    /**<br/>
     * Gets a bunch of entity attacks from the packet.  If valid, processess<br/>
     * them and ends the current turn.<br/>
     */<br/>
    private void receiveAttack(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Vector vector = (Vector)packet.getObject(1);<br/>
        <br/>
        // is this the right phase?<br/>
        if (game.getPhase() != Game.PHASE_FIRING <br/>
        &amp;&amp; game.getPhase() != Game.PHASE_PHYSICAL) {<br/>
            System.err.println("error: server got attack packet in wrong phase");<br/>
            return;<br/>
        }<br/>
        <br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity)) {<br/>
            System.err.println("error: server got invalid attack packet");<br/>
            return;<br/>
        }<br/>
        <br/>
        // looks like mostly everything's okay<br/>
        processAttack(entity, vector);<br/>
        endCurrentTurn();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process a batch of entity attack (or twist) actions by adding them to<br/>
     * the proper list to be processed later.<br/>
     */<br/>
    private void processAttack(Entity entity, Vector vector) {<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            <br/>
            // is this the right entity?<br/>
            if (ea.getEntityId() != entity.getId()) {<br/>
                System.err.println("error: attack packet has wrong attacker");<br/>
                continue;<br/>
            }<br/>
            <br/>
            if (ea instanceof PushAttackAction) {<br/>
                // push attacks go the end of the displacement attacks<br/>
                PushAttackAction paa = (PushAttackAction)ea;<br/>
                entity.setDisplacementAttack(paa);<br/>
                pendingCharges.addElement(paa);<br/>
            } else {<br/>
                // add to the normal attack list.<br/>
                attacks.addElement(ea);<br/>
            }<br/>
        }<br/>
        // this entity is done for the round<br/>
        entity.setDone(true);<br/>
        entityUpdate(entity.getId());<br/>
        <br/>
        // update all players on the attacks<br/>
        send(createAttackPacket(vector));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Auto-target active AMS systems<br/>
     */<br/>
    private void assignAMS() {<br/>
        <br/>
        // sort all missile-based attacks by the target<br/>
        Hashtable htAttacks = new Hashtable();<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements(); ) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());<br/>
<br/>
                // Only entities can have AMS.<br/>
                if ( Targetable.TYPE_ENTITY != waa.getTargetType() ) {<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Can only use AMS versus missles.<br/>
                if (((WeaponType)weapon.getType()).getDamage() == WeaponType.DAMAGE_MISSILE) {<br/>
                    Entity target = game.getEntity(waa.getTargetId());<br/>
                    Vector v = (Vector)htAttacks.get(target);<br/>
                    if (v == null) {<br/>
                        v = new Vector();<br/>
                        htAttacks.put(target, v);<br/>
                    }<br/>
                    v.addElement(waa);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        // let each target assign its AMS<br/>
        for (Enumeration i = htAttacks.keys(); i.hasMoreElements(); ) {<br/>
            Entity e = (Entity)i.nextElement();<br/>
            Vector vAttacks = (Vector)htAttacks.get(e);<br/>
            e.assignAMS(vAttacks, attacks);<br/>
        }<br/>
    }<br/>
<br/>
        <br/>
    <br/>
    /**<br/>
     * Resolve all fire for the round<br/>
     */<br/>
    private void resolveWeaponAttacks() {<br/>
        roundReport.append("\nWeapon Attack Phase\n-------------------\n");<br/>
        <br/>
        Vector results = new Vector(attacks.size());<br/>
        <br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            Entity entity = game.getEntity(((EntityAction)o).getEntityId());<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                results.addElement(preTreatWeaponAttack(waa));<br/>
                //resolveWeaponAttack(waa, cen);<br/>
            } else if (o instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)o;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
            } else if (o instanceof FlipArmsAction) {<br/>
                FlipArmsAction faa = (FlipArmsAction)o;<br/>
                game.getEntity(faa.getEntityId()).setArmsFlipped(faa.getIsFlipped());<br/>
            } else if (o instanceof FindClubAction) {<br/>
                FindClubAction fca = (FindClubAction)o;<br/>
                entity.setFindingClub(true);<br/>
                try {<br/>
                    entity.addEquipment(EquipmentType.getByInternalName("Tree Club"), Mech.LOC_NONE);<br/>
                } catch (LocationFullException ex) {<br/>
                    // unlikely...<br/>
                }<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " uproots a tree for use as a club.\n");<br/>
            } else if (o instanceof UnjamAction) {<br/>
                resolveUnjam(entity.getId());<br/>
            } else {<br/>
                // hmm, error<br/>
            }<br/>
        }<br/>
        <br/>
        // loop through weapon results and resolve<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = results.elements(); i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult)i.nextElement();<br/>
            resolveWeaponAttack(wr, cen);<br/>
            cen = wr.waa.getEntityId();<br/>
        }<br/>
        <br/>
        // and clear the attacks Vector<br/>
        attacks.removeAllElements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolve an Unjam Action object<br/>
     */<br/>
    private void resolveUnjam(int EntityId) {<br/>
        final Entity ae = game.getEntity(EntityId);<br/>
        final int TN = ae.crew.getGunnery() + 3;<br/>
        phaseReport.append("\nRAC unjam attempts for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        for (Enumeration i = ae.getWeapons(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if(mounted.isJammed()) {<br/>
                WeaponType wtype = (WeaponType)mounted.getType();<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                    phaseReport.append("  Unjamming " ).append( wtype.getName() ).append( "; needs " ).append( TN ).append( ", ");<br/>
                    int roll = Compute.d6(2);<br/>
                    phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
                    if(roll &gt;= TN) {<br/>
                        phaseReport.append(" Successfully unjammed!\n");<br/>
                        mounted.setJammed(false);<br/>
                    }<br/>
                    else {<br/>
                        phaseReport.append(" Still jammed!\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Generated by a first pass through the weapon attack list.<br/>
     */<br/>
    private class WeaponResult {<br/>
        public WeaponAttackAction waa = null;<br/>
        public ToHitData toHit = null; // stored before ammo depletion, jams<br/>
        public int roll = -1;<br/>
        public boolean revertsToSingleShot = false;<br/>
        public int amsShotDown = 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Generates a WeaponResult object for a WeaponAttackAction.  Adds heat,<br/>
     * depletes ammo, sets weapons used.<br/>
     */<br/>
    private WeaponResult preTreatWeaponAttack(WeaponAttackAction waa) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        Mounted ammo = null;<br/>
        if (usesAmmo) {<br/>
            if (waa.getAmmoId() &gt; -1) {<br/>
                ammo = ae.getEquipment(waa.getAmmoId());<br/>
                weapon.setLinked(ammo);<br/>
            } else {<br/>
                ammo = weapon.getLinked();<br/>
            }<br/>
        }<br/>
        boolean streakMiss;<br/>
        <br/>
        WeaponResult wr = new WeaponResult();<br/>
        wr.waa = waa;<br/>
        <br/>
        // has this weapon fired already?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon has already been used this round");<br/>
            return wr;<br/>
        }<br/>
        // is the weapon functional?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon was destroyed in a previous round");<br/>
            return wr;<br/>
        }<br/>
        // is it jammed?<br/>
        if (weapon.isJammed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon is jammed");<br/>
            return wr;<br/>
        }<br/>
        <br/>
        // make sure ammo is loaded<br/>
        if (usesAmmo &amp;&amp; (ammo == null || ammo.getShotsLeft() == 0 || ammo.isDumping())) {<br/>
            ae.loadWeapon(weapon);<br/>
            ammo = weapon.getLinked();<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        wr.toHit = Compute.toHitWeapon(game, waa, attacks);<br/>
        <br/>
        // roll dice<br/>
        wr.roll = Compute.d6(2);<br/>
        <br/>
        // if the shot is possible and not a streak miss, add heat and use ammo<br/>
        streakMiss = (wtype.getAmmoType() == AmmoType.T_SRM_STREAK &amp;&amp; wr.roll &lt; wr.toHit.getValue());<br/>
        if (wr.toHit.getValue() != TargetRoll.IMPOSSIBLE &amp;&amp; !streakMiss) {<br/>
            wr = addHeatUseAmmoFor(waa, wr);<br/>
        }<br/>
        <br/>
        // set the weapon as having fired<br/>
        weapon.setUsedThisRound(true);<br/>
        <br/>
        // if not streak miss, resolve any AMS attacks on this attack<br/>
        if (!streakMiss) {<br/>
            wr = resolveAmsFor(waa, wr);<br/>
        }<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Adds heat and uses ammo appropriate for a single attack of this weapon.<br/>
     * Call only on a valid attack (and with a streak weapon, only on hits.)<br/>
     *<br/>
     * @returns modified WeaponResult<br/>
     */<br/>
    private WeaponResult addHeatUseAmmoFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        Mounted ammo = weapon.getLinked();<br/>
        <br/>
        // how many shots are we firing?<br/>
        int nShots = howManyShots(weapon, ammo);<br/>
        <br/>
        // do we need to revert to single shot?<br/>
        if (usesAmmo &amp;&amp; nShots &gt; 1) {<br/>
            int nAvail = ae.getTotalAmmoOfType((AmmoType)ammo.getType());<br/>
            if (nAvail &lt; nShots) {<br/>
                wr.revertsToSingleShot = true;<br/>
                nShots = 1;<br/>
            }<br/>
        }<br/>
        <br/>
        // use up ammo<br/>
        if (usesAmmo) {<br/>
            for (int i = 0; i &lt; nShots; i++) {<br/>
                if (ammo.getShotsLeft() &lt;= 0) {<br/>
                    ae.loadWeapon(weapon);<br/>
                    ammo = weapon.getLinked();<br/>
                }<br/>
                ammo.setShotsLeft(ammo.getShotsLeft() - 1);<br/>
            }<br/>
        }<br/>
        <br/>
        // build up some heat<br/>
        ae.heatBuildup += (wtype.getHeat() * nShots);<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolves any AMS fire for this weapon attack, adding AMS heat, depleting<br/>
     * AMS ammo.<br/>
     * @returns the appropriately modified WeaponResult<br/>
     */<br/>
    private WeaponResult resolveAmsFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
        <br/>
        // any AMS attacks by the target?<br/>
        Vector vCounters = waa.getCounterEquipment();<br/>
        if (vCounters == null) {<br/>
            return wr;<br/>
        } <br/>
        <br/>
        // resolve AMS counter-fire<br/>
        for (int x = 0; x &lt; vCounters.size(); x++) {<br/>
            Mounted counter = (Mounted)vCounters.elementAt(x);<br/>
            Mounted mAmmo = counter.getLinked();<br/>
            if (!(counter.getType() instanceof WeaponType) <br/>
            || ((WeaponType)counter.getType()).getAmmoType() != AmmoType.T_AMS<br/>
            || !counter.isReady() || counter.isMissing()) {<br/>
                continue;<br/>
            }<br/>
            // roll hits<br/>
            int amsHits = Compute.d6(((WeaponType)counter.getType()).getDamage());<br/>
<br/>
            // build up some heat (assume target is ams owner)<br/>
            te.heatBuildup += ((WeaponType)counter.getType()).getHeat();<br/>
<br/>
            // decrement the ammo<br/>
            mAmmo.setShotsLeft(Math.max(0, mAmmo.getShotsLeft() - amsHits));<br/>
<br/>
            // set the ams as having fired<br/>
            counter.setUsedThisRound(true);<br/>
<br/>
            wr.amsShotDown += amsHits;<br/>
        }<br/>
        <br/>
        return wr;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns how many shots the weapon is using<br/>
     */<br/>
    private int howManyShots(Mounted weapon, Mounted ammo) {<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        int nShots = 1;<br/>
        // figure out # of shots for variable-shot weapons<br/>
        if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA &amp;&amp; weapon.curMode().equals("Ultra")) {<br/>
            nShots = 2;<br/>
        } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY ||<br/>
                   wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
            if (weapon.curMode().equals("2-shot")) {<br/>
                nShots = 2;<br/>
            } else if (weapon.curMode().equals("3-shot")) {<br/>
                nShots = 3;<br/>
            } else if (weapon.curMode().equals("4-shot")) {<br/>
                nShots = 4;<br/>
            } else if (weapon.curMode().equals("6-shot")) {<br/>
                nShots = 6;<br/>
            }<br/>
        }<br/>
        return nShots;<br/>
    }<br/>
    <br/>
    private boolean tryIgniteHex(Coords c, boolean bInferno, int nTargetRoll) {        <br/>
    <br/>
        boolean bAnyTerrain = false;<br/>
        // inferno always ignites<br/>
        if (bInferno) {<br/>
            game.board.addInfernoTo(c, InfernoTracker.STANDARD_ROUND, 1);<br/>
            nTargetRoll = 0;<br/>
            bAnyTerrain = true;<br/>
        }<br/>
        <br/>
        Hex hex = game.board.getHex(c);                                 <br/>
        if (burn(hex, nTargetRoll, bAnyTerrain)) {<br/>
            phaseReport.append("           The hex ignites!\n");<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
    <br/>
    private boolean tryClearHex(Coords c, int nTarget) {<br/>
        <br/>
        Hex h = game.board.getHex(c);<br/>
        int woodsRoll = Compute.d6(2);<br/>
        phaseReport.append("    Checking to clear woods; needs " ).append( nTarget )<br/>
                .append( ", rolls " ).append( woodsRoll ).append( ": ");<br/>
<br/>
        if(woodsRoll &gt;= nTarget) {<br/>
            int woods = h.levelOf(Terrain.WOODS);<br/>
            if(woods &gt; 1) {<br/>
                 h.removeTerrain(Terrain.WOODS);<br/>
                 h.addTerrain(new Terrain(Terrain.WOODS, woods - 1));<br/>
                 phaseReport.append(" Heavy Woods converted to Light Woods!\n");<br/>
            }<br/>
            else if(woods == 1) {<br/>
                 h.removeTerrain(Terrain.WOODS);<br/>
                 h.addTerrain(new Terrain(Terrain.ROUGH, 1));<br/>
                 phaseReport.append(" Light Woods converted to Rough!\n");<br/>
            }<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        } else {<br/>
            phaseReport.append(" fails!\n");<br/>
            return false;<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     */<br/>
    private void resolveWeaponAttack(WeaponResult wr, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
        final Targetable target = game.getTarget(wr.waa.getTargetType(), wr.waa.getTargetId());<br/>
        Entity entityTarget = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            entityTarget = (Entity)target;<br/>
        }<br/>
        final Mounted weapon = ae.getEquipment(wr.waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        final boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
        // 2002-09-16 Infantry weapons have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !isWeaponInfantry;<br/>
        final Mounted ammo = usesAmmo ? weapon.getLinked() : null;<br/>
        final AmmoType atype = ammo == null ? null : (AmmoType)ammo.getType();<br/>
        Infantry platoon = null;<br/>
        BattleArmor troopers = null;<br/>
        final boolean isBattleArmorAttack = wtype.hasFlag(WeaponType.F_BATTLEARMOR);<br/>
        ToHitData toHit = wr.toHit;<br/>
        boolean bInferno = (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_INFERNO);<br/>
        if (!bInferno) {<br/>
            // also check for inferno infantry<br/>
            bInferno = (isWeaponInfantry &amp;&amp; wtype.hasFlag(WeaponType.F_INFERNO));<br/>
        }<br/>
        <br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nWeapons fire for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
<br/>
        // Swarming infantry can stop during any weapons phase after start.<br/>
        if ( Infantry.STOP_SWARM.equals( wtype.getInternalName() ) ) {<br/>
            // ... but only as their *only* attack action.<br/>
            if ( toHit.getValue() == ToHitData.IMPOSSIBLE ) {<br/>
                phaseReport.append( "Swarm attack can not be ended (" +<br/>
                                    toHit.getDesc() ).append( ")\n" );<br/>
                return;<br/>
            } else {<br/>
                phaseReport.append( "Swarm attack ended.\n" );<br/>
                // Only apply the "stop swarm 'attack'" to the swarmed Mek.<br/>
                if ( ae.getSwarmTargetId() != target.getTargetID() ) {<br/>
                    Entity other = game.getEntity( ae.getSwarmTargetId() );<br/>
                    other.setSwarmAttackerId( Entity.NONE );<br/>
                } else {<br/>
                    entityTarget.setSwarmAttackerId( Entity.NONE );<br/>
                }<br/>
                ae.setSwarmTargetId( Entity.NONE );<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Report weapon attack and its to-hit value.<br/>
        phaseReport.append("    " ).append( wtype.getName() ).append( " at " ).append( target.getDisplayName());<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the shot is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_FAIL) {<br/>
            phaseReport.append(", the shot is an automatic miss (" ).append( toHit.getDesc() ).append( "), ");<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            phaseReport.append(", the shot is an automatic hit (" ).append( toHit.getDesc() ).append( "), ");<br/>
        } else {<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        }<br/>
        <br/>
        // if firing an HGR unbraced, schedule a PSR<br/>
        if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY &amp;&amp; ae.mpUsed &gt; 0) {<br/>
            // the mod is weight-based<br/>
            int nMod;<br/>
            if (ae.getWeight() &lt;= Mech.WEIGHT_LIGHT) {<br/>
                nMod = 2;<br/>
            } else if (ae.getWeight() &lt;= Mech.WEIGHT_MEDIUM) {<br/>
                nMod = 1;<br/>
            } else if (ae.getWeight() &lt;= Mech.WEIGHT_HEAVY) {<br/>
                nMod = 0;<br/>
            } else {<br/>
                nMod = -1;<br/>
            }<br/>
            <br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), nMod, "fired HeavyGauss unbraced"));<br/>
        }<br/>
        <br/>
        // dice have been rolled, thanks<br/>
        phaseReport.append("rolls " ).append( wr.roll ).append( " : ");<br/>
        <br/>
        // check for AC jams<br/>
        int nShots = howManyShots(weapon, ammo);<br/>
        if (nShots &gt; 1) {<br/>
            int jamCheck = 0;<br/>
            if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA &amp;&amp; weapon.curMode().equals("Ultra")) {<br/>
                jamCheck = 2;<br/>
            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                if (nShots == 2) {<br/>
                    jamCheck = 2;<br/>
                }<br/>
                else if (nShots == 4) {<br/>
                    jamCheck = 3;<br/>
                }<br/>
                else if (nShots == 6) {<br/>
                    jamCheck = 4;<br/>
                }<br/>
            }<br/>
        <br/>
            if (jamCheck &gt; 0 &amp;&amp; wr.roll &lt;= jamCheck) {<br/>
                phaseReport.append("misses AND THE AUTOCANNON JAMS.\n");<br/>
                weapon.setJammed(true);<br/>
                // ultras are destroyed by jamming<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ULTRA) {<br/>
                    weapon.setHit(true);<br/>
                }<br/>
                return;<br/>
            }<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (wr.roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            if (wr.amsShotDown &gt; 0) {<br/>
                phaseReport.append("\tAMS activates, firing " ).append( wr.amsShotDown ).append( " shot(s).\n");<br/>
            }<br/>
            <br/>
            // Non-streaks can set fires on misses<br/>
            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL &amp;&amp; wtype.getAmmoType() != AmmoType.T_SRM_STREAK) {<br/>
                <br/>
                // make sure it's a fire-setting weapon<br/>
                if (bInferno || wtype.getFireTN() != TargetRoll.IMPOSSIBLE) {<br/>
                    tryIgniteHex(target.getPosition(), bInferno, 11);<br/>
                }<br/>
            }<br/>
<br/>
            return;<br/>
        }<br/>
        <br/>
        // special case NARC hits.  No damage, but a beacon is appended<br/>
        if (wtype.getAmmoType() == AmmoType.T_NARC) {<br/>
            if (entityTarget == null) {<br/>
                phaseReport.append("hits, but doesn't do anything.\n");<br/>
            } else {<br/>
                entityTarget.setNarcedBy(ae.getOwner().getTeam());<br/>
                phaseReport.append("hits.  Pod attached.\n");<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // yeech.  handle damage. . different weapons do this in very different ways<br/>
        int hits = 1, nCluster = 1, nSalvoBonus = 0;<br/>
        int nDamPerHit = wtype.getDamage();<br/>
        boolean bSalvo = false;<br/>
        // ecm check is heavy, so only do it once<br/>
        boolean bCheckedECM = false;<br/>
        boolean bECMAffected = false;<br/>
        boolean bMekStealthActive = false;<br/>
        String sSalvoType = " shot(s) ";<br/>
<br/>
        // Mek swarms attach the attacker to the target.<br/>
        if ( Infantry.SWARM_MEK.equals( wtype.getInternalName() ) ) {<br/>
            // Is the target already swarmed?<br/>
            if ( Entity.NONE != entityTarget.getSwarmAttackerId() ) {<br/>
                phaseReport.append( "succeds, but the defender is " );<br/>
                phaseReport.append( "already swarmed by another unit.\n" );<br/>
            } else {<br/>
                phaseReport.append( "succeeds!  Defender swarmed.\n" );<br/>
                ae.setSwarmTargetId( wr.waa.getTargetId() );<br/>
                entityTarget.setSwarmAttackerId( wr.waa.getEntityId() );<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Magnetic Mine Launchers roll number of hits on battle armor<br/>
        // hits table but use # mines firing instead of men shooting.<br/>
        else if ( wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
            hits = Compute.getBattleArmorHits( nShots );<br/>
            bSalvo = true;<br/>
            sSalvoType = " mine(s) ";<br/>
        }<br/>
<br/>
        // Other battle armor attacks use # of men firing to determine hits.<br/>
        // Each hit can be in a new location. The damage per shot comes from<br/>
        // the "racksize".<br/>
        else if ( isBattleArmorAttack ) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry) ae;<br/>
            nCluster = 1;<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            hits = platoon.getShootingStrength();<br/>
            // All attacks during Mek Swarms hit; all<br/>
            // others use the Battle Armor hits table.<br/>
            if ( ae.getSwarmTargetId() != wr.waa.getTargetId() ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
<br/>
            // Handle Inferno SRM squads.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        // Infantry damage depends on # men left in platoon.<br/>
        else if (isWeaponInfantry) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry)ae;<br/>
            nCluster = 5;<br/>
            nDamPerHit = 1;<br/>
            hits = platoon.getDamage(platoon.getShootingStrength());<br/>
<br/>
            // Handle Inferno SRM infantry.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
        } else if (wtype.getDamage() == WeaponType.DAMAGE_MISSILE ||<br/>
                   wtype.hasFlag(WeaponType.F_MISSILE_HITS) ) {<br/>
            bSalvo = true;<br/>
<br/>
            // Weapons with ammo type T_BA_MG or T_BA_SMALL_LASER<br/>
            // don't have an atype object.<br/>
            if ( wtype.getAmmoType() == AmmoType.T_BA_MG ||<br/>
                 wtype.getAmmoType() == AmmoType.T_BA_SMALL_LASER ) {<br/>
                nDamPerHit = Math.abs( wtype.getAmmoType() );<br/>
            } else {<br/>
                sSalvoType = " missile(s) ";<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
            }<br/>
            <br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_MRM || <br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
                nCluster = 5;<br/>
            }<br/>
<br/>
            // calculate # of missiles hitting<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM || <br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
                <br/>
                // check for artemis, else check for narc<br/>
                Mounted mLinker = weapon.getLinkedBy();<br/>
                if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                     ( mLinker != null &amp;&amp;<br/>
                       mLinker.getType() instanceof MiscType &amp;&amp; <br/>
                       !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp;<br/>
                       mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) ) {<br/>
                            <br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        } else {<br/>
                            bECMAffected = Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition());<br/>
                        }<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                } else if (entityTarget != null &amp;&amp; entityTarget.isNarcedBy(ae.getOwner().getTeam())) {<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        } else {<br/>
                            bECMAffected = Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition());<br/>
                        }<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If dealing with Inferno rounds set damage to zero and reset<br/>
            // all salvo bonuses (cannot mix with other special munitions).<br/>
            if (bInferno) {<br/>
                    nDamPerHit = 0;<br/>
                    nSalvoBonus = 0;<br/>
                    sSalvoType = " inferno missile(s) ";<br/>
                    bSalvo = false;<br/>
            }<br/>
<br/>
            if (wtype.getAmmoType() == AmmoType.T_SRM_STREAK) {<br/>
                hits = wtype.getRackSize();<br/>
            } else if ( wtype.getRackSize() == 30 ||<br/>
                        wtype.getRackSize() == 40 ) {<br/>
                // I'm going to assume these are MRMs<br/>
                hits = Compute.missilesHit(wtype.getRackSize() / 2) +<br/>
                    Compute.missilesHit(wtype.getRackSize() / 2);<br/>
            } else if ( ae instanceof BattleArmor ) {<br/>
<br/>
                // Battle Armor units multiply their racksize by the<br/>
                // # of men shooting and they can't use NARCs.<br/>
                platoon = (Infantry) ae;<br/>
                int temp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
<br/>
                // All attacks during Mek Swarms hit the same location;<br/>
                // all others use the Battle Armor hits table.<br/>
                hits = temp;<br/>
                if ( ae.getSwarmTargetId() != wr.waa.getTargetId() ) {<br/>
<br/>
                    // Account for more than 20 missles hitting.<br/>
                    hits = 0;<br/>
                    while ( temp &gt; 20 ) {<br/>
                        hits += Compute.missilesHit( 20 );<br/>
                        temp -= 20;<br/>
                    }<br/>
                    hits += Compute.missilesHit( temp );<br/>
<br/>
                } // End not-mek-swarming<br/>
                <br/>
            } else {<br/>
                hits = Compute.missilesHit(wtype.getRackSize(), nSalvoBonus);<br/>
            }<br/>
<br/>
            // Advanced SRM's don't hit with an odd # of missles.<br/>
            if ( null != atype &amp;&amp;<br/>
                 atype.getAmmoType() == AmmoType.T_SRM_ADVANCED ) {<br/>
                hits = 2 * (int) Math.floor( (1.0 + (float) hits) / 2.0);<br/>
            }<br/>
<br/>
        } else if (atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            // Cluster shots break into single point clusters.<br/>
            bSalvo = true;<br/>
            hits = Compute.missilesHit(wtype.getRackSize());<br/>
            nDamPerHit = 1;<br/>
        } else if (nShots &gt; 1) {<br/>
            // this should handle multiple attacks from ultra and rotary ACs<br/>
            bSalvo = true;<br/>
            hits = Compute.missilesHit(nShots);<br/>
        } else if (atype != null &amp;&amp; atype.hasFlag(AmmoType.F_MG) &amp;&amp;<br/>
                   !isWeaponInfantry &amp;&amp; (target instanceof Infantry) &amp;&amp;<br/>
                   !(target instanceof BattleArmor) ) {<br/>
            // Mech and Vehicle MGs do *DICE* of damage to PBI.<br/>
            // 2002-10-24 Suvarov454 : no need for so many lines in the report.<br/>
            nDamPerHit = Compute.d6(wtype.getDamage());<br/>
            phaseReport.append( "riddles the target with " ).append( <br/>
                nDamPerHit ).append( sSalvoType ).append( "and " );<br/>
        }<br/>
        else if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY) {<br/>
            // HGR does range-dependent damage<br/>
            int nRange = ae.getPosition().distance(target.getPosition());<br/>
            if (nRange &lt;= wtype.getShortRange()) {<br/>
                nDamPerHit = 25;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nDamPerHit = 20;<br/>
            } else {<br/>
                nDamPerHit = 10;<br/>
            }<br/>
        }<br/>
<br/>
        // Some weapons double the number of hits scored.<br/>
        if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
            hits *= 2;<br/>
        }<br/>
<br/>
        // All attacks (except from infantry weapons)<br/>
        // during Mek Swarms hit the same location.<br/>
        if ( !isWeaponInfantry &amp;&amp;<br/>
             ae.getSwarmTargetId() == wr.waa.getTargetId() ) {<br/>
            nCluster = hits;<br/>
        }<br/>
<br/>
        // Battle Armor MGs do one die of damage per hit to PBI.<br/>
        if ( wtype.getAmmoType() == AmmoType.T_BA_MG &amp;&amp;<br/>
             (target instanceof Infantry) &amp;&amp; !(target instanceof BattleArmor) ) {<br/>
            nDamPerHit = Compute.d6(hits);<br/>
            phaseReport.append( "riddles the target with " ).append( <br/>
                nDamPerHit ).append( sSalvoType ).append( "and " );<br/>
            hits = 1;<br/>
            bSalvo = false;<br/>
        }<br/>
<br/>
        // Report the number of hits.<br/>
        if (bSalvo) {<br/>
            phaseReport.append(hits ).append( sSalvoType ).append( "hit" ).append( toHit.getTableDesc());<br/>
            if (bECMAffected) {<br/>
                phaseReport.append(" (ECM prevents bonus)");<br/>
            }<br/>
            else if (bMekStealthActive) {<br/>
                phaseReport.append(" (active Stealth prevents bonus)");<br/>
            }<br/>
            if (nSalvoBonus &gt; 0) {<br/>
                phaseReport.append(" (w/ +")<br/>
                    .append(nSalvoBonus)<br/>
                    .append(" bonus)");<br/>
            }<br/>
            phaseReport.append(".");<br/>
            <br/>
            if (wr.amsShotDown &gt; 0) {<br/>
                int shotDown = Math.min(wr.amsShotDown, hits);<br/>
                phaseReport.append("\n\tAMS engages, firing ")<br/>
                    .append(wr.amsShotDown).append(" shots, shooting down ")<br/>
                    .append(shotDown).append(" missile(s).");<br/>
                hits -= wr.amsShotDown;<br/>
            }<br/>
        }<br/>
<br/>
        // convert the ATM missile damages to LRM type 5 point cluster damage<br/>
        // done here after AMS has been performed<br/>
        if (wtype.getAmmoType() == AmmoType.T_ATM)<br/>
        {<br/>
            hits = nDamPerHit * hits;<br/>
            nDamPerHit = 1;<br/>
        }<br/>
<br/>
        // Make sure the player knows when his attack causes no damage.<br/>
        if ( hits == 0 ) {<br/>
            phaseReport.append( "attack deals zero damage.\n" );<br/>
        }<br/>
<br/>
        // for each cluster of hits, do a chunk of damage<br/>
        while (hits &gt; 0) {<br/>
            int nDamage;<br/>
<br/>
            // If the attack was with inferno rounds then<br/>
            // do heat and fire instead of damage.<br/>
            if ( bInferno ) {<br/>
                // TODO: remove this block and make infantry invalid<br/>
                //       targets for Infernos in Compute#toHitWeapon()<br/>
                // Infernos cannot attack infantry directly so instead<br/>
                // they attack hits the hex and sets it on fire.<br/>
                if (target instanceof Infantry) {<br/>
                    phaseReport.append("hits!\n");<br/>
                    tryIgniteHex(target.getPosition(), true, 0);<br/>
                    return;<br/>
                }<br/>
<br/>
                // targeting a hex for ignition<br/>
                if(target.getTargetType() == Targetable.TYPE_HEX_IGNITE) {<br/>
                    phaseReport.append( "hits with " )<br/>
                        .append( hits )<br/>
                        .append( " inferno missles.\n" );<br/>
                    tryIgniteHex(target.getPosition(), true, 0);<br/>
                    return;<br/>
                }<br/>
                <br/>
                // Targeting an entity<br/>
                if (entityTarget != null ) {<br/>
                    entityTarget.infernos.add( InfernoTracker.STANDARD_ROUND,<br/>
                                     hits );<br/>
                    if ( !bSalvo ) {<br/>
                        phaseReport.append( "hits with " )<br/>
                            .append( hits )<br/>
                            .append( " inferno missles." );<br/>
                    }<br/>
                    phaseReport.append("\n        " )<br/>
                        .append( target.getDisplayName() )<br/>
                        .append( " now on fire for ")<br/>
                        .append( entityTarget.infernos.getTurnsLeftToBurn() )<br/>
                        .append(" turns.\n");<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    Hex h = game.getBoard().getHex(c);<br/>
<br/>
                    phaseReport.append(" Fire started in hex!\n");<br/>
                    h.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
                    game.board.addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return;<br/>
                }<br/>
            } // End is-inferno<br/>
<br/>
            // targeting a hex for igniting<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_IGNITE) {<br/>
                phaseReport.append("hits!\n");<br/>
                if (bInferno || wtype.getFireTN() != TargetRoll.IMPOSSIBLE) {<br/>
                    tryIgniteHex(target.getPosition(), bInferno, wtype.getFireTN());<br/>
                }<br/>
                return;<br/>
            }<br/>
            <br/>
            // targeting a hex for clearing<br/>
            // is it true that flamers can't clear?<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_CLEAR) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                phaseReport.append("hits!\n");<br/>
                phaseReport.append("    Terrain takes " ).append( nDamage ).append( " damage.\n");<br/>
                <br/>
                // any clear attempt can result in accidental ignition<br/>
                // even weapons that can't normally start fires.  that's weird. . <br/>
                if (tryIgniteHex(target.getPosition(), bInferno, 9)) {<br/>
                    return;<br/>
                }<br/>
                <br/>
                int tn = 14 - nDamage;<br/>
                if(!wtype.hasFlag(WeaponType.F_FLAMER)) {<br/>
                    tryClearHex(target.getPosition(), tn);<br/>
                } <br/>
                <br/>
                return;<br/>
            }<br/>
<br/>
            // Battle Armor squads equipped with fire protection<br/>
            // gear automatically avoid flaming death.<br/>
            if ( wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp; <br/>
                 target instanceof BattleArmor ) {<br/>
                for ( Enumeration iter = entityTarget.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        phaseReport.append( "hits, but " )<br/>
                            .append(target.getDisplayName() )<br/>
                            .append( " is protected from the flamer by its gear.\n" );<br/>
                        return;<br/>
                    }<br/>
                }<br/>
            } // End target-may-be-immune<br/>
<br/>
            // Flamers do heat, not damage.<br/>
            else if (entityTarget != null &amp;&amp; wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp; game.getOptions().booleanOption("flamer_heat")) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                phaseReport.append("\n        Target gains ").append(nDamage).append(" more heat during heat phase.");<br/>
                entityTarget.heatBuildup += nDamage;<br/>
                hits = 0;<br/>
            }<br/>
            else if (entityTarget != null) {<br/>
                HitData hit = entityTarget.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
<br/>
                // If a leg attacks hit a leg that isn't<br/>
                // there, then hit the other leg.<br/>
                if ( wtype.getInternalName().equals("LegAttack") &amp;&amp;<br/>
                     entityTarget.getInternal(hit) &lt;= 0 ) {<br/>
                    if ( hit.getLocation() == Mech.LOC_RLEG ) {<br/>
                        hit = new HitData( Mech.LOC_LLEG );<br/>
                    }<br/>
                    else {<br/>
                        hit = new HitData( Mech.LOC_RLEG );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mine Launchers automatically hit the<br/>
                // CT of a Mech or the front of a Tank.<br/>
                if ( wtype.getInternalName().equals("BAMineLauncher") ) {<br/>
                    if ( target instanceof Mech ) {<br/>
                        hit = new HitData( Mech.LOC_CT );<br/>
                    }<br/>
                    else { // te instanceof Tank<br/>
                        hit = new HitData( Tank.LOC_FRONT );<br/>
                    }<br/>
                }<br/>
<br/>
                // Each hit in the salvo get's its own hit location.<br/>
                if (!bSalvo) {<br/>
                    phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).<br/>
                            append( entityTarget.getLocationAbbr(hit));<br/>
                }<br/>
<br/>
                // Special weapons do criticals instead of damage.<br/>
                if ( nDamPerHit == WeaponType.DAMAGE_SPECIAL ) {<br/>
                    // Do criticals.<br/>
                    String specialDamage = criticalEntity( entityTarget, hit.getLocation() );<br/>
<br/>
                    // Replace "no effect" results with 4 points of damage.<br/>
                    if ( specialDamage.endsWith(" no effect.") ) {<br/>
                        specialDamage = damageEntity(entityTarget, hit, 4);<br/>
                    }<br/>
                    else {<br/>
                        specialDamage = "\n" + specialDamage;<br/>
                    }<br/>
<br/>
                    // Report the result<br/>
                    phaseReport.append( specialDamage );<br/>
                }<br/>
                else {<br/>
                    // Resolve damage normally.<br/>
                    nDamage = nDamPerHit * Math.min(nCluster, hits);<br/>
                    phaseReport.append(damageEntity(entityTarget, hit, nDamage));<br/>
                }<br/>
                hits -= nCluster;<br/>
            }<br/>
        } // Handle the next cluster.<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        roundReport.append("\nPhysical Attack Phase\n-------------------\n");<br/>
        <br/>
        int cen = Entity.NONE;<br/>
        <br/>
        // add any pending charges<br/>
        for (Enumeration i = pendingCharges.elements(); i.hasMoreElements();) {<br/>
            attacks.addElement(i.nextElement());<br/>
        }<br/>
        pendingCharges.removeAllElements();<br/>
        <br/>
        // remove any duplicate attack declarations<br/>
        cleanupPhysicalAttacks();<br/>
        <br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            <br/>
            // verify that the attacker is still active<br/>
            AttackAction aa = (AttackAction)o;<br/>
            if (!(game.getEntity(aa.getEntityId()).isActive())<br/>
            &amp;&amp; !(o instanceof DfaAttackAction)) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            if (o instanceof PunchAttackAction) {<br/>
                PunchAttackAction paa = (PunchAttackAction)o;<br/>
                if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                    // If we're punching while prone (at a Tank,<br/>
                    // duh), then we can only use one arm.<br/>
                    Entity ae = game.getEntity( aa.getEntityId() );<br/>
                    if ( ae.isProne() ) {<br/>
                        // As a sanity check, make certain<br/>
                        // that no arm has been destroyed.<br/>
                        if ( ae.isLocationDestroyed(Mech.LOC_RARM) ) {<br/>
                            phaseReport.append( ae.getDisplayName() ).append<br/>
                                ( " can't punch: right arm destroyed.\n" );<br/>
                            continue;<br/>
                        }<br/>
                        else if ( ae.isLocationDestroyed(Mech.LOC_LARM) ) {<br/>
                            phaseReport.append( ae.getDisplayName() ).append<br/>
                                ( " can't punch: left arm destroyed.\n" );<br/>
                            continue;<br/>
                        }<br/>
<br/>
                        // Find out which arm has the best attack.<br/>
                        paa.setArm(PunchAttackAction.LEFT);<br/>
                        ToHitData left = Compute.toHitPunch( game, paa );<br/>
                        double oddsLeft = Compute.oddsAbove(left.getValue());<br/>
                        int damageLeft = Compute.getPunchDamageFor<br/>
                            ( ae, PunchAttackAction.LEFT );<br/>
                        paa.setArm(PunchAttackAction.RIGHT);<br/>
                        ToHitData right = Compute.toHitPunch( game, paa );<br/>
                        double oddsRight = Compute.oddsAbove(right.getValue());<br/>
                        int damageRight = Compute.getPunchDamageFor<br/>
                            ( ae, PunchAttackAction.RIGHT );<br/>
<br/>
                        // Use the best attack.<br/>
                        if (  oddsLeft*damageLeft &gt; oddsRight*damageRight ) {<br/>
                            // Be sure to set the left arm first.<br/>
                            paa.setArm(PunchAttackAction.LEFT);<br/>
                            resolvePunchAttack(paa, cen);<br/>
                            cen = paa.getEntityId();<br/>
                        } else {<br/>
                            // We've already set the right arm.<br/>
                            resolvePunchAttack(paa, cen);<br/>
                            cen = paa.getEntityId();<br/>
                        }<br/>
                    } // End Entity-is-prone<br/>
                    else {<br/>
                        paa.setArm(PunchAttackAction.LEFT);<br/>
                        resolvePunchAttack(paa, cen);<br/>
                        cen = paa.getEntityId();<br/>
                        paa.setArm(PunchAttackAction.RIGHT);<br/>
                        resolvePunchAttack(paa, cen);<br/>
                    }<br/>
                } else {<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof KickAttackAction) {<br/>
                KickAttackAction kaa = (KickAttackAction)o;<br/>
                resolveKickAttack(kaa, cen);<br/>
                cen = kaa.getEntityId();<br/>
            } else if (o instanceof BrushOffAttackAction) {<br/>
                BrushOffAttackAction baa = (BrushOffAttackAction)o;<br/>
                if (baa.getArm() == BrushOffAttackAction.BOTH) {<br/>
                    baa.setArm(BrushOffAttackAction.LEFT);<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                    cen = baa.getEntityId();<br/>
                    baa.setArm(BrushOffAttackAction.RIGHT);<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                } else {<br/>
                    resolveBrushOffAttack(baa, cen);<br/>
                    cen = baa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof ThrashAttackAction) {<br/>
                ThrashAttackAction taa = (ThrashAttackAction)o;<br/>
                resolveThrashAttack(taa, cen);<br/>
                cen = taa.getEntityId();<br/>
            } else if (o instanceof ClubAttackAction) {<br/>
                ClubAttackAction caa = (ClubAttackAction)o;<br/>
                resolveClubAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            } else if (o instanceof PushAttackAction) {<br/>
                PushAttackAction paa = (PushAttackAction)o;<br/>
                resolvePushAttack(paa, cen);<br/>
                cen = paa.getEntityId();<br/>
            }  else if (o instanceof ChargeAttackAction) {<br/>
                ChargeAttackAction caa = (ChargeAttackAction)o;<br/>
                resolveChargeAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            }  else if (o instanceof DfaAttackAction) {<br/>
                DfaAttackAction daa = (DfaAttackAction)o;<br/>
                resolveDfaAttack(daa, cen);<br/>
                cen = daa.getEntityId();<br/>
            } else {<br/>
                // hmm, error.<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Cleans up the attack declarations for the physical phase by removing<br/>
     * all attacks past the first for any one mech.  Also clears out attacks<br/>
     * by dead or disabled mechs.<br/>
     */<br/>
    private void cleanupPhysicalAttacks() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            removeDuplicateAttacks(entity.getId());<br/>
        }<br/>
        removeDeadAttacks();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes any actions in the attack queue beyond the first by the<br/>
     * specified entity.<br/>
     */<br/>
    private void removeDuplicateAttacks(int entityId) {<br/>
        boolean attacked = false;<br/>
        Vector toKeep = new Vector(attacks.size());<br/>
        <br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            if (action.getEntityId() != entityId) {<br/>
                toKeep.addElement(action);<br/>
            } else if (!attacked) {<br/>
                toKeep.addElement(action);<br/>
                attacked = true;<br/>
            } else {<br/>
                System.err.println("server: removing duplicate phys attack for id#" + entityId);<br/>
            }<br/>
        }<br/>
        <br/>
        attacks = toKeep;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes all attacks by any dead entities.  It does this by going through<br/>
     * all the attacks and only keeping ones from active entities.  DFAs are<br/>
     * kept even if the pilot is unconcious, so that he can fail.<br/>
     */<br/>
    private void removeDeadAttacks() {<br/>
        Vector toKeep = new Vector(attacks.size());<br/>
        <br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(action.getEntityId());<br/>
            if (entity != null &amp;&amp; !entity.isDestroyed()<br/>
            &amp;&amp; (entity.isActive() || action instanceof DfaAttackAction)) {<br/>
                toKeep.addElement(action);<br/>
            }<br/>
        }<br/>
        <br/>
        attacks = toKeep;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PunchAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? "Left Arm" : "Right Arm";<br/>
        <br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Punch (" +armName ).append( ") at " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPunch(game, paa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the punch is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getPunchDamageFor(ae, paa.getArm());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(KickAttackAction kaa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Entity te = game.getEntity(kaa.getTargetId());<br/>
        final String legName = kaa.getLeg() == KickAttackAction.LEFT<br/>
        ? "Left Leg"<br/>
        : "Right Leg";<br/>
        <br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Kick (" ).append( legName ).append( ") at " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitKick(game, kaa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the kick is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        <br/>
        int damage = Compute.getKickDamageFor(ae, kaa.getLeg());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        if (te.getMovementType() == Entity.MovementType.BIPED || te.getMovementType() == Entity.MovementType.QUAD) {<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was kicked"));<br/>
        }<br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a brush off attack<br/>
     */<br/>
    private void resolveBrushOffAttack( BrushOffAttackAction baa,<br/>
                                        int lastEntityId ) {<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        final Entity te = game.getEntity(baa.getTargetId());<br/>
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT<br/>
            ? "Left Arm" : "Right Arm";<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            phaseReport.append( "\nPhysical attacks for " )<br/>
                .append( ae.getDisplayName() )<br/>
                .append( "\n" );<br/>
        }<br/>
<br/>
        phaseReport.append("    Brush Off " )<br/>
            .append( te.getDisplayName() )<br/>
            .append( " with " )<br/>
            .append( armName );<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitBrushOff(game, baa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append( ", but the brush off is impossible (" )<br/>
                .append( toHit.getDesc() )<br/>
                .append( ")\n" );<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs ").append(toHit.getValue()).append(", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls ").append(roll).append(" : ");<br/>
<br/>
        int damage = Compute.getBrushOffDamageFor(ae, baa.getArm());<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
<br/>
            // Missed Brush Off attacks cause punch damage to the attacker.<br/>
            toHit.setHitTable( ToHitData.HIT_PUNCH );<br/>
            toHit.setSideTable( ToHitData.SIDE_FRONT );<br/>
            HitData hit = ae.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            phaseReport.append( ae.getDisplayName() )<br/>
                .append( " punches itself in the " )<br/>
                .append( ae.getLocationAbbr(hit) )<br/>
                .append( damageEntity(ae, hit, damage) )<br/>
                .append("\n");<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                          toHit.getSideTable() );<br/>
        phaseReport.append("hits")<br/>
            .append( toHit.getTableDesc() )<br/>
            .append( " " )<br/>
            .append( te.getLocationAbbr(hit) );<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        phaseReport.append("\n");<br/>
<br/>
        // Dislodge the swarming infantry.<br/>
        ae.setSwarmAttackerId( Entity.NONE );<br/>
        te.setSwarmTargetId( Entity.NONE );<br/>
        phaseReport.append( te.getDisplayName() )<br/>
            .append( " is dislodged.\n" );<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a thrash attack<br/>
     */<br/>
    private void resolveThrashAttack( ThrashAttackAction baa,<br/>
                                        int lastEntityId ) {<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        final Entity te = game.getEntity(baa.getTargetId());<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            phaseReport.append( "\nPhysical attacks for " )<br/>
                .append( ae.getDisplayName() )<br/>
                .append( "\n" );<br/>
        }<br/>
<br/>
        phaseReport.append("    Thrash at " )<br/>
            .append( te.getDisplayName() );<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitThrash(game, baa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append( ", but the thrash is impossible (" )<br/>
                .append( toHit.getDesc() )<br/>
                .append( ")\n" );<br/>
            return;<br/>
        }<br/>
<br/>
        // Thrash attack may hit automatically<br/>
        if ( toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS ) {<br/>
            phaseReport.append( "; hits automatically," );<br/>
        } else {<br/>
            phaseReport.append( "; needs " )<br/>
                .append( toHit.getValue() )<br/>
                .append( ", " );<br/>
<br/>
            // roll<br/>
            int roll = Compute.d6(2);<br/>
            phaseReport.append("rolls ").append(roll).append(" : ");<br/>
<br/>
            // do we hit?<br/>
            if (roll &lt; toHit.getValue()) {<br/>
                phaseReport.append("misses.\n");<br/>
                return;<br/>
            }<br/>
            phaseReport.append( ", hits" );<br/>
        }<br/>
<br/>
        // Standard damage loop in 5 point clusters.<br/>
        int hits = Compute.getThrashDamageFor(ae);<br/>
        phaseReport.append( " and deals " )<br/>
            .append( hits )<br/>
            .append( " points of damage in 5 point clusters.");<br/>
        while ( hits &gt; 0 ) {<br/>
            int damage = Math.min(5, hits);<br/>
            hits -= damage;<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            phaseReport.append("\nHits ").append( te.getLocationAbbr(hit) );<br/>
            phaseReport.append(damageEntity(te, hit, damage));<br/>
        }<br/>
        phaseReport.append("\n");<br/>
<br/>
        // Thrash attacks cause PSRs.  Failed PSRs cause falling damage.<br/>
        // This fall damage applies even though the Thrashing Mek is prone.<br/>
        PilotingRollData roll = Compute.getBasePilotingRoll(game, ae.getId());<br/>
        roll.addModifier( 0, "thrashing at infantry" );<br/>
        phaseReport.append( ae.getDisplayName() )<br/>
            .append( " must make a piloting skill check (" )<br/>
            .append( "thrashing at infantry).\n");<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " )<br/>
            .append( roll.getValueAsString() )<br/>
            .append( " [" )<br/>
            .append( roll.getDesc() )<br/>
            .append( "]" )<br/>
            .append( ", rolls " )<br/>
            .append( diceRoll )<br/>
            .append( " : " );<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("fails.\n");<br/>
            doEntityFall( ae, roll );<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a club attack<br/>
     */<br/>
    private void resolveClubAttack(ClubAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // restore club attack<br/>
        caa.getClub().restore();<br/>
        <br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    " ).append( caa.getClub().getName() ).append( " attack on " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitClub(game, caa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the attack is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getClubDamageFor(ae, caa.getClub());<br/>
        <br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" ).append( toHit.getTableDesc() ).append( " " ).append( te.getLocationAbbr(hit));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
        <br/>
        phaseReport.append("\n");<br/>
        <br/>
        if (caa.getClub().getType().hasFlag(MiscType.F_TREE_CLUB)) {<br/>
            phaseReport.append("The " ).append( caa.getClub().getName() ).append( " breaks.\n");<br/>
            ae.removeMisc(caa.getClub().getName());<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PushAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        <br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        phaseReport.append("    Pushing " ).append( te.getDisplayName());<br/>
        <br/>
//        // should we even bother?<br/>
//        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
//            phaseReport.append(" but the target is already destroyed!\n");<br/>
//            return;<br/>
//        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPush(game, paa);<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            phaseReport.append(", but the push is impossible (" ).append( toHit.getDesc() ).append( ")\n");<br/>
            return;<br/>
        }<br/>
        phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
        <br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
        <br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
        <br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            phaseReport.append("succeeds: target is pushed into hex "<br/>
            ).append( dest.getBoardNum()<br/>
            ).append( "\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
            <br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (!te.getPosition().equals(src)) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest)) {<br/>
                game.removeEntity(te.getId(),<br/>
                                  Game.UNIT_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(te.getId(),<br/>
                                              Game.UNIT_IN_RETREAT));<br/>
                phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " has been forced from the field. ***\n");<br/>
                ae.setPosition(src);<br/>
            } else {<br/>
                phaseReport.append("succeeds, but target can't be moved.\n");<br/>
                pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
            }<br/>
        }<br/>
        <br/>
        <br/>
        phaseReport.append("\n");<br/>
    }<br/>
    <br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(ChargeAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
        <br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append("    Charge cancelled as the target has been destroyed.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // attacker fell down?<br/>
        if (ae.isProne()) {<br/>
            phaseReport.append("    Charge cancelled as the attacker has fallen.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // attacker immobile?<br/>
        if (ae.isImmobile()) {<br/>
            phaseReport.append("    Charge cancelled as the attacker has been immobilized.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        phaseReport.append("    Charging " ).append( te.getDisplayName());<br/>
        <br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(caa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitCharge(game, caa);<br/>
        <br/>
        // if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            phaseReport.append(", but the charge is impossible (" ).append( toHit.getDesc() ).append( ") : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
            phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Resolve the damage.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    resolveChargeDamage( ae, te, toHit, direction );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge's damage<br/>
     */<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getChargeDamageFor(ae);<br/>
        int damageTaken = Compute.getChargeDamageTakenBy(ae, te);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PilotingRollData chargePSR = null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// If we're upright, we may fall down.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( !ae.isProne() ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    chargePSR = new PilotingRollData(ae.getId(), 2, "charging");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        <br/>
        phaseReport.append("hits.");<br/>
        phaseReport.append("\n  Defender takes " ).append( damage ).append( " damage" ).append( toHit.getTableDesc() ).append( ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " ).append( damageTaken ).append( " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            phaseReport.append("\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
        } else {<br/>
            if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest)) {<br/>
                game.removeEntity(te.getId(),<br/>
                                  Game.UNIT_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(te.getId(),<br/>
                                              Game.UNIT_IN_RETREAT));<br/>
                phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " target has been forced from the field. ***\n");<br/>
                doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
            } else {<br/>
                // they stil have to roll<br/>
                pilotRolls.addElement(new PilotingRollData(te.getId(), 2, "was charged"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pilotRolls.addElement(chargePSR);<br/>
            }<br/>
        }<br/>
        <br/>
        phaseReport.append("\n");<br/>
<br/>
    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )<br/>
    <br/>
    /**<br/>
     * Handle a death from above attack<br/>
     */<br/>
    private void resolveDfaAttack(DfaAttackAction daa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Entity te = game.getEntity(daa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
        <br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " ).append( ae.getDisplayName() ).append( "\n");<br/>
        }<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
        <br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append("    Death from above deals no damage as the target has been destroyed.\n");<br/>
            if (ae.isProne()) {<br/>
                // attacker prone during weapons phase<br/>
                doEntityFall(ae, daa.getTargetPos(), 2, 3, Compute.getBasePilotingRoll(game, ae.getId()));<br/>
            } else {<br/>
                // same effect as successful DFA<br/>
                doEntityDisplacement(ae, ae.getPosition(), daa.getTargetPos(), new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
            }<br/>
            return;<br/>
        }<br/>
        <br/>
        phaseReport.append("    Attempting death from above on " ).append( te.getDisplayName());<br/>
        <br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(daa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitDfa(game, daa);<br/>
        <br/>
        // hack: if the attacker's prone, or incapacitated, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne() || !ae.isActive()) {<br/>
            roll = -12;<br/>
            phaseReport.append(" but the attacker is prone or incapacitated : ");<br/>
        } else if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            phaseReport.append(" but the attack is impossible (" ).append( toHit.getDesc() ).append( ") : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " ).append( toHit.getValue() ).append( ", ");<br/>
            phaseReport.append("rolls " ).append( roll ).append( " : ");<br/>
        }<br/>
        <br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            if (targetDest != null) {<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, dest, targetDest, null);<br/>
                // attacker falls into destination hex<br/>
                phaseReport.append(ae.getDisplayName() ).append( " falls into hex " ).append( dest.getBoardNum() ).append( ".\n");<br/>
                doEntityFall(ae, dest, 2, 3, Compute.getBasePilotingRoll(game, ae.getId()));<br/>
            } else {<br/>
                // attacker destroyed<br/>
                phaseReport.append(destroyEntity(ae, "impossible displacement", false));<br/>
            }<br/>
            return;<br/>
        }<br/>
        <br/>
        // we hit...<br/>
        int damage = Compute.getDfaDamageFor(ae);<br/>
        int damageTaken = Compute.getDfaDamageTakenBy(ae);<br/>
        <br/>
        phaseReport.append("hits.");<br/>
        <br/>
        phaseReport.append("\n  Defender takes " ).append( damage ).append( " damage" ).append( toHit.getTableDesc() ).append( ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " ).append( damageTaken ).append( " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        phaseReport.append("\n");<br/>
        <br/>
        // defender pushed away or destroyed<br/>
        Coords src = ae.getPosition();<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (game.getOptions().booleanOption("push_off_board") &amp;&amp; !game.board.contains(dest.translated(direction))) {<br/>
            game.removeEntity(te.getId(),<br/>
                              Game.UNIT_IN_RETREAT);<br/>
            send(createRemoveEntityPacket(te.getId(),<br/>
                                          Game.UNIT_IN_RETREAT));<br/>
            phaseReport.append("\n*** " ).append( te.getDisplayName() ).append( " target has been forced from the field. ***\n");<br/>
        } else {<br/>
            if (targetDest != null) {<br/>
                doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
            } else {<br/>
                // ack!  automatic death!<br/>
                phaseReport.append(destroyEntity(te, "impossible displacement", false));<br/>
            }<br/>
        }<br/>
        // HACK: to avoid automatic falls, displace from dest to dest<br/>
        doEntityDisplacement(ae, dest, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        roundReport.append("\nHeat Phase\n----------\n");<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            Hex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
            <br/>
            // heat doesn't matter for non-mechs<br/>
            if (!(entity instanceof Mech)) {<br/>
                entity.heatBuildup = 0;<br/>
<br/>
                // If the unit is hit with an Inferno, do flaming death test.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
                continue;<br/>
            }<br/>
            else {<br/>
                // Meks gain heat from inferno hits.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    int infernoHeat = entity.infernos.getHeat();<br/>
                    entity.heatBuildup += infernoHeat;<br/>
                    roundReport.append( "Added " )<br/>
                        .append( infernoHeat )<br/>
                        .append( " from a burning inferno round...\n" );<br/>
                }<br/>
            }<br/>
<br/>
            // should we even bother?<br/>
            if ( entity.isDestroyed() || entity.isDoomed() ||<br/>
                 entity.crew.isDead() ) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            if (!entity.isShutDown()) {<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
            }<br/>
<br/>
            // If a Mek had an active Stealth suite, add 10 heat.<br/>
            if ( entity instanceof Mech &amp;&amp; entity.isStealthActive() ) {<br/>
                entity.heatBuildup += 10;<br/>
                roundReport.append("Added 10 heat from Stealth Armor...\n");<br/>
            }<br/>
<br/>
            // Add +5 Heat if the hex you're in is on fire<br/>
            // and was on fire for the full round.<br/>
            if (entityHex.levelOf(Terrain.FIRE) == 2) {<br/>
                entity.heatBuildup += 5;<br/>
                roundReport.append("Added 5 heat from a fire...\n");<br/>
            }<br/>
            <br/>
            // add the heat we've built up so far.<br/>
            roundReport.append( entity.getDisplayName() )<br/>
                .append( " gains " )<br/>
                .append( entity.heatBuildup )<br/>
                .append( " heat,");<br/>
            entity.heat += entity.heatBuildup;<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = Math.min( entity.getHeatCapacityWithWater(),<br/>
                                   entity.heat );<br/>
            <br/>
            entity.heat -= tosink;<br/>
            roundReport.append( " sinks " )<br/>
                .append( tosink )<br/>
                .append( " heat and is now at " )<br/>
                .append( entity.heat )<br/>
                .append( " heat.\n");<br/>
<br/>
            // Does the unit have inferno ammo?<br/>
            if( entity.hasInfernoAmmo() ) {<br/>
<br/>
                // Apply the inferno ammo explosion.<br/>
                if (entity.heat &gt;= 10) {<br/>
                    int boom = 4 + (entity.heat &gt;= 14 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 19 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 23 ? 2 : 0) + <br/>
                        (entity.heat &gt;= 28 ? 2 : 0);<br/>
                    int boomroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( boom )<br/>
                        .append( "+ to avoid inferno ammo explosion, rolls " )<br/>
                        .append( boomroll )<br/>
                        .append( " : " );<br/>
                    if (boomroll &gt;= boom) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails to avoid explosion.\n");<br/>
                        roundReport.append(explodeInfernoAmmoFromHeat(entity));<br/>
                    }<br/>
                }<br/>
            } // End avoid-inferno-explosion<br/>
<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; 30 &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    entity.setShutDown(false);<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " automatically starts up.\n" );<br/>
                } else {<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int suroll = Compute.d6(2);<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( startup )<br/>
                        .append( "+ to start up, rolls " )<br/>
                        .append( suroll )<br/>
                        .append( " : " );<br/>
                    if (suroll &gt;= startup) {<br/>
                        entity.setShutDown(false);<br/>
                        roundReport.append("successful!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails.\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            // 2003-01-26 JAD - Don't shut down if you just restarted.<br/>
            else if (entity.heat &gt;= 14 &amp;&amp; !entity.isShutDown()) {<br/>
                if (entity.heat &gt;= 30) {<br/>
                    roundReport.append( entity.getDisplayName() )<br/>
                        .append( " automatically shuts down.\n" );<br/>
                    // add a piloting roll and resolve immediately<br/>
                    pilotRolls.addElement(new PilotingRollData<br/>
                        ( entity.getId(), 3, "reactor shutdown" ));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int sdroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( shutdown )<br/>
                        .append( "+ to avoid shutdown, rolls " )<br/>
                        .append( sdroll )<br/>
                        .append( " : ");<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("shuts down.\n");<br/>
                        // add a piloting roll and resolve immediately<br/>
                        pilotRolls.addElement(new PilotingRollData<br/>
                            ( entity.getId(), 3, "reactor shutdown" ));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                    (entity.heat &gt;= 28 ? 2 : 0);<br/>
                int boomroll = Compute.d6(2);<br/>
                roundReport.append( entity.getDisplayName() )<br/>
                        .append( " needs a " )<br/>
                        .append( boom )<br/>
                        .append( "+ to avoid ammo explosion, rolls " )<br/>
                        .append( boomroll )<br/>
                        .append( " : ");<br/>
                if (boomroll &gt;= boom) {<br/>
                    roundReport.append("avoids successfully!\n");<br/>
                } else {<br/>
                    roundReport.append("fails to avoid explosion.\n");<br/>
                    roundReport.append(explodeAmmoFromHeat(entity));<br/>
                }<br/>
            }<br/>
            <br/>
            // heat effects: mechwarrior damage<br/>
            if (entity.getHitCriticals( CriticalSlot.TYPE_SYSTEM,<br/>
                                        Mech.SYSTEM_LIFE_SUPPORT,<br/>
                                        Mech.LOC_HEAD ) &gt; 0<br/>
                &amp;&amp; entity.heat &gt;= 15) {<br/>
                if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    roundReport.append(entity.getDisplayName() ).append( " has 25 or higher heat and damaged life support.  Mechwarrior takes 2 damage.\n");<br/>
                    damageCrew(entity, 2);<br/>
                } else {<br/>
                    // mechwarrior takes 1 damage<br/>
                    roundReport.append(entity.getDisplayName() ).append( " has 15 or higher heat and damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                    damageCrew(entity, 1);<br/>
                }<br/>
                // The pilot may have just expired.<br/>
                if ( entity.crew.isDead() ) {<br/>
                    roundReport.append( "*** " )<br/>
                        .append( entity.getDisplayName() )<br/>
                        .append( " PILOT BAKES TO DEATH! ***" );<br/>
                }<br/>
            }<br/>
<br/>
        }<br/>
    }<br/>
    <br/>
    private void doFlamingDeath(Entity entity) {<br/>
        int boomroll = Compute.d6(2);<br/>
        // Infantry are unaffected by fire while they're still swarming.<br/>
        if ( Entity.NONE != entity.getSwarmTargetId() ) {<br/>
            return;<br/>
        }<br/>
        // Battle Armor squads equipped with fire protection<br/>
        // gear automatically avoid flaming death.<br/>
        for ( Enumeration iter = entity.getMisc(); iter.hasMoreElements(); ) {<br/>
            Mounted mount = (Mounted) iter.nextElement();<br/>
            EquipmentType equip = mount.getType();<br/>
            if ( BattleArmor.ASSAULT_CLAW.equals(equip.getInternalName()) ) {<br/>
                phaseReport.append(entity.getDisplayName() )<br/>
                    .append( " is on fire, but is protected by its gear.\n" );<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        phaseReport.append( entity.getDisplayName() )<br/>
            .append( " is on fire.  Needs an 8+ to avoid destruction, rolls " )<br/>
            .append( boomroll )<br/>
            .append( " : ");<br/>
        if (boomroll &gt;= 8) {<br/>
            phaseReport.append("avoids successfully!\n");<br/>
        } else {<br/>
            phaseReport.append("fails to avoid horrible instant flaming death.\n");<br/>
            phaseReport.append(destroyEntity(entity, "fire"));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a piloting<br/>
     * skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.getMovementType() == Entity.MovementType.BIPED ||<br/>
            entity.getMovementType() == Entity.MovementType.QUAD) {<br/>
                // if this mech has 20+ damage, add another roll to the list.<br/>
                if (entity.damageThisPhase &gt;= 20) {<br/>
                    pilotRolls.addElement(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any non-mech units are standing in fire.  Called at the<br/>
     * end of the movement phase<br/>
     */<br/>
    public void checkForFlamingDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity instanceof Mech ||<br/>
                 entity.isDoomed() ||<br/>
                 entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if (curHex.contains(Terrain.FIRE)) {<br/>
                doFlamingDeath(entity);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if ((curHex.levelOf(Terrain.WATER) &gt; 1<br/>
            || (curHex.levelOf(Terrain.WATER) == 1 &amp;&amp; entity.isProne()))<br/>
            &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                roundReport.append("\n" ).append( entity.getDisplayName() ).append( " is underwater with damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * (used at end of weapons, physical phases)<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (!(entity instanceof Mech) || entity.isProne() || entity.isDoomed() || entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            int rolls = 0;<br/>
            StringBuffer reasons = new StringBuffer();<br/>
            PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
            for (Enumeration j = pilotRolls.elements(); j.hasMoreElements();) {<br/>
                final PilotingRollData modifier = (PilotingRollData)j.nextElement();<br/>
                if (modifier.getEntityId() == entity.getId()) {<br/>
                    rolls++;<br/>
                    if (reasons.length() &gt; 0) {<br/>
                        reasons.append(", ");<br/>
                    }<br/>
                    reasons.append(modifier.getPlainDesc());<br/>
                    roll.append(modifier);<br/>
                }<br/>
            }<br/>
            // any rolls needed?<br/>
            if (rolls == 0) {<br/>
                continue;<br/>
            }<br/>
            if (roll.getValue() == PilotingRollData.AUTOMATIC_FAIL || roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " must make " ).append( rolls ).append( " piloting skill roll(s) and automatically fails (" ).append( roll.getDesc() ).append( ").\n");<br/>
                doEntityFall(entity, roll);<br/>
            } else {<br/>
                phaseReport.append("\n" ).append( entity.getDisplayName() ).append( " must make " ).append( rolls ).append( " piloting skill roll(s) (" ).append( reasons.toString() ).append( ").\n");<br/>
                phaseReport.append("The target is " ).append( roll.getValueAsString() ).append( " [" ).append( roll.getDesc() ).append( "].\n");<br/>
                for (int j = 0; j &lt; rolls; j++) {<br/>
                    final int diceRoll = Compute.d6(2);<br/>
                    phaseReport.append("    " ).append( entity.getDisplayName() ).append( " needs " ).append( roll.getValueAsString() ).append( ", rolls " ).append( diceRoll ).append( " : ");<br/>
                    phaseReport.append((diceRoll &gt;= roll.getValue() ? "remains standing" : "falls") ).append( ".\n");<br/>
                    if (diceRoll &lt; roll.getValue()) {<br/>
                        doEntityFall(entity, roll);<br/>
                        // break rolling loop<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        pilotRolls.removeAllElements();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     */<br/>
    private String damageCrew(Entity en, int damage) {<br/>
        String s = new String();<br/>
        <br/>
        if (!en.crew.isDead()) {<br/>
            en.crew.setHits(en.crew.getHits() + damage);<br/>
            s += "        Pilot of " + en.getDisplayName() + " \"" + en.crew.getName() + "\" takes " + damage + " damage.";<br/>
            if (en.crew.getHits() &lt; 6) {<br/>
                en.crew.setRollsNeeded(en.crew.getRollsNeeded() + damage);<br/>
            } else {<br/>
                en.crew.setDead(true);<br/>
                en.crew.setRollsNeeded(0);<br/>
                s += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
            }<br/>
        }<br/>
        <br/>
        return s;<br/>
    }<br/>
    <br/>
    /**<br/>
     * This checks if the mech pilot goes unconcious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    final int totalHits = e.getCrew().getHits();<br/>
            final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
            e.crew.setRollsNeeded(0);<br/>
            <br/>
            if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            for (int hit = totalHits - rollsNeeded + 1; hit &lt;= totalHits; hit++) {<br/>
                int roll = Compute.d6(2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rollTarget = Compute.getConciousnessNumber( hit );<br/>
                phaseReport.append("\nPilot of " ).append( e.getDisplayName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " \"" ).append( e.getCrew().getName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( "\" needs a " ).append( rollTarget<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " to stay concious.  Rolls " ).append( roll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ).append( " : ");<br/>
                if (roll &gt;= rollTarget) {<br/>
                    phaseReport.append("successful!");<br/>
                } else {<br/>
                    e.crew.setUnconcious(true);<br/>
                    e.crew.setKoThisRound(true);<br/>
                    phaseReport.append("blacks out.");<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            phaseReport.append("\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Make the rolls indicating whether any unconcious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            <br/>
            // only unconscious pilots of mechs can roll to wake up<br/>
            if (!e.isTargetable() || !e.crew.isUnconcious() ||<br/>
            e.crew.isKoThisRound() || !(e instanceof Mech)) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            int roll = Compute.d6(2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    int rollTarget = Compute.getConciousnessNumber( e.crew.getHits() );<br/>
            roundReport.append("\nPilot of " ).append( e.getDisplayName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " \"" ).append( e.crew.getName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( "\" needs a " ).append( rollTarget<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " to regain conciousness.  Rolls " ).append( roll<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ).append( " : ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (roll &gt;= rollTarget) {<br/>
                roundReport.append("successful!");<br/>
                e.crew.setUnconcious(false);<br/>
            } else {<br/>
                roundReport.append("fails.");<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            roundReport.append("\n");<br/>
        }<br/>
    }<br/>
    <br/>
    public String damageEntity(Entity te, HitData hit, int damage) {<br/>
        return damageEntity(te, hit, damage, false);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals the listed damage to a mech.  Returns a description<br/>
     * string for the log.<br/>
     *<br/>
     * Currently mech only.<br/>
     *<br/>
     * @param te the target entity<br/>
     * @param hit the hit data for the location hit<br/>
     * @param damage the damage to apply<br/>
     * @param ammoExplosion ammo explosion type damage is handled slightly differently<br/>
     */<br/>
    private String damageEntity(Entity te, HitData hit, int damage, boolean ammoExplosion) {<br/>
        String desc = new String();<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;boolean isBattleArmor = (te instanceof BattleArmor);<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;boolean isPlatoon = !isBattleArmor &amp;&amp; (te instanceof Infantry);<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;Hex te_hex = null;<br/>
        <br/>
        int crits = hit.getEffect() == HitData.EFFECT_CRITICAL ? 1 : 0;<br/>
        //int loc = hit.getLocation();<br/>
        HitData nextHit = null;<br/>
<br/>
        // Is the infantry in the open?<br/>
        // TODO : do infantry take double damage in Swamp or Smoke<br/>
        if ( isPlatoon &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed() ) {<br/>
            te_hex = game.board.getHex( te.getPosition() );<br/>
            if ( te_hex != null &amp;&amp;<br/>
                 !te_hex.contains( Terrain.WOODS ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.ROUGH ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.RUBBLE ) &amp;&amp;<br/>
                 !te_hex.contains( Terrain.BUILDING ) ) {<br/>
                // PBI.  Damage is doubled.<br/>
                damage = damage * 2;<br/>
                desc += "\n        Infantry platoon caught in the open!!!  Damage doubled." ;<br/>
            }<br/>
        }<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;// Allocate the damage<br/>
        while (damage &gt; 0) {<br/>
            // let's resolve some damage!<br/>
            desc += "\n        " + te.getDisplayName() + " takes " + damage + " damage to " + te.getLocationAbbr(hit) + ".";<br/>
            <br/>
            // was the section destroyed earlier this phase?<br/>
            if (te.getInternal(hit) == Entity.ARMOR_DOOMED) {<br/>
                // cannot transfer a through armor crit if so<br/>
                crits = 0;<br/>
            }<br/>
<br/>
            // Does an exterior passenger absorb some of the damage?<br/>
            int nLoc = hit.getLocation();<br/>
            Entity passenger = te.getExteriorUnitAt( nLoc, hit.isRear() );<br/>
            if ( !ammoExplosion &amp;&amp;<br/>
                 null != passenger &amp;&amp; !passenger.isDoomed() ) {<br/>
<br/>
                // Yup.  Roll up some hit data for that passenger.<br/>
                desc += "\n            The passenger, " +<br/>
                    passenger.getDisplayName() + ", gets in the way.";<br/>
                HitData passHit = passenger.rollHitLocation<br/>
                    ( ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
<br/>
                // How much damage will the passenger absorb?<br/>
                int absorb = 0;<br/>
                HitData nextPassHit = passHit;<br/>
                do {<br/>
                    if ( 0 &lt; passenger.getArmor( nextPassHit ) ) {<br/>
                        absorb += passenger.getArmor( nextPassHit );<br/>
                    }<br/>
                    absorb += passenger.getInternal( nextPassHit );<br/>
                    nextPassHit = passenger.getTransferLocation( nextPassHit );<br/>
                } while ( damage &gt; absorb &amp;&amp; nextPassHit.getLocation() &gt;= 0 );<br/>
<br/>
                // Damage the passenger.<br/>
                desc += damageEntity( passenger, passHit, damage );<br/>
<br/>
                // Did some damage pass on?<br/>
                if ( damage &gt; absorb ) {<br/>
                    // Yup.  Remove the absorbed damage.<br/>
                    damage -= absorb;<br/>
                    desc += "\n    " + damage +<br/>
                        " damage point(s) passes on to " +<br/>
                        te.getDisplayName() + ".";<br/>
                } else {<br/>
                    // Nope.  Return our description.<br/>
                    return desc;<br/>
                }<br/>
<br/>
            } // End nLoc-has-exterior-passenger<br/>
<br/>
            // is this a mech dumping ammo being hit in the rear torso?<br/>
            boolean bTorso = (nLoc == Mech.LOC_CT || nLoc == Mech.LOC_RT || nLoc == Mech.LOC_LT);<br/>
            if (te instanceof Mech &amp;&amp; hit.isRear() &amp;&amp; bTorso) {<br/>
                for (Enumeration e = te.getAmmo(); e.hasMoreElements(); ) {<br/>
                    Mounted mAmmo = (Mounted)e.nextElement();<br/>
                    if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed() &amp;&amp; !mAmmo.isHit()) {<br/>
                        // doh.  explode it<br/>
                        desc += explodeEquipment(te, mAmmo.getLocation(), mAmmo);<br/>
                        mAmmo.setHit(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            // is there armor in the location hit?<br/>
            if (!ammoExplosion &amp;&amp; te.getArmor(hit) &gt; 0) {<br/>
                if (te.getArmor(hit) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(hit) - damage, hit);<br/>
                    te.damageThisPhase += damage;<br/>
                    damage = 0;<br/>
                    desc += " " + te.getArmor(hit) + " Armor remaining";<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    int absorbed = Math.max(te.getArmor(hit), 0);<br/>
                    te.setArmor(Entity.ARMOR_DESTROYED, hit);<br/>
                    te.damageThisPhase += absorbed;<br/>
                    damage -= absorbed;<br/>
                    desc += " Armor destroyed,";<br/>
                }<br/>
            }<br/>
            <br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(hit) &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Triggers a critical hit on Vehicles and Mechs.<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( !isPlatoon &amp;&amp; !isBattleArmor ) {<br/>
                    crits++;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                    if (te.getInternal(hit) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(hit) - damage, hit);<br/>
                        te.damageThisPhase += damage;<br/>
                        damage = 0;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry platoons have men not "Internals".<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( isPlatoon ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " " + te.getInternal(hit) + " men alive.";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
                        desc += " " + te.getInternal(hit) + " Internal Structure remaining";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        int absorbed = Math.max(te.getInternal(hit), 0);<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        te.damageThisPhase += absorbed;<br/>
                        damage -= absorbed;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Infantry have only one section.<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( isPlatoon ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " &lt;&lt;&lt;PLATOON KILLED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ( isBattleArmor ) {<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += " &lt;&lt;&lt;TROOPER KILLED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
                        desc += " &lt;&lt;&lt;SECTION DESTROYED&gt;&gt;&gt;,";<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        if (hit.getLocation() == Mech.LOC_RT || hit.getLocation() == Mech.LOC_LT) {<br/>
                            int numEngineHits = 0;<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                            numEngineHits += te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                            if (numEngineHits &gt; 2) {<br/>
                                // third engine hit<br/>
                                phaseReport.append(destroyEntity(te, "engine destruction"));<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
                <br/>
                // is the internal structure gone?  what are the transfer potentials?<br/>
                if (te.getInternal(hit) &lt;= 0) {<br/>
                    nextHit = te.getTransferLocation(hit);<br/>
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {<br/>
                        // Entity destroyed.  Ammo explosions are<br/>
                        // neither survivable nor salvagable.<br/>
                        desc += destroyEntity(te, "damage", !ammoExplosion,<br/>
                                              !ammoExplosion);<br/>
                        // nowhere for further damage to go<br/>
                        damage = 0;<br/>
                    } else if ( nextHit.getLocation() == Entity.LOC_NONE ) {<br/>
                        // Rest of the damage is wasted.<br/>
                        damage = 0;<br/>
                    } else if (ammoExplosion &amp;&amp; te.locationHasCase(hit.getLocation())) {<br/>
                        // remaining damage prevented<br/>
                        desc += " remaining " + damage + " damage prevented by CASE.";<br/>
                        damage = 0;<br/>
                    } else if (damage &gt; 0) {<br/>
                        // remaining damage transfers<br/>
                        desc += " " + damage + " damage transfers to "<br/>
                        + te.getLocationAbbr(nextHit) + ".";<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            // resolve special results<br/>
            if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {<br/>
                desc += "\n            Movement system damaged!";<br/>
                int nMP = te.getOriginalWalkMP();<br/>
                if (nMP &lt;= 1) {<br/>
                    ((Tank)te).immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    te_hex = game.board.getHex( te.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( te.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc += destroyEntity(te, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                }<br/>
                else {<br/>
                    te.setOriginalWalkMP(nMP - 1);<br/>
                }<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DESTROYED) {<br/>
                desc += "\n            Movement system destroyed!";<br/>
                ((Tank)te).immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;te_hex = game.board.getHex( te.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( te.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += destroyEntity(te, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_VEHICLE_TURRETLOCK) {<br/>
                desc += "\n            Turret locked!";<br/>
                ((Tank)te).lockTurret();<br/>
            }<br/>
            <br/>
            // roll all critical hits against this location<br/>
            for (int i = 0; i &lt; crits; i++) {<br/>
                desc += "\n" + criticalEntity(te, hit.getLocation());<br/>
            }<br/>
            crits = 0;<br/>
            <br/>
            if (te instanceof Mech &amp;&amp; hit.getLocation() == Mech.LOC_HEAD) {<br/>
                desc += "\n" + damageCrew(te, 1);<br/>
            }<br/>
            <br/>
            // loop to next location<br/>
            hit = nextHit;<br/>
        }<br/>
        <br/>
        return desc;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Rolls and resolves critical hits on mechs or vehicles.<br/>
     */<br/>
    private String criticalEntity(Entity en, int loc) {<br/>
        String desc = "        Critical hit on " + en.getLocationAbbr(loc) + ". ";<br/>
        int hits = 0;<br/>
        int roll = Compute.d6(2);<br/>
        desc += "Roll = " + roll + ";";<br/>
        if (roll &lt;= 7) {<br/>
            desc += " no effect.";<br/>
            return desc;<br/>
        } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
            hits = 1;<br/>
            desc += " 1 location.";<br/>
        } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
            hits = 2;<br/>
            desc += " 2 locations.";<br/>
        } else if (roll == 12) {<br/>
            if (en instanceof Tank) {<br/>
                hits = 3;<br/>
                desc += " 3 locations.";<br/>
            } else if (en.locationIsLeg(loc)) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                if (en.getInternal(loc) &gt; 0) {<br/>
                    destroyLocation(en, loc);<br/>
                }<br/>
                return desc;<br/>
            } else if (loc == Mech.LOC_RARM || loc == Mech.LOC_LARM) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                return desc;<br/>
            } else if (loc == Mech.LOC_HEAD) {<br/>
                desc += "&lt;&lt;&lt;HEAD BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                en.crew.setDead(true);<br/>
                desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                return desc;<br/>
            } else {<br/>
                // torso hit<br/>
                hits = 3;<br/>
                desc += " 3 locations.";<br/>
            }<br/>
        }<br/>
        <br/>
        // vehicle handle crits in their own 'special' way<br/>
        if (en instanceof Tank) {<br/>
            Tank tank = (Tank)en;<br/>
            for (int x = 0; x &lt; hits &amp;&amp; !tank.isDoomed(); x++) {<br/>
                switch (Compute.d6(1)) {<br/>
                    case 1 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Crew stunned for 3 turns";<br/>
                        // Carried units can't unload from a stunned transport.<br/>
                        // Units that escape a transport don't need to un-stun.<br/>
                        tank.stunCrew();<br/>
                        break;<br/>
                    case 2 :<br/>
                        // this one's ridiculous.  the 'main weapon' jams.<br/>
                        Mounted mWeap = tank.getMainWeapon();<br/>
                        if (mWeap == null) {<br/>
                            desc += "\n            No main weapon crit, because no main weapon!";<br/>
                        }<br/>
                        else {<br/>
                            desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; " + mWeap.getName() +<br/>
                            " jams.";<br/>
                            tank.setJammedWeapon(mWeap);<br/>
                        }<br/>
                        break;<br/>
                    case 3 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Engine destroyed.  Immobile.";<br/>
                        tank.immobilize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Does the hovercraft sink?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hex te_hex = game.board.getHex( en.getPosition() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( en.getMovementType() == Entity.MovementType.HOVER &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     te_hex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    desc += destroyEntity(en, "a watery grave", false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        break;<br/>
                    case 4 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Crew killed";<br/>
                        desc += destroyEntity(en, "crew death", true);<br/>
                        break;<br/>
                    case 5 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Fuel tank hit.  BOOM!";<br/>
                        desc += destroyEntity(en, "fuel tank explosion", false);<br/>
                       break;<br/>
                    case 6 :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; Power plant hit.  BOOM!";<br/>
                        desc += destroyEntity(en, "power plant destruction", false);<br/>
                        break;<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // transfer criticals, if needed<br/>
            if (hits &gt; 0 &amp;&amp; !en.hasHittableCriticals(loc)<br/>
            &amp;&amp; en.getTransferLocation(new HitData(loc)).getLocation() != Entity.LOC_DESTROYED) {<br/>
                loc = en.getTransferLocation(new HitData(loc)).getLocation();<br/>
                desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
                <br/>
                // may need to transfer crits twice--if you are shooting a CDA-3C Cicada and get lucky on the left arm two turns in a row<br/>
                if (hits &gt; 0 &amp;&amp; !en.hasHittableCriticals(loc)<br/>
                &amp;&amp; en.getTransferLocation(new HitData(loc)).getLocation() != Entity.LOC_DESTROYED) {<br/>
                    loc = en.getTransferLocation(new HitData(loc)).getLocation();<br/>
                    desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
                }<br/>
            }<br/>
            // roll criticals<br/>
            while (hits &gt; 0) {<br/>
                if (en.getHittableCriticals(loc) &lt;= 0) {<br/>
                    desc += "\n            Location has no more hittable critical slots.";<br/>
                    break;<br/>
                }<br/>
                int slot = Compute.randomInt(en.getNumberOfCriticals(loc));<br/>
                CriticalSlot cs = en.getCritical(loc, slot);<br/>
                if (cs == null || !cs.isHittable()) {<br/>
                    continue;<br/>
                }<br/>
                cs.setHit(true);<br/>
                switch(cs.getType()) {<br/>
                    case CriticalSlot.TYPE_SYSTEM :<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + Mech.systemNames[cs.getIndex()] + ".";<br/>
                        switch(cs.getIndex()) {<br/>
                            case Mech.SYSTEM_COCKPIT :<br/>
                                // boink!<br/>
                                en.crew.setDead(true);<br/>
                                desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                                break;<br/>
                            case Mech.SYSTEM_ENGINE :<br/>
                                int numEngineHits = 0;<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                                numEngineHits += en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
                                if (numEngineHits &gt; 2) {<br/>
                                    // third engine hit<br/>
                                    desc += destroyEntity(en, "engine destruction");<br/>
                                }<br/>
                                break;<br/>
                            case Mech.SYSTEM_GYRO :<br/>
                                if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                                    // gyro destroyed<br/>
                                    pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 3, "gyro destroyed"));<br/>
                                } else {<br/>
                                    // first gyro hit<br/>
                                    pilotRolls.addElement(new PilotingRollData(en.getId(), 3, "gyro hit"));<br/>
                                }<br/>
                                break;<br/>
                            case Mech.ACTUATOR_UPPER_LEG :<br/>
                            case Mech.ACTUATOR_LOWER_LEG :<br/>
                            case Mech.ACTUATOR_FOOT :<br/>
                                // leg/foot actuator piloting roll<br/>
                                pilotRolls.addElement(new PilotingRollData(en.getId(), 1, "leg/foot actuator hit"));<br/>
                                break;<br/>
                            case Mech.ACTUATOR_HIP :<br/>
                                // hip piloting roll<br/>
                                pilotRolls.addElement(new PilotingRollData(en.getId(), 2, "hip actuator hit"));<br/>
                                break;<br/>
                        }<br/>
                        break;<br/>
                    case CriticalSlot.TYPE_EQUIPMENT :<br/>
                        Mounted mounted = en.getEquipment(cs.getIndex());<br/>
                        EquipmentType eqType = mounted.getType();<br/>
                        boolean hitBefore = mounted.isHit();<br/>
                        desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + mounted.getDesc() + ".";<br/>
                        mounted.setHit(true);<br/>
<br/>
                        // If the item is the ECM suite of a Mek Stealth system<br/>
                        // then it's destruction turns off the stealth.<br/>
                        if ( !hitBefore &amp;&amp; eqType instanceof MiscType &amp;&amp;<br/>
                             eqType.hasFlag(MiscType.F_ECM) &amp;&amp;<br/>
                             mounted.getLinkedBy() != null ) {<br/>
                            Mounted stealth = mounted.getLinkedBy();<br/>
                            desc += "\n       " + stealth.getType().getName() +<br/>
                               " will stop functioning at end of turn.";<br/>
                            stealth.setMode( "Off" );<br/>
                        }<br/>
<br/>
                        // Handle equipment explosions.<br/>
                        if (eqType.isExplosive() &amp;&amp; !hitBefore) {<br/>
                            desc += explodeEquipment(en, loc, slot);<br/>
                        }<br/>
                        break;<br/>
                }<br/>
                hits--;<br/>
<br/>
            }<br/>
        }<br/>
        <br/>
        return desc;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    private void destroyLocation(Entity en, int loc) {<br/>
        // if it's already marked as destroyed, don't bother<br/>
        if (en.getInternal(loc) &lt; 0) {<br/>
            return;<br/>
        }<br/>
        // mark armor, internal as doomed<br/>
        en.setArmor(Entity.ARMOR_DOOMED, loc, false);<br/>
        en.setInternal(Entity.ARMOR_DOOMED, loc);<br/>
        if (en.hasRearArmor(loc)) {<br/>
            en.setArmor(Entity.ARMOR_DOOMED, loc, true);<br/>
        }<br/>
        // equipment marked missing<br/>
        for (Enumeration i = en.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setMissing(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as missing<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                cs.setMissing(true);<br/>
            }<br/>
        }<br/>
        // if it's a leg, the entity falls<br/>
        if (loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
            pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 5, "leg destroyed"));<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Mech.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Mark the unit as destroyed!  Units transported in the destroyed unit<br/>
     * will get a chance to escape.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason) {<br/>
        return destroyEntity( entity, reason, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the <br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason, <br/>
                                 boolean survivable) {<br/>
        // Generally, the entity can still be salvaged.<br/>
        return this.destroyEntity( entity, reason, survivable, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the <br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @param   canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that indicates if<br/>
     *          the unit can be salvaged (or cannibalized for spare parts).<br/>
     *          If &lt;code&gt;true&lt;/code&gt;, salvage operations are possible, if<br/>
     *          &lt;code&gt;false&lt;/code&gt;, the unit is too badly damaged.<br/>
     * @return  a &lt;code&gt;String&lt;/code&gt; that can be sent to the output log.<br/>
     */<br/>
    private String destroyEntity(Entity entity, String reason, <br/>
                                 boolean survivable, boolean canSalvage) {<br/>
        StringBuffer sb = new StringBuffer();<br/>
<br/>
        // The unit can suffer an ammo explosion after it has been destroyed.<br/>
        int condition = Game.UNIT_SALVAGEABLE;<br/>
        if ( !canSalvage ) {<br/>
            entity.setSalvage( canSalvage );<br/>
            condition = Game.UNIT_DEVASTATED;<br/>
        }<br/>
<br/>
        // Ignore entities that are already destroyed.<br/>
        if (!entity.isDoomed() &amp;&amp; !entity.isDestroyed()) {<br/>
            sb.append("\n*** ");<br/>
            sb.append(entity.getDisplayName());<br/>
            sb.append(" DESTROYED by ");<br/>
            sb.append(reason);<br/>
            sb.append("! ***\n");<br/>
            <br/>
            entity.setDoomed(true);<br/>
<br/>
            // Handle escape of transported units.<br/>
            Enumeration iter = entity.getLoadedUnits().elements();<br/>
            if ( iter.hasMoreElements() ) {<br/>
                Entity other = null;<br/>
                Coords curPos = entity.getPosition();<br/>
                Coords nextPos = null;<br/>
                Hex entityHex = game.getBoard().getHex( curPos );<br/>
                Hex nextHex = null;<br/>
                int curFacing = entity.getFacing();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    other = (Entity) iter.nextElement();<br/>
<br/>
                    // Can the other unit survive?<br/>
                    if ( !survivable ) {<br/>
<br/>
                        // Nope.<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        sb.append("\n*** " ).append( other.getDisplayName() +<br/>
                                  " was trapped in the wreckage. ***\n");<br/>
<br/>
                    }<br/>
                    // Can we unload the unit to the current hex?<br/>
                    else if (null != Compute.stackingViolation(game, other.getId(), curPos)<br/>
                             || other.isHexProhibited(entityHex) ) {<br/>
                        // TODO : this isn't covered in the rules<br/>
                        // Nope.<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        sb.append("\n*** " ).append( other.getDisplayName() +<br/>
                                  " tried to escape the wreckage, but couldn't. ***\n");<br/>
                    } // End can-not-unload<br/>
                    else {<br/>
                        // The other unit survives.<br/>
                        this.unloadUnit( entity, other, curPos, curFacing );<br/>
                    }<br/>
<br/>
                } // Handle the next transported unit.<br/>
<br/>
            } // End has-transported-unit<br/>
<br/>
            // Is this unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                sb.append( swarmer.getDisplayName() );<br/>
                sb.append( " ends its swarm attack.\n" );<br/>
                this.entityUpdate( swarmerId );<br/>
            }<br/>
<br/>
            // Is this unit swarming somebody?<br/>
            final int swarmedId = entity.getSwarmTargetId();<br/>
            if ( Entity.NONE != swarmedId ) {<br/>
                final Entity swarmed = game.getEntity( swarmedId );<br/>
                swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                entity.setSwarmTargetId( Entity.NONE );<br/>
                sb.append( swarmed.getDisplayName() );<br/>
                sb.append( " is freed from its swarm attack.\n" );<br/>
                this.entityUpdate( swarmedId );<br/>
            }<br/>
<br/>
        } // End entity-not-already-destroyed.<br/>
<br/>
        return sb.toString();<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes a piece of equipment on a mech explode!  POW!  This expects either<br/>
     * ammo, or an explosive weapon.<br/>
     */<br/>
    private String explodeEquipment(Entity en, int loc, int slot) {<br/>
        return explodeEquipment(en, loc, en.getEquipment(en.getCritical(loc, slot).getIndex()));<br/>
    } <br/>
    <br/>
    private String explodeEquipment(Entity en, int loc, Mounted mounted) {<br/>
        StringBuffer desc = new StringBuffer();<br/>
        // is this already destroyed?<br/>
        if (mounted.isDestroyed()) {<br/>
            System.err.println("server: explodeEquipment called on destroyed"<br/>
            + " equipment (" + mounted.getName() + ")");<br/>
            return "";<br/>
        }<br/>
        <br/>
        // special-case.  RACs only explode when jammed<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp; <br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
            if (!mounted.isJammed()) {<br/>
                return "";<br/>
            }<br/>
        }<br/>
<br/>
        // Inferno ammo causes heat buildup as well as the damage<br/>
        if ( mounted.getType() instanceof AmmoType &amp;&amp;<br/>
             ((AmmoType)mounted.getType()).getMunitionType() == AmmoType.M_INFERNO) {<br/>
            en.heatBuildup += 30;<br/>
        }<br/>
<br/>
        // determine and deal damage<br/>
        int damage = mounted.getExplosionDamage();<br/>
        <br/>
        if (damage &lt;= 0) {<br/>
            return "";<br/>
        }<br/>
        <br/>
        desc.append("\n*** ");<br/>
        desc.append(mounted.getName());<br/>
        desc.append(" EXPLODES!  ");<br/>
        desc.append(damage);<br/>
        desc.append(" DAMAGE! ***");<br/>
        <br/>
        desc.append(damageEntity(en, new HitData(loc), damage, true));<br/>
        desc.append("\n");<br/>
        if (!en.isDoomed() &amp;&amp; !en.isDestroyed()) {<br/>
            desc.append(damageCrew(en, 2));<br/>
            desc.append("\n");<br/>
        }<br/>
        <br/>
        return desc.toString();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                if (cs == null || cs.isDestroyed() || cs.isHit() || cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {<br/>
                    continue;<br/>
                }<br/>
                Mounted mounted = entity.getEquipment(entity.getCritical(j, k).getIndex());<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if (!atype.isExplosive()) {<br/>
                    continue;<br/>
                }<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds. <br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            return explodeEquipment(entity, boomloc, boomslot);<br/>
        } else {<br/>
            return "  Luckily, there is no ammo to explode.\n";<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, int facing, PilotingRollData roll) {<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            phaseReport.append("But, since the 'mech is making a death from above attack, damage will be dealt during the physical phase.\n");<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }<br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
            case 1:<br/>
            case 2:<br/>
                side = "right side";<br/>
                table = ToHitData.SIDE_RIGHT;<br/>
                break;<br/>
            case 3:<br/>
                side = "rear";<br/>
                table = ToHitData.SIDE_REAR;<br/>
                break;<br/>
            case 4:<br/>
            case 5:<br/>
                side = "left side";<br/>
                table = ToHitData.SIDE_LEFT;<br/>
                break;<br/>
            case 0:<br/>
            default:<br/>
                side = "front";<br/>
                table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        // calculate damage<br/>
        int damage = (int)Math.round(entity.getWeight() / 10) * (height + 1);<br/>
        <br/>
        // TODO: only fall to surface of water<br/>
        if (game.board.getHex(fallPos).levelOf(Terrain.WATER) &gt; 0) {<br/>
            damage = (int)Math.ceil(damage / 2.0);<br/>
        }<br/>
        <br/>
        // report falling<br/>
        phaseReport.append("    " ).append( entity.getDisplayName() ).append( " falls on its " ).append( side ).append( ", suffering " ).append( damage ).append( " damage.");<br/>
<br/>
        // Any swarming infantry will be dislodged, but we don't want to<br/>
        // interrupt the fall's report.  We have to get the ID now because<br/>
        // the fall may kill the entity which will reset the attacker ID.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            phaseReport.append(damageEntity(entity, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        <br/>
        // pilot damage?<br/>
        roll.removeAutos();<br/>
<br/>
        if (height &gt; 0) {<br/>
            roll.addModifier(height, "height of fall");<br/>
        }<br/>
        <br/>
        if (roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            phaseReport.append("\nPilot of " ).append( entity.getDisplayName()<br/>
            ).append( " \"" ).append( entity.crew.getName() ).append( "\" cannot avoid damage.\n");<br/>
            phaseReport.append(damageCrew(entity, 1) ).append( "\n");<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("\nPilot of " ).append( entity.getDisplayName()<br/>
            ).append( " \"" ).append( entity.crew.getName() ).append( "\" must roll " ).append( roll.getValueAsString()<br/>
            ).append( " to avoid damage; rolls " ).append( diceRoll ).append( " : ");<br/>
            if (diceRoll &gt;= roll.getValue()) {<br/>
                phaseReport.append("succeeds.\n");<br/>
            } else {<br/>
                phaseReport.append("fails.\n");<br/>
                phaseReport.append(damageCrew(entity, 1) ).append( "\n");<br/>
            }<br/>
        }<br/>
         <br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Only Mechs can fall prone.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( entity instanceof Mech ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    entity.setProne(true);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
<br/>
        // Now dislodge any swarming infantry.<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            entity.setSwarmAttackerId( Entity.NONE );<br/>
            swarmer.setSwarmTargetId( Entity.NONE );<br/>
            // Did the infantry fall into water?<br/>
            Hex fallHex = game.board.getHex( fallPos );<br/>
            if ( fallHex.levelOf(Terrain.WATER) &gt; 0 ) {<br/>
                // Swarming infantry die.<br/>
                swarmer.setPosition( fallPos );<br/>
                phaseReport.append("    ")<br/>
                    .append(swarmer.getDisplayName())<br/>
                    .append(" is dislodged and drowns!")<br/>
                    .append(destroyEntity(swarmer, "a watery grave", false));<br/>
            } else {<br/>
                // Swarming infantry take an 11 point hit.<br/>
                // ASSUMPTION : damage should not be doubled.<br/>
                phaseReport.append("    ")<br/>
                    .append(swarmer.getDisplayName())<br/>
                    .append(" is dislodged and suffers 11 damage.")<br/>
                    .append( damageEntity(swarmer, <br/>
                                          swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT),<br/>
                                          11) )<br/>
                    .append( "\n" );<br/>
            }<br/>
            swarmer.setPosition( fallPos );<br/>
            entityUpdate( swarmerId );<br/>
        } // End dislodge-infantry<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, PilotingRollData roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
    <br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, PilotingRollData roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
    /** Make fires spread, smoke spread, and make sure that all fires<br/>
     * started this turn are marked as "burning" for next turn.<br/>
     * <br/>
     * A "FIRE" terrain has one of two levels: <br/>
     *  1 (Created this turn, and so can't spread of generate heat)<br/>
     *  2 (Created as a result of spreading fire or on a previous turn)<br/>
     *<br/>
     * Since fires created at end of turn act normally in the following turn, <br/>
     * spread fires have level 2.<br/>
     *<br/>
     * At NO TIME should any fire created outside this function have a level of <br/>
     * 2, nor should anything except this function SET fires to level 2.<br/>
     * <br/>
     * Newly created "spread" fires have a level of 1, so that they do not <br/>
     * spread in the turn they are created.  After all spreading has been <br/>
     * completed, all burning hexes are set to level 2.<br/>
     */<br/>
    private void resolveFire() {<br/>
        Board board = game.getBoard();<br/>
        int width = board.width;<br/>
        int height = board.height;<br/>
        int windDirection = game.getWindDirection();<br/>
        <br/>
        phaseReport.append("\n\nResolving fire movement \n ------------------------\n");<br/>
        // Cycle through all hexes, checking for fire.<br/>
        for (int currentXCoord = 0; currentXCoord &lt; width; currentXCoord++ ) {<br/>
            <br/>
            for (int currentYCoord = 0; currentYCoord &lt; height;<br/>
                 currentYCoord++) {<br/>
                Coords currentCoords = new Coords(currentXCoord,<br/>
                                                  currentYCoord);<br/>
                Hex currentHex = board.getHex(currentXCoord, currentYCoord);<br/>
                boolean infernoBurning = board.burnInferno( currentCoords );<br/>
<br/>
                // If the woods has been cleared, put non-inferno fires out.<br/>
                if ( currentHex.contains(Terrain.FIRE) &amp;&amp; !infernoBurning &amp;&amp;<br/>
                     !(currentHex.contains(Terrain.WOODS))) {<br/>
                    removeFire(currentXCoord, currentYCoord, currentHex);<br/>
                }<br/>
<br/>
                // Was the fire was started on a previous turn?<br/>
                else if (currentHex.levelOf(Terrain.FIRE) == 2)<br/>
                {<br/>
                    if ( infernoBurning ) {<br/>
                        phaseReport.append( "Inferno fire at " );<br/>
                    } else {<br/>
                        phaseReport.append( "Fire at " );<br/>
                    }<br/>
                    phaseReport.append( currentCoords.getBoardNum() )<br/>
                        .append( " is burning brightly.\n" );<br/>
                    spreadFire(currentXCoord, currentYCoord, windDirection);<br/>
                }  // End the Else If Hex was on fire previously<br/>
            }  // end the loop through Y coordinates<br/>
        }  // end the loop through X coordinates<br/>
        //  Loop a second time, to set all fires to level 2 before next turn, and add smoke.<br/>
        for (int currentXCoord = 0; currentXCoord &lt; width; currentXCoord++ ) {<br/>
            <br/>
            for (int currentYCoord = 0; currentYCoord &lt; height; currentYCoord++) {<br/>
                Coords currentCoords = new Coords(currentXCoord, currentYCoord);<br/>
                Hex currentHex = board.getHex(currentXCoord,currentYCoord);<br/>
                // if the fire in the hex was started this turn<br/>
                if (currentHex.levelOf(Terrain.FIRE) == 1) {<br/>
                    currentHex.removeTerrain(Terrain.FIRE);<br/>
                    currentHex.addTerrain(new Terrain(Terrain.FIRE, 2));<br/>
                    sendChangedHex(currentCoords);<br/>
                    phaseReport.append( "Fire at " )<br/>
                        .append( currentCoords.getBoardNum() )<br/>
                        .append( " was started this round.\n" );<br/>
                }<br/>
                if (currentHex.contains(Terrain.FIRE)) {<br/>
                    addSmoke(currentXCoord, currentYCoord, windDirection);<br/>
                    addSmoke(currentXCoord, currentYCoord, (windDirection+1)%6);<br/>
                    addSmoke(currentXCoord, currentYCoord, (windDirection+5)%6);<br/>
                    board.initializeAround(currentXCoord,currentYCoord);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }  // End the ResolveFire() method<br/>
    <br/>
    /**<br/>
     * Spreads the fire around the specified coordinates.<br/>
     */<br/>
    public void spreadFire(int x, int y, int windDir) {<br/>
        Coords src = new Coords(x, y);<br/>
        Coords nextCoords = src.translated(windDir);<br/>
        <br/>
        spreadFire(nextCoords, 9);<br/>
        <br/>
        // Spread to the next hex downwind on a 12 if the first hex wasn't burning...<br/>
        Hex nextHex = game.getBoard().getHex(nextCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.contains(Terrain.FIRE))) {<br/>
            // we've already gone one step in the wind direction, now go another<br/>
            spreadFire(nextCoords.translated(windDir), 12);<br/>
        }<br/>
        <br/>
        // spread fire 60 degrees clockwise....<br/>
        spreadFire(src.translated((windDir + 1) % 6), 11);<br/>
        <br/>
        // spread fire 60 degrees counterclockwise<br/>
        spreadFire(src.translated((windDir + 5) % 6), 11);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Spreads the fire, and reports the spread, to the specified hex, if<br/>
     * possible and the fire roll is made.<br/>
     */<br/>
    public void spreadFire(Coords coords, int roll) {<br/>
        Hex hex = game.getBoard().getHex(coords);<br/>
        if (burn(hex, roll)) {<br/>
            sendChangedHex(coords);<br/>
            phaseReport.append("Fire spreads to " ).append( coords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     */<br/>
    public boolean burn(Hex hex, int roll, boolean bAnyTerrain) {<br/>
        if (!game.getOptions().booleanOption("fire") || null == hex <br/>
                || hex.contains(Terrain.FIRE)) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        if (!bAnyTerrain &amp;&amp; !(hex.contains(Terrain.WOODS))) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        int fireRoll = Compute.d6(2);<br/>
        if (fireRoll &gt;= roll) {<br/>
            hex.addTerrain(new Terrain(Terrain.FIRE, 1));<br/>
            return true;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
    }<br/>
    <br/>
    // default signature, assuming only woods can burn<br/>
    public boolean burn(Hex hex, int roll) {<br/>
        return burn(hex, roll, false);<br/>
    }<br/>
    <br/>
    <br/>
    public void removeFire(int x, int y, Hex hex) {<br/>
        Coords fireCoords = new Coords(x, y);<br/>
        int windDir = game.getWindDirection();<br/>
        hex.removeTerrain(Terrain.FIRE);<br/>
        sendChangedHex(fireCoords);<br/>
        removeSmoke(x, y, windDir);<br/>
        removeSmoke(x, y, (windDir + 1) % 6);<br/>
        removeSmoke(x, y, (windDir + 5) % 6);<br/>
        phaseReport.append("Fire at " ).append( fireCoords.getBoardNum() ).append( " goes out due to lack of fuel!\n");<br/>
    }<br/>
    <br/>
    // called when a fire is burning.  Adds smoke to hex in the direction specified.  Called 3 times per fire hex,<br/>
    public void addSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        Hex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.contains(Terrain.SMOKE))) {<br/>
            nextHex.addTerrain(new Terrain(Terrain.SMOKE, 1));<br/>
            sendChangedHex(smokeCoords);<br/>
            phaseReport.append("Smoke fills " ).append( smokeCoords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    public void removeSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        Hex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; nextHex.contains(Terrain.SMOKE)) {<br/>
            nextHex.removeTerrain(Terrain.SMOKE);<br/>
            sendChangedHex(smokeCoords);<br/>
            phaseReport.append("Smoke clears from " ).append( smokeCoords.getBoardNum() ).append( "!\n");<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Scans the boards directory for map boards of the appropriate size<br/>
     * and returns them.<br/>
     */<br/>
    private Vector scanForBoards(int boardWidth, int boardHeight) {<br/>
        Vector boards = new Vector();<br/>
        <br/>
        File boardDir = new File("data/boards");<br/>
        <br/>
        // just a check...<br/>
        if (!boardDir.isDirectory()) {<br/>
            return boards;<br/>
        }<br/>
        <br/>
        // scan files<br/>
        String[] fileList = boardDir.list();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(fileList[i], boardWidth, boardHeight)) {<br/>
                boards.addElement(fileList[i].substring(0, fileList[i].lastIndexOf(".board")));<br/>
            }<br/>
        }<br/>
        <br/>
        // if there are any boards, add these:<br/>
        if (boards.size() &gt; 0) {<br/>
            boards.insertElementAt(MapSettings.BOARD_RANDOM, 0);<br/>
            boards.insertElementAt(MapSettings.BOARD_SURPRISE, 1);<br/>
        }<br/>
        <br/>
        //TODO: alphabetize files?<br/>
        <br/>
        return boards;<br/>
    }<br/>
    <br/>
    private boolean doBlind() {<br/>
        return (game.getOptions().booleanOption("double_blind") &amp;&amp;<br/>
        game.phase &gt;= Game.PHASE_INITIATIVE);<br/>
    }<br/>
    <br/>
    /**<br/>
     * In a double-blind game, update only visible entities.  Otherwise,<br/>
     * update everyone<br/>
     */<br/>
    private void entityUpdate(int nEntityID) {<br/>
        if (doBlind()) {<br/>
            Entity eTarget = game.getEntity(nEntityID);<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            Vector vCanSee = new Vector();<br/>
            vCanSee.addElement(eTarget.getOwner());<br/>
            Vector vEntities = game.getEntitiesVector();<br/>
            for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
                Entity e = (Entity)vEntities.elementAt(x);<br/>
                if (vCanSee.contains(e.getOwner()) || !e.isActive()) {<br/>
                    continue;<br/>
                }<br/>
                if (Compute.canSee(game, e, eTarget)) {<br/>
                    vCanSee.addElement(e.getOwner());<br/>
                }<br/>
            }<br/>
            // send an entity update to everyone who can see<br/>
            Packet pack = createEntityPacket(nEntityID);<br/>
            for (int x = 0; x &lt; vCanSee.size(); x++) {<br/>
                Player p = (Player)vCanSee.elementAt(x);<br/>
                send(p.getId(), pack);<br/>
            }<br/>
            // send an entity delete to everyone else<br/>
            pack = createRemoveEntityPacket(nEntityID);<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                if (!vCanSee.contains(vPlayers.elementAt(x))) {<br/>
                    Player p = (Player)vPlayers.elementAt(x);<br/>
                    send(p.getId(), pack);<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // everyone can see<br/>
            send(createEntityPacket(nEntityID));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send the complete list of entities to the players.<br/>
     * If double_blind is in effect, enforce it by filtering the entities<br/>
     */<br/>
    private void entityAllUpdate() {<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                Player p = (Player)vPlayers.elementAt(x);<br/>
                send(p.getId(), createFilteredEntitiesPacket(p));<br/>
            }<br/>
        }<br/>
        else {<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Filters an entity vector according to LOS<br/>
     */<br/>
    private Vector filterEntities(Player pViewer, Vector vEntities) {<br/>
        Vector vCanSee = new Vector();<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        Vector vMyEntities = new Vector();<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            if (e.getOwner() == pViewer) {<br/>
                vMyEntities.addElement(e);<br/>
            }<br/>
        }<br/>
        <br/>
        for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
            Entity e = (Entity)vEntities.elementAt(x);<br/>
            if (vMyEntities.contains(e)) {<br/>
                vCanSee.addElement(e);<br/>
                continue;<br/>
            }<br/>
            for (int y = 0; y &lt; vMyEntities.size(); y++) {<br/>
                Entity e2 = (Entity)vMyEntities.elementAt(y);<br/>
                if (Compute.canSee(game, e2, e)) {<br/>
                    vCanSee.addElement(e);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets an entity ready status to false<br/>
     */<br/>
    private void receiveEntityReady(Packet pkt, int connIndex) {<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveMulti = game.getOptions().booleanOption("inf_move_multi");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMoveLast = game.getOptions().booleanOption("inf_move_last");<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getTurn().getPlayerNum() == connIndex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Check for potential cheating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // If "inf_move_mutli" option is selected, and we're in the middle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // of a block of Infantry fires, entity had better be an Infantry<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // platoon owned by the most recent player.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( infMoveMulti &amp;&amp; turnInfMoved &gt; 0 &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( !(entity instanceof Infantry) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   entity.getOwnerId() != turnLastPlayerId ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something appropriately awful.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: Implement me!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }        <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // We passed the cheat checks.<br/>
            entity.setDone(true);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Is the entity Infantry?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if ( entity instanceof Infantry ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Increment the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved++;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Record the player moving the infantry.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLastPlayerId = entity.getOwnerId();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do infantry move in blocks?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( infMoveMulti ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Are we at the end of a block?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( Game.INF_MOVE_MULTI == turnInfMoved ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !game.hasInfantry(turnLastPlayerId) ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Yup.  Reset the counter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnInfMoved = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nope.  Decrement the turn index.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnIndex--;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // End inf_move_multi<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } // End entity-is-infantry<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
            System.out.println("server.receiveEntityReady: got an invalid ready message");<br/>
        }<br/>
<br/>
    }<br/>
    <br/>
    /**<br/>
     * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
     */<br/>
    private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        <br/>
        entity.restore();<br/>
        entity.setOwner(getPlayer(connIndex));<br/>
<br/>
        // Only assign an entity ID when the client hasn't.<br/>
        if ( Entity.NONE == entity.getId() ) { <br/>
            entity.setId(entityCounter++); <br/>
        }<br/>
        game.addEntity(entity.getId(), entity);<br/>
        <br/>
        send(createAddEntityPacket(entity.getId()));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Updates an entity with the info from the client.  Only valid to do this<br/>
     * durring the lounge phase.<br/>
     */<br/>
    private void receiveEntityUpdate(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        Entity oldEntity = game.getEntity(entity.getId());<br/>
        if (oldEntity != null &amp;&amp; oldEntity.getOwner() == getPlayer(connIndex)) {<br/>
            entity.restore();<br/>
            entity.setOwner(getPlayer(connIndex));<br/>
            game.setEntity(entity.getId(), entity);<br/>
            <br/>
            send(createEntitiesPacket());<br/>
        } else {<br/>
            // hey!<br/>
        }<br/>
    }<br/>
    <br/>
    private void receiveEntityModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        Mounted m = e.getEquipment(equipId);<br/>
        <br/>
        // a mode change for ammo means dumping<br/>
        if (m.getType() instanceof AmmoType) {<br/>
            m.setPendingDump(mode == 1);<br/>
        }<br/>
        else {<br/>
            m.setMode(mode);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        Entity entity = game.getEntity(entityId);<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)) {<br/>
            game.removeEntity(entityId);<br/>
            send(createRemoveEntityPacket(entityId, Game.UNIT_NEVER_JOINED));<br/>
        } else {<br/>
            // hey! that's not your entity<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerDone(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        getPlayer(connIndex).setDone(ready);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sets game options, providing that the player has specified the password<br/>
     * correctly.<br/>
     *<br/>
     * @returns true if any options have been successfully changed.<br/>
     */<br/>
    private boolean receiveGameOptions(Packet packet, int connId) {<br/>
        // check password<br/>
        if (password != null &amp;&amp; password.length() &gt; 0 &amp;&amp; !password.equals(packet.getObject(0))) {<br/>
            sendServerChat(connId, "The password you specified to change game options is incorrect.");<br/>
            return false;<br/>
        }<br/>
        <br/>
        int changed = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infLastValue =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_last").booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean infMultiValue =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_multi").booleanValue();<br/>
        <br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            GameOption option = (GameOption)i.nextElement();<br/>
            GameOption originalOption = game.getOptions().getOption(option.getShortName());<br/>
            <br/>
            if (originalOption == null) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            sendServerChat("Player " + getPlayer(connId).getName() + " changed option \"" + originalOption.getFullName() + "\" to " + option.stringValue() + ".");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // Record mutually-exclusive infantry move options.<br/>
            if ( option.getShortName().equals("inf_move_last") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infLastValue = option.booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    else if ( option.getShortName().equals("inf_move_multi") ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infMultiValue = option.booleanValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
            originalOption.setValue(option.getValue());<br/>
            changed++;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Infantry move options can't BOTH be on!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( infLastValue &amp;&amp; (infLastValue == infMultiValue) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    sendServerChat("Player " + getPlayer(connId).getName() + " tried to set BOTH \"" + game.getOptions().getOption("inf_move_last").getFullName() + "\" and \""  + game.getOptions().getOption("inf_move_multi").getFullName() + "\" to true.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    sendServerChat("Clearing *BOTH* options.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_last").setValue(false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    game.getOptions().getOption("inf_move_multi").setValue(false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    changed += 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        return changed &gt; 0;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    <br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerDones() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            <br/>
            send(createPlayerDonePacket(player.getId()));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerDonePacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isDone());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the map settings<br/>
     */<br/>
    private Packet createMapSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing temporary map settings as a response to a<br/>
     * client query<br/>
     */<br/>
    private Packet createMapQueryPacket(MapSettings temp) {<br/>
        return new Packet(Packet.COMMAND_QUERY_MAP_SETTINGS, temp);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createGameSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, game.getOptions());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.board);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Creates a packet containing the round report<br/>
     */<br/>
    private Packet createReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORT, roundReport.toString());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing all entities visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredEntitiesPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, filterEntities(p, game.getEntitiesVector()));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the addition of an entity<br/>
     */<br/>
    private Packet createAddEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_ADD, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     * Maintained for backwards compatability.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId) {<br/>
        return this.createRemoveEntityPacket(entityId, Game.UNIT_SALVAGEABLE);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @param   condition - the &lt;code&gt;int&lt;/code&gt; condition the unit was in.<br/>
     *          This value must be one of &lt;code&gt;Game.UNIT_IN_RETREAT&lt;/code&gt;,<br/>
     *          &lt;code&gt;Game.UNIT_SALVAGEABLE&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_DEVASTATED&lt;/code&gt; or an<br/>
     *          &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId, int condition) {<br/>
        if ( condition != Game.UNIT_NEVER_JOINED &amp;&amp;<br/>
             condition != Game.UNIT_IN_RETREAT &amp;&amp;<br/>
             condition != Game.UNIT_SALVAGEABLE &amp;&amp;<br/>
             condition != Game.UNIT_DEVASTATED ) {<br/>
            throw new IllegalArgumentException( "Unknown unit condition: " +<br/>
                                                condition );<br/>
        }<br/>
        Object[] array = new Object[2];<br/>
        array[0] = new Integer(entityId);<br/>
        array[1] = new Integer(condition);<br/>
        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet indicating end of game, including detailed unit status<br/>
     */<br/>
    private Packet createEndOfGamePacket() {<br/>
        return new Packet(Packet.COMMAND_END_OF_GAME, getDetailedVictoryReport());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(int connId, String origin, String message) {<br/>
        send(connId, new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(String origin, String message) {<br/>
        String chat = origin + ": " + message;<br/>
        send(new Packet(Packet.COMMAND_CHAT, chat));<br/>
        log.append(chat);<br/>
    }<br/>
    <br/>
    public void sendServerChat(int connId, String message) {<br/>
        sendChat(connId, "***Server", message);<br/>
    }<br/>
    <br/>
    public void sendServerChat(String message) {<br/>
        sendChat("***Server", message);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing a hex, and the coordinates it goes at.<br/>
     */<br/>
    private Packet createHexChangePacket(Coords coords, Hex hex) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = coords;<br/>
        data[1] = hex;<br/>
        return new Packet(Packet.COMMAND_CHANGE_HEX, data);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Sends notification to clients that the specified hex has changed.<br/>
     */<br/>
    public void sendChangedHex(Coords coords) {<br/>
        send(createHexChangePacket(coords, game.board.getHex(coords)));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(Vector vector) {<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, vector);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
        packet.zipData();<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        packet.zipData();<br/>
        getClient(connId).send(packet);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        getPendingConnection(connId).send(packet);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Process an in-game command<br/>
     */<br/>
    private void processCommand(int connId, String commandString) {<br/>
        String[] args;<br/>
        String commandName;<br/>
        // all tokens are read as strings; if they're numbers, string-ize 'em.<br/>
        StringTokenizer st = new StringTokenizer(commandString);<br/>
        args = new String[st.countTokens()];<br/>
        for (int i = 0; i &lt; args.length; i++) {<br/>
            args[i] = st.nextToken();<br/>
        }<br/>
        <br/>
        // figure out which command this is<br/>
        commandName = args[0].substring(1);<br/>
        <br/>
        // process it<br/>
        ServerCommand command = getCommand(commandName);<br/>
        if (command != null) {<br/>
            command.run(connId, args);<br/>
        } else {<br/>
            sendServerChat(connId, "Command not recognized.  Type /help for a list of commands.");<br/>
        }<br/>
    }<br/>
 <br/>
    /**<br/>
     * Calculate the piloting skill roll modifier, based upon the number<br/>
     * of hexes moved this phase.<br/>
     */<br/>
    private int getMovementPSRModifier( int distance ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( distance &gt; 10 ) // 11+ hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 7 ) // 8-10 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 4 ) // 5-7 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if ( distance &gt; 2 ) // 3-4 hexes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return -1; // 0-2 hexes<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a packet<br/>
     */<br/>
    synchronized void handle(int connId, Packet packet) {<br/>
        //System.out.println("s(" + cn + "): received command");<br/>
        if (packet == null) {<br/>
            System.out.println("server.connection.handle: got null packet");<br/>
            return;<br/>
        }<br/>
        // act on it<br/>
        switch(packet.getCommand()) {<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receivePlayerName(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(packet, connId);<br/>
                validatePlayerInfo(connId);<br/>
                send(createPlayerUpdatePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerDone(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)packet.getObject(0);<br/>
                if (chat.startsWith("/")) {<br/>
                    processCommand(connId, chat);<br/>
                } else {<br/>
                    sendChat(getPlayer(connId).getName(), chat);<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                receiveMovement(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_DEPLOY :<br/>
                receiveDeployment(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_UPDATE :<br/>
                receiveEntityUpdate(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MODECHANGE :<br/>
                receiveEntityModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                if (receiveGameOptions(packet, connId)) {<br/>
                    resetPlayersDone();<br/>
                    transmitAllPlayerDones();<br/>
                    send(createGameSettingsPacket());<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_MAP_SETTINGS :<br/>
                mapSettings = (MapSettings)packet.getObject(0);<br/>
                mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case Packet.COMMAND_QUERY_MAP_SETTINGS :<br/>
                MapSettings temp = (MapSettings)packet.getObject(0);<br/>
                temp.setBoardsAvailableVector(scanForBoards(temp.getBoardWidth(), temp.getBoardHeight()));<br/>
                temp.removeUnavailable();<br/>
                temp.setNullBoards(DEFAULT_BOARD);<br/>
                temp.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                temp.removeUnavailable();<br/>
                send(connId, createMapQueryPacket(temp));<br/>
                break;<br/>
        }<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
                <br/>
                int id = connectionCounter++;<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
                <br/>
                connectionsPending.addElement(new Connection(this, s, id));<br/>
                <br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
                ;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of inferno ammo, determined<br/>
     * by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeInfernoAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        StringBuffer result = new StringBuffer();<br/>
<br/>
        // Find the most destructive Inferno ammo.<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                // Ignore empty, destroyed, hit, and structure slots.<br/>
                if ( cs == null || cs.isDestroyed() || cs.isHit() ||<br/>
                     cs.getType() != CriticalSlot.TYPE_EQUIPMENT ) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but weapons slots.<br/>
                Mounted mounted = entity.getEquipment<br/>
                    ( entity.getCritical(j, k).getIndex() );<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but Inferno ammo.<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if ( !atype.isExplosive() ||<br/>
                     atype.getMunitionType() != AmmoType.M_INFERNO) {<br/>
                    continue;<br/>
                }<br/>
                // Find the most destructive undamaged ammo.<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds. <br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        // Did we find anything to explode?<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            // We've allocated heatBuildup to heat in resolveHeat(),<br/>
            // so need to add to the entity's heat instead.<br/>
            result.append( explodeEquipment(entity, boomloc, boomslot) );<br/>
            entity.heat += 30;<br/>
            result.append( "   Gains 30 heat and is now at " )<br/>
                .append( entity.heat )<br/>
                .append( " heat.\n" );<br/>
            entity.heatBuildup = 0;<br/>
        } else {<br/>
            result.append("  Luckily, there is no inferno ammo to explode.\n");<br/>
        }<br/>
        return result.toString();<br/>
    }<br/>
<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>