<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_Server_1.20.java</h1>
<div class="code">
<div class="id">
/**<br/>
 * MegaMek - Copyright (C) 2000-2002 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.net.*;<br/>
import java.io.*;<br/>
import java.util.*;<br/>
<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server<br/>
    implements Runnable<br/>
{<br/>
    // server setup<br/>
    private String              name;<br/>
    private ServerSocket        serverSocket;<br/>
<br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
<br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
<br/>
    private Game                game = new Game();<br/>
<br/>
    // list of turns and whose turn it is<br/>
    private int                 roundCounter = 0;<br/>
    private int[]               turns;<br/>
    private int                 ti;<br/>
<br/>
    // stuff for the current turn<br/>
    private GameSettings        gameSettings = new GameSettings();<br/>
    private Vector              attacks = new Vector();<br/>
    private Vector              pendingCharges = new Vector();<br/>
    private Vector              pilotRolls = new Vector();<br/>
<br/>
    private StringBuffer        roundReport = new StringBuffer();<br/>
    private StringBuffer        phaseReport = new StringBuffer();<br/>
<br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
<br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     */<br/>
    public Server(String name, int port) {<br/>
        this.name = name;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port " + port);<br/>
        }<br/>
<br/>
        game.phase = Game.PHASE_LOUNGE;<br/>
<br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
        System.out.println("s: address = " + serverSocket.getInetAddress().getHostAddress() + " port = " + serverSocket.getLocalPort());<br/>
<br/>
        connector = new Thread(this);<br/>
        connector.start();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sent when a clients attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server info -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_NAME, name));<br/>
    }<br/>
<br/>
    /**<br/>
     * Recieves a client name, sent from a pending connection as a signal to<br/>
     * connect.<br/>
     */<br/>
    private void receiveClientName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
<br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending connection");<br/>
            return;<br/>
        }<br/>
<br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
<br/>
        // add and validate the player info<br/>
        game.addPlayer(connId, new Player(connId, (String)packet.getObject(0)));<br/>
        validatePlayerInfo(connId);<br/>
<br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
<br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
<br/>
        // send current game info<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(connId, createSettingsPacket());<br/>
        send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(game.phase)));<br/>
        send(connId, createEntitiesPacket());<br/>
<br/>
        System.out.println("s: player " + connId<br/>
                           + " (" + getPlayer(connId).getName() + ") connected from "<br/>
                           + getClient(connId).socket.getInetAddress());<br/>
        sendChatToAll("***Server", getPlayer(connId).getName() + " connected from "<br/>
                           + getClient(connId).socket.getInetAddress());<br/>
    }<br/>
<br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        //TODO: remove unsavory characters from the name<br/>
        //TODO: check for duplicate or reserved names<br/>
<br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (player.getId() != playerId) {<br/>
                colorUsed[player.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (colorUsed[getPlayer(playerId).getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    getPlayer(playerId).setColorIndex(i);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when it is sensed that a connection has terminated.<br/>
     */<br/>
    private void disconnected(int connId) {<br/>
        final Connection conn = getClient(connId);<br/>
        final Player player = getPlayer(connId);<br/>
<br/>
        conn.die();<br/>
<br/>
        connections.removeElement(conn);<br/>
        connectionIds.remove(new Integer(connId));<br/>
<br/>
        // in the lounge, just remove all entities for that player<br/>
        if (game.phase == Game.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
<br/>
        // if a player has active entities, he becomes a ghost<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0) {<br/>
            player.setGhost(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, new Integer(player.getId())));<br/>
        }<br/>
<br/>
        System.out.println("s: player " + connId + " disconnected");<br/>
        sendChatToAll("***Server", player.getName() + " disconnected.");<br/>
    }<br/>
<br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
<br/>
    /**<br/>
     * Counts up how many non-ghost, non-observer players are connected.<br/>
     */<br/>
        private int countActivePlayers() {<br/>
        int count = 0;<br/>
<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver()) {<br/>
                count++;<br/>
            }<br/>
        }<br/>
<br/>
        return count;<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            game.removeEntity(entity.getId());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    private Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
<br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Resets the server back to the lounge<br/>
     */<br/>
    private void resetServer() {<br/>
        //game.entities.removeAllElements();<br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Are we out of turns (done with the phase?)<br/>
     */<br/>
    private boolean areMoreTurns() {<br/>
        return ti &lt; turns.length;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the player number of who gets the next turn,<br/>
     * or -1 if we're done.<br/>
     */<br/>
    private int nextTurn() {<br/>
        if (ti &lt; turns.length) {<br/>
            return turns[ti++];<br/>
        } else {<br/>
            return -1;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this entity<br/>
     * that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.delta_distance = 0;<br/>
            entity.moved = Entity.MOVE_NONE;<br/>
            <br/>
            entity.setCharging(false);<br/>
            entity.setMakingDfa(false);<br/>
<br/>
            entity.crew.setKoThisRound(false);<br/>
<br/>
            for (Enumeration i = entity.weapons.elements(); i.hasMoreElements();) {<br/>
                MountedWeapon w = (MountedWeapon)i.nextElement();<br/>
                w.setFiredThisRound(false);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase() {<br/>
    // first, mark doomed entities as destroyed and move them to the graveyard<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
            if (entity.isDestroyed()) {<br/>
                game.moveToGraveyard(entity.getId());<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            // if ammo has exploded, empty the bin<br/>
            for (Enumeration i = entity.ammo.elements(); i.hasMoreElements();) {<br/>
                final Ammo a = (Ammo)i.nextElement();<br/>
                if (a.exploded) {<br/>
                    a.shots = 0;<br/>
                    a.exploded = false;<br/>
                }<br/>
            }<br/>
<br/>
            // weapons are readied, except destroyed ones.<br/>
            for (Enumeration i = entity.weapons.elements(); i.hasMoreElements();) {<br/>
               final MountedWeapon w = (MountedWeapon)i.nextElement();<br/>
<br/>
                // first, if a weapon isn't destroyed, it's okay.<br/>
                boolean weaponOK = !w.isDestroyed();<br/>
<br/>
                // does the weapon use ammo?<br/>
                if (weaponOK &amp;&amp; w.getType().getAmmoType() != Ammo.TYPE_NA) {<br/>
                    // try to reload if needed<br/>
                    if (w.getAmmoFeed() == null || w.getAmmoFeed().shots &lt;= 0) {<br/>
                        entity.loadWeapon(w);<br/>
                    }<br/>
                    // if still out of shots, weapon is useless<br/>
                    if (w.getAmmoFeed() == null || w.getAmmoFeed().shots &lt;= 0) {<br/>
                        weaponOK = false;<br/>
                    }<br/>
                }<br/>
<br/>
                // ready it if it's still okay<br/>
                w.setReady(weaponOK);<br/>
            }<br/>
<br/>
            // destroy doomed criticals<br/>
            for (int i = 0; i &lt; entity.locations(); i++) {<br/>
                for (int j = 0; j &lt; entity.getNumberOfCriticals(i); j++) {<br/>
                    final CriticalSlot cs = entity.getCritical(i, j);<br/>
                    if (cs != null) {<br/>
                        cs.setDestroyed(cs.isDestroyed() | cs.isDoomed());<br/>
                    }<br/>
                }<br/>
            }<br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
<br/>
            // reset ready to true<br/>
            entity.ready = entity.isActive();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resets an entity's secondary facing to face forwards<br/>
     */<br/>
    private void resetEntityFacing() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            entity.setSecondaryFacing(entity.getFacing());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayerReady() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setReady(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersReady() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setReady(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
<br/>
        }<br/>
        transmitAllPlayerReadys();<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when a player is "ready".  Handles any moving<br/>
     * to the next turn or phase or that stuff.<br/>
     */<br/>
    private void checkReady() {<br/>
        // are there any active players?<br/>
        boolean allAboard = countActivePlayers() &gt; 0;<br/>
        // check if all active players are ready<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isReady()) {<br/>
                allAboard = false;<br/>
            }<br/>
        }<br/>
        // now, do something about it.<br/>
        switch(game.phase) {<br/>
        case Game.PHASE_LOUNGE :<br/>
        case Game.PHASE_EXCHANGE :<br/>
        case Game.PHASE_INITIATIVE :<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
        case Game.PHASE_END :<br/>
            if (allAboard) {<br/>
                endCurrentPhase();<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            if (!areMoreTurns()) {<br/>
                endCurrentPhase();<br/>
            } else if (getPlayer(game.getTurn()).isReady()) {<br/>
                changeTurn(nextTurn());<br/>
            }<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.phase = phase;<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
<br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
<br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_EXCHANGE :<br/>
            gameSettings.friendlyFire = game.getNoOfPlayers() &lt;= 1;<br/>
            resetPlayerReady();<br/>
            // apply board layout settings to produce a mega-board<br/>
            Board[] sheetBoards = new Board[gameSettings.sheetWidth * gameSettings.sheetHeight];<br/>
            for (int i = 0; i &lt; gameSettings.sheetWidth * gameSettings.sheetHeight; i++) {<br/>
                sheetBoards[i] = new Board();<br/>
                sheetBoards[i].load(getRandomBoard());<br/>
            }<br/>
            game.board.combine(gameSettings.boardWidth, gameSettings.boardHeight,<br/>
                    gameSettings.sheetWidth, gameSettings.sheetHeight, sheetBoards);<br/>
            // deploy all entities<br/>
            Coords center = new Coords(game.board.width / 2, game.board.height / 2);<br/>
            for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
                Entity entity = (Entity)i.nextElement();<br/>
                deploy(entity, getStartingCoords(entity.getOwner().getStartingPos()), center, 10);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_INITIATIVE :<br/>
            // remove the last traces of last round<br/>
            attacks.removeAllElements();<br/>
            roundReport = new StringBuffer();<br/>
            resetEntityPhase();<br/>
            resetEntityRound();<br/>
            // roll 'em<br/>
            resetActivePlayersReady();<br/>
            rollInitiative();<br/>
            setIneligible(phase);<br/>
            determineTurnOrder();<br/>
            writeInitiativeReport();<br/>
            send(createReportPacket());<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
            resetEntityFacing();<br/>
        case Game.PHASE_PHYSICAL :<br/>
            resetEntityPhase();<br/>
            setIneligible(phase);<br/>
            determineTurnOrder();<br/>
            resetActivePlayersReady();<br/>
            send(createEntitiesPacket());<br/>
            phaseReport = new StringBuffer();<br/>
            break;<br/>
        case Game.PHASE_END :<br/>
            phaseReport = new StringBuffer();<br/>
            resetEntityPhase();<br/>
            resolveHeat();<br/>
            checkForSuffocation();<br/>
            resolveCrewDamage();<br/>
            resolveCrewWakeUp();<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
            }<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
            resetActivePlayersReady();<br/>
            send(createReportPacket());<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Should we play this phase or skip it?  The only phases we'll skip<br/>
     * are the firing or the physical phase if no entities are eligible.<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            return areMoreTurns();<br/>
        default :<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_EXCHANGE :<br/>
            // transmit the board to everybody<br/>
            send(createBoardPacket());<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            // set turn<br/>
            ti = 0;<br/>
            changeTurn(nextTurn());<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.phase) {<br/>
        case Game.PHASE_LOUNGE :<br/>
            changePhase(Game.PHASE_EXCHANGE);<br/>
            break;<br/>
        case Game.PHASE_EXCHANGE :<br/>
            changePhase(Game.PHASE_INITIATIVE);<br/>
            break;<br/>
        case Game.PHASE_INITIATIVE :<br/>
            changePhase(Game.PHASE_MOVEMENT);<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
            roundReport.append("\nMovement Phase\n-------------------\n");<br/>
            resolveCrewDamage();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
                changePhase(Game.PHASE_MOVEMENT_REPORT);<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
                changePhase(Game.PHASE_FIRING);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
            changePhase(Game.PHASE_FIRING);<br/>
            break;<br/>
        case Game.PHASE_FIRING :<br/>
            resolveWeaponAttacks();<br/>
            checkFor20Damage();<br/>
            resolveCrewDamage();<br/>
            resolvePilotingRolls();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
                changePhase(Game.PHASE_FIRING_REPORT);<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
                changePhase(Game.PHASE_PHYSICAL);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
            changePhase(Game.PHASE_PHYSICAL);<br/>
            break;<br/>
        case Game.PHASE_PHYSICAL :<br/>
            resolvePhysicalAttacks();<br/>
            checkFor20Damage();<br/>
            resolveCrewDamage();<br/>
            resolvePilotingRolls();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
            }<br/>
            changePhase(Game.PHASE_END);<br/>
            break;<br/>
        case Game.PHASE_END :<br/>
            changePhase(Game.PHASE_INITIATIVE);<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes it to make it the specified player's turn.<br/>
     */<br/>
    private void changeTurn(int turn) {<br/>
        final Player player = getPlayer(game.getTurn());<br/>
<br/>
        game.setTurn(turn);<br/>
        player.setReady(false);<br/>
        send(new Packet(Packet.COMMAND_TURN, new Integer(turn)));<br/>
    }<br/>
<br/>
    /**<br/>
     * Deploys an entity near a selected point on the board.<br/>
     *<br/>
     * @param entity the entity to deploy<br/>
     * @param pos the point to deploy near<br/>
     * @param towards another point that the deployed mechs will face towards<br/>
     */<br/>
    private boolean deploy(Entity entity, Coords pos, Coords towards, int recurse) {<br/>
        if (game.board.contains(pos) &amp;&amp; game.getEntity(pos) == null) {<br/>
            placeEntity(entity, pos, pos.direction(towards));<br/>
            return true;<br/>
        }<br/>
        <br/>
        // if pos is filled, try some different positions<br/>
        for (int j = 0; j &lt; recurse; j++) {<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                Coords deployPos = pos.translated(i);<br/>
                if (deploy(entity, deployPos, towards, j)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Places a mech on the board<br/>
     */<br/>
    private void placeEntity(Entity entity, Coords pos, int facing) {<br/>
        entity.setPosition(pos);<br/>
        entity.setFacing(facing);<br/>
        entity.setSecondaryFacing(facing);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the starting point for the specified player<br/>
     */<br/>
    private Coords getStartingCoords(int startingPos) {<br/>
        switch (startingPos) {<br/>
        default :<br/>
        case 0 :<br/>
            return new Coords(1, 1);<br/>
        case 1 :<br/>
            return new Coords(game.board.width / 2, 1);<br/>
        case 2 :<br/>
            return new Coords(game.board.width - 2, 1);<br/>
        case 3 :<br/>
            return new Coords(game.board.width - 2, game.board.height / 2);<br/>
        case 4 :<br/>
            return new Coords(game.board.width - 2, game.board.height - 2);<br/>
        case 5 :<br/>
            return new Coords(game.board.width / 2, game.board.height - 2);<br/>
        case 6 :<br/>
            return new Coords(1, game.board.height - 2);<br/>
        case 7 :<br/>
            return new Coords(1, game.board.height / 2);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        roundCounter++;<br/>
<br/>
        // roll the dice for each player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.clearInitiative();<br/>
            player.setInitiative(Compute.d6(2), 0);<br/>
        }<br/>
        <br/>
        // roll off initiative ties, up to 5 times<br/>
        // TODO: infinite rerolls<br/>
        for (int i = 0; i &lt; 5; i++) {<br/>
            for (int j = 2; j &lt;= 12; j++) {<br/>
                for (Enumeration k = game.getPlayers(); k.hasMoreElements();) {<br/>
                    final Player player = (Player)k.nextElement();<br/>
                    if (player.getInitiativeSize() &gt; i &amp;&amp; player.getInitiative(i) == j &amp;&amp; isInitTie(j, i)) {<br/>
                        player.setInitiative(Compute.d6(2), i + 1);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
    <br/>
    private boolean isInitTie(int init, int index) {<br/>
        int playersAt = 0;<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (player.getInitiativeSize() &gt; index &amp;&amp; player.getInitiative(index) == init) {<br/>
                playersAt++;<br/>
            }<br/>
        }<br/>
        return playersAt &gt; 1;<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Determine turn order by number of entities that are selectable this phase<br/>
     */<br/>
    private void determineTurnOrder() {<br/>
        // determine turn order<br/>
        int[] order = new int[game.getNoOfPlayers()];<br/>
        int oi = 0;<br/>
        for (int i = 0; i &lt; 5; i++) {<br/>
            for (int j = 2; j &lt;= 12; j++) {<br/>
                for (Enumeration k = game.getPlayers(); k.hasMoreElements();) {<br/>
                    final Player player = (Player)k.nextElement();<br/>
                    if (player.getInitiativeSize() &gt; i &amp;&amp; player.getInitiative(i) == j &amp;&amp; !isInitTie(j, i)) {<br/>
                        order[oi++] = player.getId();<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        // count how many entities each player controls, and how many turns we have to assign<br/>
        int MAX_PLAYERS = 255; //XXX HACK HACK HACK!<br/>
        int[] noe = new int[MAX_PLAYERS];<br/>
        int noOfTurns = 0;<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            if (entity.isSelectable()) {<br/>
                noe[entity.getOwner().getId()]++;<br/>
                noOfTurns++;<br/>
            }<br/>
        }<br/>
<br/>
        // generate turn list<br/>
        turns = new int[noOfTurns];<br/>
        ti = 0;<br/>
        while (ti &lt; turns.length){<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoe = 1;<br/>
            int lnoe = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                    if (noe[i] &gt; 0 &amp;&amp; noe[i] &lt; lnoe) {<br/>
                            lnoe = noe[i];<br/>
                    }<br/>
                    if (noe[i] &gt; hnoe) {<br/>
                            hnoe = noe[i];<br/>
                    }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noe[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                // if you have less than twice the next lowest,<br/>
                // move 1, otherwise, move more.<br/>
                // if you have less than half the maximum,<br/>
                // move none<br/>
                int ntm = Math.max(1, (int)Math.floor(noe[order[i]] / lnoe));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns[ti++] = order[i];<br/>
                    noe[order[i]]--;<br/>
                }<br/>
            }<br/>
        }<br/>
        // reset turn counter<br/>
        ti = 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport() {<br/>
        // write to report<br/>
        roundReport.append("\nInitiative Phase for Round #" + roundCounter<br/>
                           + "\n------------------------------\n");<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            roundReport.append(player.getName() + " rolls a ");<br/>
            boolean first = true;<br/>
            for (Enumeration j = player.getInitiatives(); j.hasMoreElements();) {<br/>
                Integer init = (Integer)j.nextElement();<br/>
                if (first) {<br/>
                    first = false;<br/>
                } else {<br/>
                    roundReport.append(" / ");<br/>
                }<br/>
                roundReport.append(init.toString());<br/>
            }<br/>
            roundReport.append(".\n");<br/>
        }<br/>
        roundReport.append("\nThe turn order is:\n  ");<br/>
        for (int i = 0; i &lt; turns.length; i++) {<br/>
            roundReport.append((i == 0 ? "" : ", ") + getPlayer(turns[i]).getName());<br/>
        }<br/>
        roundReport.append("\n");<br/>
<br/>
        // reset turn index<br/>
        ti = 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            if (!isEligibleFor(entity, phase)) {<br/>
                entity.ready = false;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines if an entity is eligible for a phase.<br/>
     */<br/>
    private boolean isEligibleFor(Entity entity, int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_FIRING :<br/>
            return isEligibleForFiring(entity, phase);<br/>
        case Game.PHASE_PHYSICAL :<br/>
            return isEligibleForPhysical(entity, phase);<br/>
        default:<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * An entity is eligible if its to-hit number is anything but impossible.<br/>
     * This is only really an issue if friendly fire is turned off.<br/>
     */<br/>
    private boolean isEligibleForFiring(Entity entity, int phase) {<br/>
        // if you're charging, no shooting<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Check if the entity has any valid targets for physical attacks.<br/>
     */<br/>
    private boolean isEligibleForPhysical(Entity entity, int phase) {<br/>
        boolean canHit = false;<br/>
        <br/>
        // if you're charging, it's already declared<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity target = (Entity)e.nextElement();<br/>
<br/>
            // don't hit yourself, please<br/>
            if (target.equals(entity)) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // don't hit your own guys with friendly fire<br/>
            if (!gameSettings.friendlyFire<br/>
                &amp;&amp; target.getOwner().equals(entity.getOwner())) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
                                         PunchAttackAction.LEFT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
                                         PunchAttackAction.RIGHT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
                                        KickAttackAction.LEFT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
                                        KickAttackAction.RIGHT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
        }<br/>
<br/>
        return canHit;<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps thru an entity movement packet, executing it.<br/>
     */<br/>
    private void doEntityMovement(Packet c, int cn) {<br/>
        final MovementData md = (MovementData)c.getObject(1);<br/>
        // walk thru data, stopping when the mech is out of movement<br/>
        final Entity entity = game.getEntity(c.getIntValue(0));<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int distance = 0;<br/>
        int moveType = Entity.MOVE_NONE;<br/>
        int overallMoveType = Entity.MOVE_NONE;<br/>
        boolean firstStep;<br/>
<br/>
        Compute.compile(game, entity.getId(), md);<br/>
<br/>
        // get last step's movement type<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            } else {<br/>
                overallMoveType = step.getMovementType();<br/>
            }<br/>
        }<br/>
<br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
<br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
<br/>
            // check piloting skill for getting up<br/>
            if (step.getType() == MovementData.STEP_GET_UP) {<br/>
                entity.setProne(false);<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "getting up"));<br/>
                entity.heatBuildup += 1;<br/>
            } else if (firstStep) {<br/>
                // running with destroyed hip or gyro needs a check<br/>
                if (overallMoveType == Entity.MOVE_RUN<br/>
                        &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                            || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_RLEG) &gt; 0<br/>
                            || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_LLEG) &gt; 0)) {<br/>
                    doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "running with damaged hip actuator or gyro"));<br/>
                }<br/>
                firstStep = false;<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                break;<br/>
            }<br/>
            <br/>
            // check for charge<br/>
            if (step.getType() == MovementData.STEP_CHARGE) {<br/>
                Entity target = game.getEntity(step.getPosition());<br/>
<br/>
                distance = step.getDistance();<br/>
                entity.setCharging(true);<br/>
                <br/>
                pendingCharges.addElement(new ChargeAttackAction(entity.getId(), target.getId(), target.getPosition()));<br/>
                break;<br/>
            }<br/>
<br/>
            // check for dfa<br/>
            if (step.getType() == MovementData.STEP_DFA) {<br/>
                Entity target = game.getEntity(step.getPosition());<br/>
<br/>
                distance = step.getDistance();<br/>
                entity.setMakingDfa(true);<br/>
                <br/>
                pendingCharges.addElement(new DfaAttackAction(entity.getId(), target.getId(), target.getPosition()));<br/>
                break;<br/>
            }<br/>
<br/>
            // step...<br/>
            moveType = step.getMovementType();<br/>
            curPos = step.getPosition();<br/>
            curFacing = step.getFacing();<br/>
            distance = step.getDistance();<br/>
<br/>
            final Hex curHex = game.board.getHex(curPos);<br/>
<br/>
            // check if we've moved into rubble<br/>
            if (!lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
                    &amp;&amp; (curHex.getTerrainType() == Terrain.RUBBLE)) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Rubble"));<br/>
            }<br/>
<br/>
            // check if we've moved into water<br/>
            if (!lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
                    &amp;&amp; curHex.getTerrainType() == Terrain.WATER<br/>
                    &amp;&amp; curHex.getElevation() &lt; 0) {<br/>
                if (curHex.getElevation() == -1) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"));<br/>
                } else if (curHex.getElevation() == -2) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"));<br/>
                } else {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"));<br/>
                }<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                break;<br/>
            }<br/>
<br/>
            // update lastPos<br/>
            lastPos = new Coords(curPos);<br/>
        }<br/>
<br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == Entity.MOVE_JUMP<br/>
                &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, Mech.LOC_LLEG) &gt; 0)) {<br/>
            doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "landing with damaged leg actuator or gyro"));<br/>
        }<br/>
<br/>
        // build up heat from movement<br/>
        if (moveType == Entity.MOVE_WALK) {<br/>
            entity.heatBuildup += 1;<br/>
        } else if (moveType == Entity.MOVE_RUN) {<br/>
            entity.heatBuildup += 2;<br/>
        } else if (moveType == Entity.MOVE_JUMP) {<br/>
            entity.heatBuildup += Math.max(3, distance);<br/>
        }<br/>
<br/>
        entity.ready = false;<br/>
<br/>
        // duhh.. send an outgoing packet to everybody<br/>
        send(createEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the movement phase)<br/>
     */<br/>
    private void doSkillCheckInPlace(Entity entity, PilotingRollData reason) {<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
<br/>
        // append the reason modifier<br/>
        roll.addModifier(reason.getValue(), reason.getDesc());<br/>
<br/>
        // okay, print the info<br/>
        phaseReport.append("\n" + entity.getDisplayName()<br/>
                   + " must make a piloting skill check (" + reason.getDesc() + ")"<br/>
                   + ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " + roll.getValue()<br/>
                   + " (" + roll.getDesc() + ")"<br/>
                   + ", rolls " + diceRoll + " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFall(entity, roll.getValue());<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while moving<br/>
     */<br/>
    private void doSkillCheckWhileMoving(Entity entity, Coords src, Coords dest,<br/>
                                         PilotingRollData reason) {<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        boolean fallsInPlace;<br/>
        int fallElevation;<br/>
<br/>
        // append the reason modifier<br/>
        roll.addModifier(reason.getValue(), reason.getDesc());<br/>
<br/>
        // will the entity fall in the source or destination hex?<br/>
        if (src.equals(dest) || srcHex.getElevation() &lt; destHex.getElevation()) {<br/>
            fallsInPlace = true;<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
        }<br/>
<br/>
        // how far down did it fall?<br/>
        fallElevation = Math.abs(destHex.getElevation() - srcHex.getElevation());<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" + entity.getDisplayName()<br/>
                + " must make a piloting skill check"<br/>
                + " while moving from hex " + src.getBoardNum()<br/>
                + " to hex " + dest.getBoardNum()<br/>
                + " (" + reason.getDesc() + ")" + ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " + roll.getValue()<br/>
                + " (" + roll.getDesc() + ")"<br/>
                + ", rolls " + diceRoll + " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFallsInto(entity, (fallsInPlace ? src : dest), (fallsInPlace ? dest : src), roll.getValue());<br/>
            //doEntityFall(entity, (fallsInPlace ? src : dest), fallElevation, roll.getValue());<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, int roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int fallElevation = Math.abs(destHex.getElevation() - srcHex.getElevation());<br/>
        int direction = src.direction(dest);<br/>
        // check entity in target hex<br/>
        Entity target = game.getEntity(dest);<br/>
        // check if we can fall in that hex<br/>
        if (target != null &amp;&amp; !target.equals(entity)<br/>
            &amp;&amp; !Compute.isValidDisplacement(game, target.getId(), src, dest)) {<br/>
            // if target can't be displaced, fall in source hex.<br/>
            // NOTE: source hex should never contain a non-displacable entity<br/>
            Coords temp = dest;<br/>
            dest = src;<br/>
            src = temp;<br/>
            target = game.getEntity(dest);<br/>
        }<br/>
<br/>
        // falling mech falls<br/>
        phaseReport.append(entity.getDisplayName() + " falls "<br/>
                + fallElevation + " level(s) into hex "<br/>
                + dest.getBoardNum() + ".\n");<br/>
<br/>
        // if hex was empty, deal damage and we're done<br/>
        if (target == null || target.equals(entity)) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
<br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2) {<br/>
            // accidental death from above<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            // target gets displaced<br/>
            doEntityDisplacement(target, dest, dest.translated(direction), new PilotingRollData(target.getId(), 0, "domino effect"));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
                                      PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
        int fallElevation = srcHex.getElevation() - destHex.getElevation();<br/>
        Entity target = game.getEntity(dest);<br/>
<br/>
        // can't fall upwards<br/>
        if (fallElevation &lt; 0) {<br/>
            fallElevation = 0;<br/>
        }<br/>
<br/>
        // if destination is empty, this could be easy...<br/>
        if (target == null || target.equals(entity)) {<br/>
            if (fallElevation &lt; 2) {<br/>
                // no cliff: move and roll normally<br/>
                phaseReport.append(entity.getDisplayName()<br/>
                           + " is displaced into hex "<br/>
                           + dest.getBoardNum() + ".\n");<br/>
                entity.setPosition(dest);<br/>
                if (roll != null) {<br/>
                    pilotRolls.addElement(roll);<br/>
                }<br/>
                return;<br/>
            } else {<br/>
                // cliff: fall off it, deal damage, prone immediately<br/>
                phaseReport.append(entity.getDisplayName() + " falls "<br/>
                           + fallElevation + " levels into hex "<br/>
                           + dest.getBoardNum() + ".\n");<br/>
                doEntityFall(entity, dest, fallElevation, PilotingRollData.AUTOMATIC_FALL);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // okay, destination occupied.  hmmm...<br/>
        System.err.println("server.doEntityDisplacement: destination occupied");<br/>
        if (fallElevation &lt; 2) {<br/>
            // domino effect: move &amp; displace target<br/>
            phaseReport.append(entity.getDisplayName()<br/>
                           + " is displaced into hex "<br/>
                           + dest.getBoardNum() + ", occupied by "<br/>
                           + target.getDisplayName() + ".\n");<br/>
            entity.setPosition(dest);<br/>
            if (roll != null) {<br/>
                pilotRolls.addElement(roll);<br/>
            }<br/>
            doEntityDisplacement(target, dest, dest.translated(direction), new PilotingRollData(target.getId(), 0, "domino effect"));<br/>
            return;<br/>
        } else {<br/>
            // accidental fall from above: havoc!<br/>
            phaseReport.append(entity.getDisplayName() + " falls "<br/>
                           + fallElevation + " levels into hex "<br/>
                           + dest.getBoardNum() + ", occupied by "<br/>
                           + target.getDisplayName() + ".\n");<br/>
<br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "7 (base)");<br/>
            toHit.append(Compute.getTargetMovementModifier(game, target.getId()));<br/>
            toHit.append(Compute.getTargetTerrainModifier(game, target.getId()));<br/>
<br/>
            // roll dice<br/>
            final int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("Collision occurs on a " + toHit.getValue()<br/>
                           + " or greater.  Rolls " + diceRoll);<br/>
            if (diceRoll &gt;= toHit.getValue()) {<br/>
                phaseReport.append(", hits!\n");<br/>
                // deal damage to target<br/>
                int damage = (int)Math.ceil(entity.getWeight() / 10);<br/>
                phaseReport.append(target.getDisplayName() + " takes "<br/>
                                   + damage + " from the collision.");<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                    phaseReport.append(damageEntity(target, hit, cluster));<br/>
                    damage -= cluster;<br/>
                }<br/>
                phaseReport.append("\n");<br/>
<br/>
                // attacker falls as normal, on his back<br/>
                doEntityFall(entity, dest, fallElevation, 3, PilotingRollData.AUTOMATIC_FALL);<br/>
<br/>
                // defender pushed away, or destroyed<br/>
                Coords targetDest = Compute.getValidDisplacement(game, target.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(target, dest, targetDest, new PilotingRollData(target.getId(), 2, "fallen on"));<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append("*** " + target.getDisplayName()<br/>
                                       + " DESTROYED due to impossible displacement! ***");<br/>
                    target.setDoomed(true);<br/>
                }<br/>
            } else {<br/>
                phaseReport.append(", misses.\n");<br/>
                //TODO: this is not quite how the rules go<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.AUTOMATIC_FALL, "pushed off a cliff"));<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append("*** " + entity.getDisplayName()<br/>
                                       + " DESTROYED due to impossible displacement! ***");<br/>
                    entity.setDoomed(true);<br/>
                }<br/>
            }<br/>
            return;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets a bunch of entity actions from the packet<br/>
     */<br/>
    private void receiveAttack(Packet pkt) {<br/>
        Vector vector = (Vector)pkt.getObject(1);<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
<br/>
            // add to the list.<br/>
            attacks.addElement(ea);<br/>
<br/>
            // if torso twist, twist so that everybody can see it later<br/>
            if (ea instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)ea;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
            }<br/>
<br/>
            // send an outgoing packet to everybody<br/>
            send(createAttackPacket(ea));<br/>
        }<br/>
        send(createEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve all fire for the round<br/>
     */<br/>
    private void resolveWeaponAttacks() {<br/>
        roundReport.append("\nWeapon Attack Phase\n-------------------\n");<br/>
<br/>
        int cen = Entity.NONE;<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                resolveWeaponAttack(waa, cen);<br/>
                cen = waa.getEntityId();<br/>
            } else if (o instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)o;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
<br/>
                System.out.println("server.resolveFire: torso twisting "<br/>
                                   + game.getEntity(tta.getEntityId()).getDisplayName()<br/>
                                   + " in direction " + tta.getFacing());<br/>
            } else {<br/>
                // hmm, error<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     */<br/>
    private void resolveWeaponAttack(WeaponAttackAction waa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
        final MountedWeapon w = ae.getWeapon(waa.getWeaponId());<br/>
<br/>
        if (lastEntityId != waa.getEntityId()) {<br/>
            phaseReport.append("\nWeapons fire for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    " + w.getType().getName() + " at "<br/>
                   + te.getDisplayName());<br/>
<br/>
        // check ammo<br/>
        if (w.getAmmoFeed() != null) {<br/>
            if (w.getAmmoFeed().shots == 0) {<br/>
                // try reloading?<br/>
                ae.loadWeapon(w);<br/>
            }<br/>
            if (w.getAmmoFeed().shots == 0) {<br/>
                phaseReport.append(" but the weapon is out of ammo");<br/>
                return;<br/>
            }<br/>
            w.getAmmoFeed().shots--;<br/>
        }<br/>
<br/>
        // build up some heat<br/>
        ae.heatBuildup += w.getType().getHeat();<br/>
<br/>
        // set the weapon as having fired<br/>
        w.setFiredThisRound(true);<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitWeapon(game, waa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        // are we attacks normal weapons or missiles?<br/>
        if (w.getType().getDamage() != Weapon.DAMAGE_MISSILE) {<br/>
            // normal weapon; deal damage<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
            phaseReport.append(damageEntity(te, hit, w.getType().getDamage()));<br/>
        } else {<br/>
            // missiles; determine number of missiles hitting<br/>
            int hits = Compute.missilesHit(w.getType().getRackSize());<br/>
            phaseReport.append(hits + " missiles hit" + toHit.getTableDesc() + ".");<br/>
            // for SRMs, do each missile seperately<br/>
            if (w.getType().getAmmoType() == Ammo.TYPE_SRM) {<br/>
                for (int j = 0; j &lt; hits; j++) {<br/>
                    HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                    phaseReport.append(damageEntity(te, hit, 2));<br/>
                }<br/>
            }<br/>
            // LRMs, do salvos of 5<br/>
                if (w.getType().getAmmoType() == Ammo.TYPE_LRM) {<br/>
                    while (hits &gt; 0) {<br/>
                        int salvo = Math.min(5, hits);<br/>
                        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                        phaseReport.append(damageEntity(te, hit, salvo));<br/>
                        hits -= salvo;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        roundReport.append("\nPhysical Attack Phase\n-------------------\n");<br/>
<br/>
        int cen = Entity.NONE;<br/>
        <br/>
        // add any pending charges<br/>
        for (Enumeration i = pendingCharges.elements(); i.hasMoreElements();) {<br/>
            attacks.addElement(i.nextElement());<br/>
        }<br/>
        pendingCharges.removeAllElements();<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof PunchAttackAction) {<br/>
                PunchAttackAction paa = (PunchAttackAction)o;<br/>
                if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                    paa.setArm(PunchAttackAction.LEFT);<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                    paa.setArm(PunchAttackAction.RIGHT);<br/>
                    resolvePunchAttack(paa, cen);<br/>
                } else {<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof KickAttackAction) {<br/>
                KickAttackAction kaa = (KickAttackAction)o;<br/>
                resolveKickAttack(kaa, cen);<br/>
                cen = kaa.getEntityId();<br/>
            } else if (o instanceof PushAttackAction) {<br/>
                PushAttackAction paa = (PushAttackAction)o;<br/>
                resolvePushAttack(paa, cen);<br/>
                cen = paa.getEntityId();<br/>
            }  else if (o instanceof ChargeAttackAction) {<br/>
                ChargeAttackAction caa = (ChargeAttackAction)o;<br/>
                resolveChargeAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            }  else if (o instanceof DfaAttackAction) {<br/>
                DfaAttackAction daa = (DfaAttackAction)o;<br/>
                resolveDfaAttack(daa, cen);<br/>
                cen = daa.getEntityId();<br/>
            } else {<br/>
                // hmm, error.<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PunchAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
                               ? "Left Arm" : "Right Arm";<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Punch (" +armName + ") at " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPunch(game, paa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getPunchDamageFor(ae, paa.getArm());<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(KickAttackAction kaa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Entity te = game.getEntity(kaa.getTargetId());<br/>
        final String legName = kaa.getLeg() == KickAttackAction.LEFT <br/>
                                ? "Left Leg" <br/>
                                : "Right Leg";<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Kick (" + legName + ") at " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitKick(game, kaa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        <br/>
        int damage = Compute.getKickDamageFor(ae, kaa.getLeg());<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was kicked"));<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PushAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Pushing " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPush(game, paa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            Coords src = te.getPosition();<br/>
            Coords dest = src.translated(direction);<br/>
            phaseReport.append("succeeds: target is pushed into hex "<br/>
                               + dest.getBoardNum()<br/>
                               + "\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
<br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (game.getEntity(src) == null) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            phaseReport.append("succeeds, but target can't be moved.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
        }<br/>
<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(ChargeAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Charging " + te.getDisplayName());<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setCharging(false);<br/>
<br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(caa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitCharge(game, caa);<br/>
<br/>
        // hack: if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne()) {<br/>
            roll = -12;<br/>
            phaseReport.append("; but the attaker is prone : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
            phaseReport.append("rolls " + roll + " : ");<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getChargeDamageFor(ae);<br/>
        int damageTaken = Compute.getChargeDamageTakenBy(ae, te);<br/>
<br/>
        phaseReport.append("hits.");<br/>
        phaseReport.append("\n  Defender takes " + damage + " damage" + toHit.getTableDesc() + ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " + damageTaken + " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            Coords src = te.getPosition();<br/>
            Coords dest = src.translated(direction);<br/>
            <br/>
            phaseReport.append("\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, new PilotingRollData(ae.getId(), 2, "charging"));<br/>
        } else {<br/>
            // they stil have to roll<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 2, "charging"));<br/>
        }<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveDfaAttack(DfaAttackAction daa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Entity te = game.getEntity(daa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Attempting death from above on " + te.getDisplayName());<br/>
<br/>
        // entity isn't charging any more<br/>
        ae.setMakingDfa(false);<br/>
<br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(daa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitDfa(game, daa);<br/>
<br/>
        // hack: if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne()) {<br/>
            roll = -12;<br/>
            phaseReport.append("; but the attacker is prone : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
            phaseReport.append("rolls " + roll + " : ");<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            if (targetDest != null) {<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, src, targetDest, null);<br/>
                // attacker falls into destination hex<br/>
                phaseReport.append(ae.getDisplayName() + " falls into hex " + dest.getBoardNum() + ".\n");<br/>
                doEntityFall(ae, dest, 2, 3, PilotingRollData.AUTOMATIC_FALL);<br/>
            } else {<br/>
                // attacker destroyed<br/>
                phaseReport.append("*** " + ae.getDisplayName()<br/>
                                   + " DESTROYED due to impossible displacement! ***");<br/>
                ae.setDoomed(true);<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getDfaDamageFor(ae);<br/>
        int damageTaken = Compute.getDfaDamageTakenBy(ae);<br/>
<br/>
        phaseReport.append("hits.");<br/>
<br/>
        phaseReport.append("\n  Defender takes " + damage + " damage" + toHit.getTableDesc() + ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " + damageTaken + " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = te.rollHitLocation(ToHitData.HIT_KICK, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        phaseReport.append("\n");<br/>
        <br/>
        // defender pushed away or destroyed<br/>
        Coords src = ae.getPosition();<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (targetDest != null) {<br/>
            doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
        } else {<br/>
            // ack!  automatic death!<br/>
            phaseReport.append("*** " + te.getDisplayName()<br/>
                               + " DESTROYED due to impossible displacement! ***");<br/>
            te.setDoomed(true);<br/>
        }<br/>
        doEntityDisplacement(ae, src, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
<br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        roundReport.append("\nHeat Phase\n----------\n");<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
<br/>
            // should we even bother?<br/>
            if (entity.isDestroyed() || entity.isDoomed() || entity.crew.isDead()) {<br/>
                continue;<br/>
            }<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            if (!entity.isShutDown()) {<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
            }<br/>
<br/>
            // add the heat we've built up so far.<br/>
            roundReport.append(entity.getDisplayName() + " gains " + entity.heatBuildup + " heat,");<br/>
            entity.heat += entity.heatBuildup;<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = Math.min(entity.getHeatCapacityWithWater(game), entity.heat);<br/>
<br/>
            entity.heat -= tosink;<br/>
            roundReport.append(" sinks " + tosink + " heat and is now at " + entity.heat + " heat.\n");<br/>
<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; 30 &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    entity.setShutDown(false);<br/>
                    roundReport.append(entity.getDisplayName() + " automatically starts up.\n");<br/>
                } else {<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int suroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() + " needs a " + startup + "+ to start up, rolls " + suroll + " : ");<br/>
                    if (suroll &gt;= startup) {<br/>
                        entity.setShutDown(false);<br/>
                        roundReport.append("successful!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails.\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            if (entity.heat &gt;= 14 &amp;&amp; entity.isActive()) {<br/>
                if (entity.heat &gt;= 30) {<br/>
                    roundReport.append(entity.getDisplayName() + " automatically shuts down.\n");<br/>
                    // add a piloting roll and resolve immediately<br/>
                    pilotRolls.addElement(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int sdroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() + " needs a " + shutdown + "+ to avoid shutdown, rolls " + sdroll + " : ");<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("shuts down.\n");<br/>
                        // add a piloting roll and resolve immediately<br/>
                        pilotRolls.addElement(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) + (entity.heat &gt;= 28 ? 2 : 0);<br/>
                int boomroll = Compute.d6(2);<br/>
                roundReport.append(entity.getDisplayName() + " needs a " + boom + "+ to avoid ammo explosion, rolls " + boomroll + " : ");<br/>
                if (boomroll &gt;= boom) {<br/>
                    roundReport.append("avoids successfully!\n");<br/>
                } else {<br/>
                    roundReport.append("fails to avoid explosion.\n");<br/>
                    roundReport.append(explodeAmmo(entity));<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: mechwarrior damage<br/>
            if (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0<br/>
                &amp;&amp; entity.heat &gt;= 15) {<br/>
                if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    roundReport.append(entity.getDisplayName() + " has 25 or higher heat and damaged life support.  Mechwarrior takes 2 damage.\n");<br/>
                    damageCrew(entity, 2);<br/>
                } else {<br/>
                    // mechwarrior takes 1 damage<br/>
                    roundReport.append(entity.getDisplayName() + " has 15 or higher heat and damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                    damageCrew(entity, 1);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a piloting<br/>
     * skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            // if this mech has 20+ damage, add another roll to the list.<br/>
            if (entity.damageThisPhase &gt;= 20) {<br/>
                pilotRolls.addElement(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if (curHex.getTerrainType() == Terrain.WATER<br/>
                    &amp;&amp; (curHex.getElevation() &lt;= -2<br/>
                        || (curHex.getElevation() == -1 &amp;&amp; entity.isProne()))<br/>
                    &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                roundReport.append("\n" + entity.getDisplayName() + " is underwater with damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * (used at end of weapons, physical phases)<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.isProne() || entity.isDoomed() || entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            int rolls = 0;<br/>
            StringBuffer reasons = new StringBuffer();<br/>
            PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
            for (Enumeration j = pilotRolls.elements(); j.hasMoreElements();) {<br/>
                final PilotingRollData modifier = (PilotingRollData)j.nextElement();<br/>
                if (modifier.getEntityId() == entity.getId()) {<br/>
                    rolls++;<br/>
                    if (reasons.length() &gt; 0) {<br/>
                        reasons.append(", ");<br/>
                    }<br/>
                    reasons.append(modifier.getDesc());<br/>
                    roll.addModifier(modifier.getValue(), modifier.getDesc());<br/>
                }<br/>
            }<br/>
            // any rolls needed?<br/>
            if (rolls == 0) {<br/>
                continue;<br/>
            }<br/>
            if (roll.getValue() == PilotingRollData.AUTOMATIC_FALL) {<br/>
                phaseReport.append("\n" + entity.getDisplayName() + " must make " + rolls + " piloting skill roll(s) and automatically fails (" + roll.getDesc() + ").\n");<br/>
                doEntityFall(entity, roll.getValue());<br/>
            } else {<br/>
                phaseReport.append("\n" + entity.getDisplayName() + " must make " + rolls + " piloting skill roll(s) (" + reasons + ").\n");<br/>
                phaseReport.append("The target is " + roll.getValue() + " [" + roll.getDesc() + "].\n");<br/>
                for (int j = 0; j &lt; rolls; j++) {<br/>
                    final int diceRoll = Compute.d6(2);<br/>
                    phaseReport.append("    " + entity.getDisplayName() + " needs " + roll.getValue() + ", rolls " + diceRoll + " : ");<br/>
                    phaseReport.append((diceRoll &gt;= roll.getValue() ? "remains standing" : "falls") + ".\n");<br/>
                    if (diceRoll &lt; roll.getValue()) {<br/>
                        doEntityFall(entity, roll.getValue());<br/>
                        // break rolling loop<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        pilotRolls.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     */<br/>
    private String damageCrew(Entity en, int damage) {<br/>
        String s = new String();<br/>
<br/>
        if (!en.crew.isDead()) {<br/>
            en.crew.setHits(en.crew.getHits() + damage);<br/>
            s += "        Pilot of " + en.getDisplayName() + " \"" + en.crew.getName() + "\" takes " + damage + " damage.";<br/>
            if (en.crew.getHits() &lt; 6) {<br/>
                en.crew.setRollsNeeded(en.crew.getRollsNeeded() + damage);<br/>
            } else {<br/>
                en.crew.setDead(true);<br/>
                en.crew.setRollsNeeded(0);<br/>
                s += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
            }<br/>
        }<br/>
<br/>
        return s;<br/>
    }<br/>
<br/>
    /**<br/>
     * This checks if the mech pilot goes unconcious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
            e.crew.setRollsNeeded(0);<br/>
<br/>
            if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            for (int j = 0; j &lt; e.crew.getRollsNeeded(); j++) {<br/>
                int roll = Compute.d6(2);<br/>
                phaseReport.append("\nPilot of " + e.getDisplayName()<br/>
                   + " \"" + e.getCrew().getName() + "\""<br/>
                   + " needs a " + e.getCrew().getConciousnessNumber()<br/>
                   + " to stay concious.  Rolls " + roll + " : ");<br/>
                if (roll &gt;= e.crew.getConciousnessNumber()) {<br/>
                    phaseReport.append("successful!");<br/>
                } else {<br/>
                    e.crew.setUnconcious(true);<br/>
                    e.crew.setKoThisRound(true);<br/>
                    phaseReport.append("blacks out.");<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            phaseReport.append("\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Make the rolls indicating whether any unconcious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
<br/>
            if (!e.isTargetable() || !e.crew.isUnconcious() || e.crew.isKoThisRound()) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            int roll = Compute.d6(2);<br/>
            roundReport.append("\nPilot of " + e.getDisplayName() + " \"" + e.crew.getName() + "\" needs a " + e.crew.getConciousnessNumber() + " to regain conciousness.  Rolls " + roll + " : ");<br/>
            if (roll &gt;= e.crew.getConciousnessNumber()) {<br/>
                roundReport.append("successful!");<br/>
                e.crew.setUnconcious(false);<br/>
            } else {<br/>
                roundReport.append("fails.");<br/>
                break;<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            roundReport.append("\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Deals the listed damage to a mech.  Returns a description<br/>
     * string for the log.<br/>
     *<br/>
     * Currently mech only.<br/>
     */<br/>
    private String damageEntity(Entity te, HitData hit, int damage) {<br/>
        String desc = new String();<br/>
<br/>
        int crits = hit.effect == HitData.EFFECT_CRITICAL ? 1 : 0;<br/>
<br/>
        int loc = hit.loc, nextLoc = Entity.LOC_NONE;<br/>
        while (damage &gt; 0 &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed()) {<br/>
            // let's resolve some damage!<br/>
            <span class="del"><span class="del"><span class="mv">desc</span> += <span class="del"><span class="mv">"\n        "</span> + <span class="mv">te.getDisplayName()</span> + <span class="mv">" takes "</span> + <span class="mv">damage</span> + <span class="mv">" damage to "</span> + <span class="mv">te.getLocationAbbr(loc)</span> + <span class="mv">"."</span></span></span>;</span><br/>
            te.damageThisPhase += damage;<br/>
<br/>
            // is there armor in the location hit?<br/>
            if (te.getArmor(loc) &gt; 0) {<br/>
                if (te.getArmor(loc) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(loc) - damage, loc);<br/>
                    damage = 0;<br/>
                    desc += " " + te.getArmor(loc) + " Armor remaining";<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    damage -= te.getArmor(loc);<br/>
                    te.setArmor(Entity.ARMOR_DESTROYED, loc);<br/>
                    desc += " Armor destroyed,";<br/>
                }<br/>
            }<br/>
<br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(loc) &gt; 0) {<br/>
                    // triggers a critical hit<br/>
                    crits++;<br/>
                    if (te.getInternal(loc) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(loc) - damage, loc);<br/>
                        damage = 0;<br/>
                        desc += " " + te.getInternal(loc) + " Internal Structure remaining";<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        damage -= te.getInternal(loc);<br/>
                        te.setInternal(Entity.ARMOR_DESTROYED, loc);<br/>
                        desc += " &lt;&lt;&lt;SECTION DESTROYED&gt;&gt;&gt;,";<br/>
                    }<br/>
                }<br/>
<br/>
                // is the internal structure gone?<br/>
                if (te.isLocationDestroyed(loc)) {<br/>
                    destroyLocation(te, loc);<br/>
                    if (loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
                        pilotRolls.addElement(new PilotingRollData(te.getId(),<br/>
                        PilotingRollData.AUTOMATIC_FALL, "leg destroyed"));<br/>
                    }<br/>
                    if (te.getTransferLocation(loc) == Entity.LOC_DESTROYED) {<br/>
                        // entity destroyed.<br/>
                        desc += " Entity destroyed!\n";<br/>
                        desc += "*** " + te.getDisplayName() + " DESTROYED! ***";<br/>
                        te.setDoomed(true);<br/>
                        // no need for further damage<br/>
                        damage = 0;<br/>
                        crits = 0;<br/>
                    } else {<br/>
                        // remaining damage transfers<br/>
                        nextLoc = te.getTransferLocation(loc);<br/>
                        desc += " " + damage + " damage transfers to "<br/>
                            + te.getLocationAbbr(nextLoc) + ";";<br/>
                    }<br/>
                }<br/>
            }<br/>
            // roll all critical hits against this location<br/>
            for (int i = 0; i &lt; crits; i++) {<br/>
                desc += "\n" + criticalEntity(te, loc);<br/>
            }<br/>
            crits = 0;<br/>
<br/>
            if (loc == Mech.LOC_HEAD) {<br/>
                desc += "\n" + damageCrew(te, 1);<br/>
            }<br/>
<br/>
            // loop to next location<br/>
            loc = nextLoc;<br/>
        }<br/>
<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits<br/>
     *<br/>
     * Currently mech only<br/>
     */<br/>
    private String criticalEntity(Entity en, int loc) {<br/>
        if (en.isRearLocation(loc)) {<br/>
            loc = en.getFrontLocation(loc);<br/>
        }<br/>
        String desc = "        Critical hit on " + en.getLocationAbbr(loc) + ". ";<br/>
        int hits = 0;<br/>
        int roll = Compute.d6(2);<br/>
        desc += "Roll = " + roll + ";";<br/>
        if (roll &lt;= 7) {<br/>
                desc += " no effect.";<br/>
                return desc;<br/>
        } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
                hits = 1;<br/>
                desc += " 1 location.";<br/>
        } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
                hits = 2;<br/>
                desc += " 2 locations.";<br/>
        } else if (roll == 12) {<br/>
            if (loc == Mech.LOC_HEAD ||<br/>
                    loc == Mech.LOC_RARM || loc == Mech.LOC_LARM ||<br/>
                    loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                if (loc == Mech.LOC_HEAD) {<br/>
                    en.crew.setDead(true);<br/>
                    desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                }<br/>
                return desc;<br/>
            }<br/>
            hits = 3;<br/>
            desc += " 3 locations.";<br/>
        }<br/>
        // transfer criticals, if needed<br/>
        if (hits &gt; 0 &amp;&amp; en.getHitableCriticals(loc) &lt;= 0<br/>
                &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_DESTROYED) {<br/>
            loc = en.getTransferLocation(loc);<br/>
            desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
        }<br/>
        // roll criticals<br/>
        while (hits &gt; 0) {<br/>
            if (en.getHitableCriticals(loc) &lt;= 0) {<br/>
                desc += "\n            Location empty.";<br/>
                break;<br/>
            }<br/>
            int slot = (int)(Compute.random.nextDouble() * en.getNumberOfCriticals(loc));<br/>
            CriticalSlot cs = en.getCritical(loc, slot);<br/>
            if (cs != null &amp;&amp; !cs.isHit()) {<br/>
                cs.setDoomed(true);<br/>
                en.setCritical(loc, slot, cs);<br/>
                switch(cs.getType()) {<br/>
                case CriticalSlot.TYPE_SYSTEM :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + Mech.systemNames[cs.getIndex()] + ".";<br/>
                    switch(cs.getIndex()) {<br/>
                    case Mech.SYSTEM_COCKPIT :<br/>
                        // boink!<br/>
                        en.crew.setDead(true);<br/>
                        desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                        break;<br/>
                    case Mech.SYSTEM_ENGINE :<br/>
                        if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, loc) &gt; 2) {<br/>
                            // third engine hit<br/>
                            en.setDoomed(true);<br/>
                            desc += "\n*** " + en.getDisplayName() + "ENGINE DESTROYED! ***";<br/>
                        }<br/>
                        break;<br/>
                    case Mech.SYSTEM_GYRO :<br/>
                        if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                            // gyro destroyed<br/>
                            pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FALL, "gyro destroyed"));<br/>
                        } else {<br/>
                            // first gyro hit<br/>
                            pilotRolls.addElement(new PilotingRollData(en.getId(), 3, "gyro hit"));<br/>
                        }<br/>
                        break;<br/>
                    case Mech.ACTUATOR_UPPER_LEG :<br/>
                    case Mech.ACTUATOR_LOWER_LEG :<br/>
                    case Mech.ACTUATOR_FOOT :<br/>
                        // leg/foot actuator piloting roll<br/>
                        pilotRolls.addElement(new PilotingRollData(en.getId(), 1, "leg/foot actuator hit"));<br/>
                        break;<br/>
                    case Mech.ACTUATOR_HIP :<br/>
                        // hip piloting roll<br/>
                        pilotRolls.addElement(new PilotingRollData(en.getId(), 2, "hip actuator hit"));<br/>
                        break;<br/>
                    }<br/>
                    break;<br/>
                case CriticalSlot.TYPE_WEAPON :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + en.getWeapon(cs.getIndex()).getType().getName() + ".";<br/>
                    en.getWeapon(cs.getIndex()).setDestroyed(true);<br/>
                    break;<br/>
                case CriticalSlot.TYPE_AMMO :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + en.getAmmo(cs.getIndex()).getName() + ".";<br/>
                    en.getWeapon(cs.getIndex()).setDestroyed(true);<br/>
                    desc += explodeAmmo(en, loc, slot);<br/>
                    break;<br/>
                }<br/>
                hits--;<br/>
                //System.err.println("s: critical loop, " + hits + " remaining");<br/>
            }<br/>
        }<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    private void destroyLocation(Entity en, int loc) {<br/>
        // mark armor, internal as destroyed<br/>
        en.setArmor(Entity.ARMOR_DESTROYED, loc);<br/>
        en.setInternal(Entity.ARMOR_DESTROYED, loc);<br/>
        if (en.getRearLocation(loc) != loc) {<br/>
            en.setArmor(Entity.ARMOR_DESTROYED, en.getRearLocation(loc));<br/>
        }<br/>
        // weapons destroyed<br/>
        for (int i = 0; i &lt; en.weapons.size(); i++) {<br/>
            if (en.getWeapon(i).getLocation() == loc) {<br/>
                en.getWeapon(i).setDestroyed(true);<br/>
            }<br/>
        }<br/>
        // ammo destroyed<br/>
        for (int i = 0; i &lt; en.ammo.size(); i++) {<br/>
            if (en.getAmmo(i).location == loc) {<br/>
                en.getAmmo(i).exploded = true;<br/>
            }<br/>
        }<br/>
        // all critical slots destroyed<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                cs.setDoomed(true);<br/>
            }<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Entity.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Explodes the ammo in the specified location and slot.<br/>
     */<br/>
    private String explodeAmmo(Entity en, int loc, int slot) {<br/>
        String desc = "";<br/>
        if (en.getCritical(loc, slot).getType() != CriticalSlot.TYPE_AMMO) {<br/>
            System.err.println("server: explodeAmmo called on non-ammo"<br/>
                               + " crititical slot (" + loc + " , " + slot + ")");<br/>
            return "";<br/>
        }<br/>
        // check amount of damage<br/>
        Ammo ammo = en.getAmmo(en.getCritical(loc, slot).getIndex());<br/>
        if (ammo.exploded) {<br/>
            System.err.println("server: explodeAmmo called already exploded ammo"<br/>
                               + " crititical slot (" + loc + " , " + slot + ")");<br/>
            return "";<br/>
        }<br/>
        int damage = ammo.damagePerShot * ammo.rackSize * ammo.shots;<br/>
        if (damage &lt;= 0) {<br/>
            return "";<br/>
        }<br/>
        // if there is damage, it's probably a lot<br/>
        desc += "\n*** AMMO EXPLOSION!  " + damage + " DAMAGE! ***";<br/>
        ammo.exploded = true;<br/>
        <span class="del"><span class="del"><span class="mv">desc</span> += <span class="del"><span class="del"><span class="mv">damageEntity</span>(<span class="mv">en</span>, <span class="del">new <span class="del"><span class="mv">HitData</span></span>(<span class="mv">loc</span>)</span>, <span class="mv">damage</span>)</span> + <span class="mv">"\n\n"</span></span></span>;</span><br/>
        // if the mech survives, the pilot takes damage<br/>
        if (!en.isDoomed() &amp;&amp; !en.isDestroyed()) {<br/>
            desc += damageCrew(en, 2) + "\n";<br/>
        }<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeAmmo(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                    if (cs != null &amp;&amp; !cs.isDestroyed()<br/>
                        &amp;&amp; cs.getType() == CriticalSlot.TYPE_AMMO) {<br/>
                      Ammo a = entity.getAmmo(cs.getIndex());<br/>
                      if (!a.exploded &amp;&amp; (rack &lt; a.damagePerShot * a.rackSize<br/>
                            || damage &lt; a.damagePerShot * a.rackSize * a.shots)) {<br/>
                            rack = a.damagePerShot * a.rackSize;<br/>
                            damage = a.damagePerShot * a.rackSize * a.shots;<br/>
                            boomloc = j;<br/>
                            boomslot = k;<br/>
                      }<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            return explodeAmmo(entity, boomloc, boomslot);<br/>
        } else {<br/>
            return "  Luckily, there is no ammo to explode.\n";<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height,<br/>
        int facing, int roll) {<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            phaseReport.append("But, since the 'mech is making a death from above attack, damage will be dealt during the physical phase.\n");<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }            <br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
        case 1:<br/>
        case 2:<br/>
            side = "right side";<br/>
            table = ToHitData.SIDE_RIGHT;<br/>
            break;<br/>
        case 3:<br/>
            side = "rear";<br/>
            table = ToHitData.SIDE_REAR;<br/>
            break;<br/>
        case 4:<br/>
        case 5:<br/>
            side = "left side";<br/>
            table = ToHitData.SIDE_LEFT;<br/>
            break;<br/>
        case 0:<br/>
        default:<br/>
            side = "front";<br/>
            table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        // calculate damage<br/>
        int damage = (int)Math.round(entity.getWeight() / 10) * (height + 1);<br/>
        <br/>
        // TODO: only fall to surface of water<br/>
        if (game.board.getHex(fallPos).getTerrainType() == Terrain.WATER) {<br/>
            damage = (int)Math.ceil(damage / 2.0);<br/>
        }<br/>
<br/>
        // report falling<br/>
        phaseReport.append("    " + entity.getDisplayName() + " falls on its " + side + ", suffering " + damage + " damage.");<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            <span class="mv">HitData</span> <span class="mv">hit</span> = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            phaseReport.append(damageEntity(entity, <span class="mv">hit</span>, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
<br/>
        // pilot damage?<br/>
        if (roll != PilotingRollData.AUTOMATIC_FALL) {<br/>
            roll += height;<br/>
        }<br/>
        if (roll &gt; 12) {<br/>
            phaseReport.append("\nPilot of " + entity.getDisplayName() + " \"" + entity.crew.getName() + "\" cannot avoid damage.\n");<br/>
            damageCrew(entity, 1);<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("\nPilot of " + entity.getDisplayName() + " \"" + entity.crew.getName() + "\" must roll " + roll + " to avoid damage; rolls " + diceRoll + " : " + (diceRoll &gt;= roll ? "succeeds" : "fails") + ".\n");<br/>
            if (diceRoll &lt; roll) {<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
<br/>
        entity.setProne(true);<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height,<br/>
                          int roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, int roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a random board filename<br/>
     *<br/>
     * TODO: make this search the boards directory for boards of the correct size<br/>
     */<br/>
    private String getRandomBoard() {<br/>
        String[] boards = {"battletech.board", "citytech.board",<br/>
                           "deepcanyon1.board", "deepcanyon2.board",<br/>
                           "deserthills.board",<br/>
                           "desertmountain1.board", "desertmountain2.board",<br/>
                           "heavyforest1.board", "heavyforest2.board",<br/>
                           "lakearea.board",<br/>
                           "largelakes1.board", "largelakes2.board",<br/>
                           "openterrain1.board", "openterrain2.board",<br/>
                           "rivervalley.board",<br/>
                           "rollinghills1.board", "rollinghills2.board",<br/>
                           "scatteredwoods.board",<br/>
                           "woodland.board"};<br/>
<br/>
        return boards[(int)(Compute.random.nextDouble() * boards.length)];<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Sets an entity ready status to false<br/>
     */<br/>
    private void receiveEntityReady(Packet pkt, int connIndex) {<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)<br/>
            &amp;&amp; game.getTurn() == connIndex) {<br/>
            entity.ready = false;<br/>
        } else {<br/>
            System.out.println("server.receiveEntityReady: got an invalid ready message");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
      * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
      */<br/>
     private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
<br/>
        entity.restore();<br/>
        entity.setOwner(getPlayer(connIndex));<br/>
        entity.setId(entityCounter++);<br/>
        game.addEntity(entity.getId(), entity);<br/>
<br/>
        send(createEntitiesPacket());<br/>
     }<br/>
<br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int enum = c.getIntValue(0);<br/>
        Entity entity = game.getEntity(enum);<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)) {<br/>
            game.removeEntity(enum);<br/>
            send(createEntitiesPacket());<br/>
        } else {<br/>
            // hey! that's not your entity<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerReady(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        // don't let them enter the game with no entities<br/>
        if (ready &amp;&amp; game.phase == Game.PHASE_LOUNGE<br/>
            &amp;&amp; game.getEntitiesOwnedBy(getPlayer(connIndex)) &lt; 1) {<br/>
            ready = false;<br/>
        }<br/>
        getPlayer(connIndex).setReady(ready);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerReadys() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerReadyPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerReadyPacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isReady());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, gameSettings);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.board);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet containing the round report<br/>
     */<br/>
    private Packet createReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORT, roundReport.toString());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChatToAll(String origin, String message) {<br/>
        send(new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(EntityAction ea) {<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, ea);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
    for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
        final Connection conn = (Connection)i.nextElement();<br/>
            conn.connSend(packet);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        getClient(connId).connSend(packet);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        getPendingConnection(connId).connSend(packet);<br/>
    }<br/>
<br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
<br/>
                int id = connectionCounter++;<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
<br/>
                connectionsPending.addElement(new Connection(s, id));<br/>
<br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
                ;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
    * Listens for player messages and calls the appropriate<br/>
    * server functions.<br/>
    */<br/>
    class Connection implements Runnable {<br/>
        public Socket     socket;<br/>
        //public Player     player;<br/>
<br/>
        public int                id;<br/>
<br/>
        public Thread            receiver;<br/>
<br/>
<br/>
        public Connection(Socket socket, int id) {<br/>
            this.socket = socket;<br/>
            this.id = id;<br/>
<br/>
            // start pump thread<br/>
            receiver = new Thread(this);<br/>
            receiver.start();<br/>
        }<br/>
<br/>
        public int getId() {<br/>
            return id;<br/>
        }<br/>
<br/>
        /**<br/>
         * Kill off the thread<br/>
         */<br/>
        public void die() {<br/>
            receiver = null;<br/>
        }<br/>
<br/>
<br/>
        /**<br/>
         * Allow the player to set whatever parameters he is able to<br/>
         */<br/>
        private void receivePlayerInfo(Packet c) {<br/>
            Player player = (Player)c.getObject(0);<br/>
            game.getPlayer(id).setColorIndex(player.getColorIndex());<br/>
            game.getPlayer(id).setStartingPos(player.getStartingPos());<br/>
        }<br/>
<br/>
        /**<br/>
         * Reads a complete net command from the given socket<br/>
         */<br/>
        private Packet readCommand() {<br/>
            try {<br/>
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());<br/>
                Packet packet = (Packet)ois.readObject();<br/>
                return packet;<br/>
            } catch (IOException ex) {<br/>
                System.err.println("s(" + id + "): IO error reading command");<br/>
                disconnected(id);<br/>
                return null;<br/>
            } catch (ClassNotFoundException ex) {<br/>
                System.err.println("s(" + id + "): curPosass not found error reading command");<br/>
                disconnected(id);<br/>
                return null;<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Sends a packet!<br/>
         *<br/>
         * synchronized seems to keep this from getting munged.<br/>
         */<br/>
        public synchronized void connSend(Packet packet) {<br/>
            try {<br/>
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());<br/>
                oos.flush();<br/>
                oos.writeObject(packet);<br/>
                oos.flush();<br/>
                //System.out.println("s(" + cn + "): command #" + c.getCommand() + " sent");<br/>
            } catch(IOException ex) {<br/>
                System.err.println("s(" + id + "): error sending command.  dropping player");<br/>
                System.err.println(ex);<br/>
                System.err.println(ex.getMessage());<br/>
                disconnected(id);<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Process a packet<br/>
         */<br/>
        private void handle(Packet c) {<br/>
            //System.out.println("s(" + cn + "): received command");<br/>
            // act on it<br/>
            switch(c.getCommand()) {<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receiveClientName(c, id);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(c);<br/>
                validatePlayerInfo(id);<br/>
                send(createPlayerUpdatePacket(id));<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_READY :<br/>
                receiveEntityReady(c, id);<br/>
                send(createEntityPacket(c.getIntValue(0)));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerReady(c, id);<br/>
                send(createPlayerReadyPacket(id));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)c.getObject(0);<br/>
                sendChatToAll(getPlayer(id).getName(), chat);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                doEntityMovement(c, id);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(c);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(c, id);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(c, id);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                gameSettings = (GameSettings)c.getObject(0);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                send(createSettingsPacket());<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
<br/>
        /**<br/>
         * listen for packets &amp; handle them<br/>
         */<br/>
        public void run() {<br/>
            while (receiver == Thread.currentThread()) {<br/>
                handle(readCommand());<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_Server_1.21.java</h1>
<div class="code">
<div class="id">
/**<br/>
 * MegaMek - Copyright (C) 2000-2002 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.net.*;<br/>
import java.io.*;<br/>
import java.util.*;<br/>
<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server<br/>
    implements Runnable<br/>
{<br/>
    // server setup<br/>
    private String              name;<br/>
    private ServerSocket        serverSocket;<br/>
<br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
<br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
<br/>
    private Game                game = new Game();<br/>
<br/>
    // list of turns and whose turn it is<br/>
    private int                 roundCounter = 0;<br/>
    private int[]               turns;<br/>
    private int                 ti;<br/>
<br/>
    // stuff for the current turn<br/>
    private GameSettings        gameSettings = new GameSettings();<br/>
    private Vector              attacks = new Vector();<br/>
    private Vector              pendingCharges = new Vector();<br/>
    private Vector              pilotRolls = new Vector();<br/>
<br/>
    private StringBuffer        roundReport = new StringBuffer();<br/>
    private StringBuffer        phaseReport = new StringBuffer();<br/>
<br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
<br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     */<br/>
    public Server(String name, int port) {<br/>
        this.name = name;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port " + port);<br/>
        }<br/>
<br/>
        game.phase = Game.PHASE_LOUNGE;<br/>
<br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
        System.out.println("s: address = " + serverSocket.getInetAddress().getHostAddress() + " port = " + serverSocket.getLocalPort());<br/>
<br/>
        connector = new Thread(this);<br/>
        connector.start();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sent when a clients attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server info -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_NAME, name));<br/>
    }<br/>
<br/>
    /**<br/>
     * Recieves a client name, sent from a pending connection as a signal to<br/>
     * connect.<br/>
     */<br/>
    private void receiveClientName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
<br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending connection");<br/>
            return;<br/>
        }<br/>
<br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
<br/>
        // add and validate the player info<br/>
        game.addPlayer(connId, new Player(connId, (String)packet.getObject(0)));<br/>
        validatePlayerInfo(connId);<br/>
<br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
<br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
<br/>
        // send current game info<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(connId, createSettingsPacket());<br/>
        send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(game.phase)));<br/>
        send(connId, createEntitiesPacket());<br/>
<br/>
        System.out.println("s: player " + connId<br/>
                           + " (" + getPlayer(connId).getName() + ") connected from "<br/>
                           + getClient(connId).socket.getInetAddress());<br/>
        sendChatToAll("***Server", getPlayer(connId).getName() + " connected from "<br/>
                           + getClient(connId).socket.getInetAddress());<br/>
    }<br/>
<br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        //TODO: remove unsavory characters from the name<br/>
        //TODO: check for duplicate or reserved names<br/>
<br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (player.getId() != playerId) {<br/>
                colorUsed[player.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (colorUsed[getPlayer(playerId).getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    getPlayer(playerId).setColorIndex(i);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when it is sensed that a connection has terminated.<br/>
     */<br/>
    private void disconnected(int connId) {<br/>
        final Connection conn = getClient(connId);<br/>
        final Player player = getPlayer(connId);<br/>
<br/>
        conn.die();<br/>
<br/>
        connections.removeElement(conn);<br/>
        connectionIds.remove(new Integer(connId));<br/>
<br/>
        // in the lounge, just remove all entities for that player<br/>
        if (game.phase == Game.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
<br/>
        // if a player has active entities, he becomes a ghost<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0) {<br/>
            player.setGhost(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE, new Integer(player.getId())));<br/>
        }<br/>
<br/>
        System.out.println("s: player " + connId + " disconnected");<br/>
        sendChatToAll("***Server", player.getName() + " disconnected.");<br/>
    }<br/>
<br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
<br/>
    /**<br/>
     * Counts up how many non-ghost, non-observer players are connected.<br/>
     */<br/>
        private int countActivePlayers() {<br/>
        int count = 0;<br/>
<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver()) {<br/>
                count++;<br/>
            }<br/>
        }<br/>
<br/>
        return count;<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            game.removeEntity(entity.getId());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    private Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i = connectionsPending.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
<br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Resets the server back to the lounge<br/>
     */<br/>
    private void resetServer() {<br/>
        //game.entities.removeAllElements();<br/>
        changePhase(Game.PHASE_LOUNGE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Are we out of turns (done with the phase?)<br/>
     */<br/>
    private boolean areMoreTurns() {<br/>
        return ti &lt; turns.length;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the player number of who gets the next turn,<br/>
     * or -1 if we're done.<br/>
     */<br/>
    private int nextTurn() {<br/>
        if (ti &lt; turns.length) {<br/>
            return turns[ti++];<br/>
        } else {<br/>
            return -1;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this entity<br/>
     * that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.delta_distance = 0;<br/>
            entity.moved = Entity.MOVE_NONE;<br/>
            <br/>
            entity.setCharging(false);<br/>
            entity.setMakingDfa(false);<br/>
<br/>
            entity.crew.setKoThisRound(false);<br/>
<br/>
            for (Enumeration i = entity.weapons.elements(); i.hasMoreElements();) {<br/>
                MountedWeapon w = (MountedWeapon)i.nextElement();<br/>
                w.setFiredThisRound(false);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase() {<br/>
    // first, mark doomed entities as destroyed and move them to the graveyard<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
            if (entity.isDestroyed()) {<br/>
                game.moveToGraveyard(entity.getId());<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            // if ammo has exploded, empty the bin<br/>
            for (Enumeration i = entity.ammo.elements(); i.hasMoreElements();) {<br/>
                final Ammo a = (Ammo)i.nextElement();<br/>
                if (a.exploded) {<br/>
                    a.shots = 0;<br/>
                    a.exploded = false;<br/>
                }<br/>
            }<br/>
<br/>
            // weapons are readied, except destroyed ones.<br/>
            for (Enumeration i = entity.weapons.elements(); i.hasMoreElements();) {<br/>
               final MountedWeapon w = (MountedWeapon)i.nextElement();<br/>
<br/>
                // first, if a weapon isn't destroyed, it's okay.<br/>
                boolean weaponOK = !w.isDestroyed();<br/>
<br/>
                // does the weapon use ammo?<br/>
                if (weaponOK &amp;&amp; w.getType().getAmmoType() != Ammo.TYPE_NA) {<br/>
                    // try to reload if needed<br/>
                    if (w.getAmmoFeed() == null || w.getAmmoFeed().shots &lt;= 0) {<br/>
                        entity.loadWeapon(w);<br/>
                    }<br/>
                    // if still out of shots, weapon is useless<br/>
                    if (w.getAmmoFeed() == null || w.getAmmoFeed().shots &lt;= 0) {<br/>
                        weaponOK = false;<br/>
                    }<br/>
                }<br/>
<br/>
                // ready it if it's still okay<br/>
                w.setReady(weaponOK);<br/>
            }<br/>
<br/>
            // destroy doomed criticals<br/>
            for (int i = 0; i &lt; entity.locations(); i++) {<br/>
                for (int j = 0; j &lt; entity.getNumberOfCriticals(i); j++) {<br/>
                    final CriticalSlot cs = entity.getCritical(i, j);<br/>
                    if (cs != null) {<br/>
                        cs.setDestroyed(cs.isDestroyed() | cs.isDoomed());<br/>
                    }<br/>
                }<br/>
            }<br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
<br/>
            // reset ready to true<br/>
            entity.ready = entity.isActive();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resets an entity's secondary facing to face forwards<br/>
     */<br/>
    private void resetEntityFacing() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            entity.setSecondaryFacing(entity.getFacing());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayerReady() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setReady(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersReady() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setReady(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
<br/>
        }<br/>
        transmitAllPlayerReadys();<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when a player is "ready".  Handles any moving<br/>
     * to the next turn or phase or that stuff.<br/>
     */<br/>
    private void checkReady() {<br/>
        // are there any active players?<br/>
        boolean allAboard = countActivePlayers() &gt; 0;<br/>
        // check if all active players are ready<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isReady()) {<br/>
                allAboard = false;<br/>
            }<br/>
        }<br/>
        // now, do something about it.<br/>
        switch(game.phase) {<br/>
        case Game.PHASE_LOUNGE :<br/>
        case Game.PHASE_EXCHANGE :<br/>
        case Game.PHASE_INITIATIVE :<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
        case Game.PHASE_END :<br/>
            if (allAboard) {<br/>
                endCurrentPhase();<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            if (!areMoreTurns()) {<br/>
                endCurrentPhase();<br/>
            } else if (getPlayer(game.getTurn()).isReady()) {<br/>
                changeTurn(nextTurn());<br/>
            }<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.phase = phase;<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
<br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
<br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_EXCHANGE :<br/>
            gameSettings.friendlyFire = game.getNoOfPlayers() &lt;= 1;<br/>
            resetPlayerReady();<br/>
            // apply board layout settings to produce a mega-board<br/>
            Board[] sheetBoards = new Board[gameSettings.sheetWidth * gameSettings.sheetHeight];<br/>
            for (int i = 0; i &lt; gameSettings.sheetWidth * gameSettings.sheetHeight; i++) {<br/>
                sheetBoards[i] = new Board();<br/>
                sheetBoards[i].load(getRandomBoard());<br/>
            }<br/>
            game.board.combine(gameSettings.boardWidth, gameSettings.boardHeight,<br/>
                    gameSettings.sheetWidth, gameSettings.sheetHeight, sheetBoards);<br/>
            // deploy all entities<br/>
            Coords center = new Coords(game.board.width / 2, game.board.height / 2);<br/>
            for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
                Entity entity = (Entity)i.nextElement();<br/>
                deploy(entity, getStartingCoords(entity.getOwner().getStartingPos()), center, 10);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_INITIATIVE :<br/>
            // remove the last traces of last round<br/>
            attacks.removeAllElements();<br/>
            roundReport = new StringBuffer();<br/>
            resetEntityPhase();<br/>
            resetEntityRound();<br/>
            // roll 'em<br/>
            resetActivePlayersReady();<br/>
            rollInitiative();<br/>
            setIneligible(phase);<br/>
            determineTurnOrder();<br/>
            writeInitiativeReport();<br/>
            send(createReportPacket());<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
            resetEntityFacing();<br/>
        case Game.PHASE_PHYSICAL :<br/>
            resetEntityPhase();<br/>
            setIneligible(phase);<br/>
            determineTurnOrder();<br/>
            resetActivePlayersReady();<br/>
            send(createEntitiesPacket());<br/>
            phaseReport = new StringBuffer();<br/>
            break;<br/>
        case Game.PHASE_END :<br/>
            phaseReport = new StringBuffer();<br/>
            resetEntityPhase();<br/>
            resolveHeat();<br/>
            checkForSuffocation();<br/>
            resolveCrewDamage();<br/>
            resolveCrewWakeUp();<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
            }<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
            resetActivePlayersReady();<br/>
            send(createReportPacket());<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Should we play this phase or skip it?  The only phases we'll skip<br/>
     * are the firing or the physical phase if no entities are eligible.<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            return areMoreTurns();<br/>
        default :<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_EXCHANGE :<br/>
            // transmit the board to everybody<br/>
            send(createBoardPacket());<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
        case Game.PHASE_FIRING :<br/>
        case Game.PHASE_PHYSICAL :<br/>
            // set turn<br/>
            ti = 0;<br/>
            changeTurn(nextTurn());<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.phase) {<br/>
        case Game.PHASE_LOUNGE :<br/>
            changePhase(Game.PHASE_EXCHANGE);<br/>
            break;<br/>
        case Game.PHASE_EXCHANGE :<br/>
            changePhase(Game.PHASE_INITIATIVE);<br/>
            break;<br/>
        case Game.PHASE_INITIATIVE :<br/>
            changePhase(Game.PHASE_MOVEMENT);<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT :<br/>
            roundReport.append("\nMovement Phase\n-------------------\n");<br/>
            resolveCrewDamage();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
                changePhase(Game.PHASE_MOVEMENT_REPORT);<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
                changePhase(Game.PHASE_FIRING);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_MOVEMENT_REPORT :<br/>
            changePhase(Game.PHASE_FIRING);<br/>
            break;<br/>
        case Game.PHASE_FIRING :<br/>
            resolveWeaponAttacks();<br/>
            checkFor20Damage();<br/>
            resolveCrewDamage();<br/>
            resolvePilotingRolls();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
                changePhase(Game.PHASE_FIRING_REPORT);<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
                changePhase(Game.PHASE_PHYSICAL);<br/>
            }<br/>
            break;<br/>
        case Game.PHASE_FIRING_REPORT :<br/>
            changePhase(Game.PHASE_PHYSICAL);<br/>
            break;<br/>
        case Game.PHASE_PHYSICAL :<br/>
            resolvePhysicalAttacks();<br/>
            checkFor20Damage();<br/>
            resolveCrewDamage();<br/>
            resolvePilotingRolls();<br/>
            // check phase report<br/>
            if (phaseReport.length() &gt; 0) {<br/>
                roundReport.append(phaseReport.toString());<br/>
            } else {<br/>
                roundReport.append("&lt;nothing&gt;\n");<br/>
            }<br/>
            changePhase(Game.PHASE_END);<br/>
            break;<br/>
        case Game.PHASE_END :<br/>
            changePhase(Game.PHASE_INITIATIVE);<br/>
            break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes it to make it the specified player's turn.<br/>
     */<br/>
    private void changeTurn(int turn) {<br/>
        final Player player = getPlayer(game.getTurn());<br/>
<br/>
        game.setTurn(turn);<br/>
        player.setReady(false);<br/>
        send(new Packet(Packet.COMMAND_TURN, new Integer(turn)));<br/>
    }<br/>
<br/>
    /**<br/>
     * Deploys an entity near a selected point on the board.<br/>
     *<br/>
     * @param entity the entity to deploy<br/>
     * @param pos the point to deploy near<br/>
     * @param towards another point that the deployed mechs will face towards<br/>
     */<br/>
    private boolean deploy(Entity entity, Coords pos, Coords towards, int recurse) {<br/>
        if (game.board.contains(pos) &amp;&amp; game.getEntity(pos) == null) {<br/>
            placeEntity(entity, pos, pos.direction(towards));<br/>
            return true;<br/>
        }<br/>
        <br/>
        // if pos is filled, try some different positions<br/>
        for (int j = 0; j &lt; recurse; j++) {<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                Coords deployPos = pos.translated(i);<br/>
                if (deploy(entity, deployPos, towards, j)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Places a mech on the board<br/>
     */<br/>
    private void placeEntity(Entity entity, Coords pos, int facing) {<br/>
        entity.setPosition(pos);<br/>
        entity.setFacing(facing);<br/>
        entity.setSecondaryFacing(facing);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the starting point for the specified player<br/>
     */<br/>
    private Coords getStartingCoords(int startingPos) {<br/>
        switch (startingPos) {<br/>
        default :<br/>
        case 0 :<br/>
            return new Coords(1, 1);<br/>
        case 1 :<br/>
            return new Coords(game.board.width / 2, 1);<br/>
        case 2 :<br/>
            return new Coords(game.board.width - 2, 1);<br/>
        case 3 :<br/>
            return new Coords(game.board.width - 2, game.board.height / 2);<br/>
        case 4 :<br/>
            return new Coords(game.board.width - 2, game.board.height - 2);<br/>
        case 5 :<br/>
            return new Coords(game.board.width / 2, game.board.height - 2);<br/>
        case 6 :<br/>
            return new Coords(1, game.board.height - 2);<br/>
        case 7 :<br/>
            return new Coords(1, game.board.height / 2);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        roundCounter++;<br/>
<br/>
        // roll the dice for each player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.clearInitiative();<br/>
            player.setInitiative(Compute.d6(2), 0);<br/>
        }<br/>
        <br/>
        // roll off initiative ties, up to 5 times<br/>
        // TODO: infinite rerolls<br/>
        for (int i = 0; i &lt; 5; i++) {<br/>
            for (int j = 2; j &lt;= 12; j++) {<br/>
                for (Enumeration k = game.getPlayers(); k.hasMoreElements();) {<br/>
                    final Player player = (Player)k.nextElement();<br/>
                    if (player.getInitiativeSize() &gt; i &amp;&amp; player.getInitiative(i) == j &amp;&amp; isInitTie(j, i)) {<br/>
                        player.setInitiative(Compute.d6(2), i + 1);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
    <br/>
    private boolean isInitTie(int init, int index) {<br/>
        int playersAt = 0;<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (player.getInitiativeSize() &gt; index &amp;&amp; player.getInitiative(index) == init) {<br/>
                playersAt++;<br/>
            }<br/>
        }<br/>
        return playersAt &gt; 1;<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * Determine turn order by number of entities that are selectable this phase<br/>
     */<br/>
    private void determineTurnOrder() {<br/>
        // determine turn order<br/>
        int[] order = new int[game.getNoOfPlayers()];<br/>
        int oi = 0;<br/>
        for (int i = 0; i &lt; 5; i++) {<br/>
            for (int j = 2; j &lt;= 12; j++) {<br/>
                for (Enumeration k = game.getPlayers(); k.hasMoreElements();) {<br/>
                    final Player player = (Player)k.nextElement();<br/>
                    if (player.getInitiativeSize() &gt; i &amp;&amp; player.getInitiative(i) == j &amp;&amp; !isInitTie(j, i)) {<br/>
                        order[oi++] = player.getId();<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        // count how many entities each player controls, and how many turns we have to assign<br/>
        int MAX_PLAYERS = 255; //XXX HACK HACK HACK!<br/>
        int[] noe = new int[MAX_PLAYERS];<br/>
        int noOfTurns = 0;<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            if (entity.isSelectable()) {<br/>
                noe[entity.getOwner().getId()]++;<br/>
                noOfTurns++;<br/>
            }<br/>
        }<br/>
<br/>
        // generate turn list<br/>
        turns = new int[noOfTurns];<br/>
        ti = 0;<br/>
        while (ti &lt; turns.length){<br/>
            // get lowest number of entities, minimum 1.<br/>
            int hnoe = 1;<br/>
            int lnoe = Integer.MAX_VALUE;<br/>
            for (int i = 0; i &lt; MAX_PLAYERS; i++) {<br/>
                    if (noe[i] &gt; 0 &amp;&amp; noe[i] &lt; lnoe) {<br/>
                            lnoe = noe[i];<br/>
                    }<br/>
                    if (noe[i] &gt; hnoe) {<br/>
                            hnoe = noe[i];<br/>
                    }<br/>
            }<br/>
            // cycle through order list<br/>
            for (int i = 0; i &lt; order.length; i++) {<br/>
                if (noe[order[i]] &lt;= 0) {<br/>
                    continue;<br/>
                }<br/>
                // if you have less than twice the next lowest,<br/>
                // move 1, otherwise, move more.<br/>
                // if you have less than half the maximum,<br/>
                // move none<br/>
                int ntm = Math.max(1, (int)Math.floor(noe[order[i]] / lnoe));<br/>
                for (int j = 0; j &lt; ntm; j++) {<br/>
                    turns[ti++] = order[i];<br/>
                    noe[order[i]]--;<br/>
                }<br/>
            }<br/>
        }<br/>
        // reset turn counter<br/>
        ti = 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport() {<br/>
        // write to report<br/>
        roundReport.append("\nInitiative Phase for Round #" + roundCounter<br/>
                           + "\n------------------------------\n");<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            roundReport.append(player.getName() + " rolls a ");<br/>
            boolean first = true;<br/>
            for (Enumeration j = player.getInitiatives(); j.hasMoreElements();) {<br/>
                Integer init = (Integer)j.nextElement();<br/>
                if (first) {<br/>
                    first = false;<br/>
                } else {<br/>
                    roundReport.append(" / ");<br/>
                }<br/>
                roundReport.append(init.toString());<br/>
            }<br/>
            roundReport.append(".\n");<br/>
        }<br/>
        roundReport.append("\nThe turn order is:\n  ");<br/>
        for (int i = 0; i &lt; turns.length; i++) {<br/>
            roundReport.append((i == 0 ? "" : ", ") + getPlayer(turns[i]).getName());<br/>
        }<br/>
        roundReport.append("\n");<br/>
<br/>
        // reset turn index<br/>
        ti = 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
            if (!isEligibleFor(entity, phase)) {<br/>
                entity.ready = false;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines if an entity is eligible for a phase.<br/>
     */<br/>
    private boolean isEligibleFor(Entity entity, int phase) {<br/>
        switch (phase) {<br/>
        case Game.PHASE_FIRING :<br/>
            return isEligibleForFiring(entity, phase);<br/>
        case Game.PHASE_PHYSICAL :<br/>
            return isEligibleForPhysical(entity, phase);<br/>
        default:<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * An entity is eligible if its to-hit number is anything but impossible.<br/>
     * This is only really an issue if friendly fire is turned off.<br/>
     */<br/>
    private boolean isEligibleForFiring(Entity entity, int phase) {<br/>
        // if you're charging, no shooting<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
        <br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Check if the entity has any valid targets for physical attacks.<br/>
     */<br/>
    private boolean isEligibleForPhysical(Entity entity, int phase) {<br/>
        boolean canHit = false;<br/>
        <br/>
        // if you're charging, it's already declared<br/>
        if (entity.isCharging() || entity.isMakingDfa()) {<br/>
            return false;<br/>
        }<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity target = (Entity)e.nextElement();<br/>
<br/>
            // don't hit yourself, please<br/>
            if (target.equals(entity)) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // don't hit your own guys with friendly fire<br/>
            if (!gameSettings.friendlyFire<br/>
                &amp;&amp; target.getOwner().equals(entity.getOwner())) {<br/>
                continue;<br/>
            }<br/>
            <br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
                                         PunchAttackAction.LEFT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitPunch(game, entity.getId(), target.getId(),<br/>
                                         PunchAttackAction.RIGHT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
                                        KickAttackAction.LEFT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
<br/>
            canHit |= Compute.toHitKick(game, entity.getId(), target.getId(),<br/>
                                        KickAttackAction.RIGHT).getValue()<br/>
                      != ToHitData.IMPOSSIBLE;<br/>
        }<br/>
<br/>
        return canHit;<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps thru an entity movement packet, executing it.<br/>
     */<br/>
    private void doEntityMovement(Packet c, int cn) {<br/>
        final MovementData md = (MovementData)c.getObject(1);<br/>
        // walk thru data, stopping when the mech is out of movement<br/>
        final Entity entity = game.getEntity(c.getIntValue(0));<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int distance = 0;<br/>
        int moveType = Entity.MOVE_NONE;<br/>
        int overallMoveType = Entity.MOVE_NONE;<br/>
        boolean firstStep;<br/>
<br/>
        Compute.compile(game, entity.getId(), md);<br/>
<br/>
        // get last step's movement type<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            } else {<br/>
                overallMoveType = step.getMovementType();<br/>
            }<br/>
        }<br/>
<br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MovementData.Step step = (MovementData.Step)i.nextElement();<br/>
<br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == Entity.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
<br/>
            // check piloting skill for getting up<br/>
            if (step.getType() == MovementData.STEP_GET_UP) {<br/>
                entity.setProne(false);<br/>
                doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "getting up"));<br/>
                entity.heatBuildup += 1;<br/>
            } else if (firstStep) {<br/>
                // running with destroyed hip or gyro needs a check<br/>
                if (overallMoveType == Entity.MOVE_RUN<br/>
                        &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                            || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_RLEG) &gt; 0<br/>
                            || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_LLEG) &gt; 0)) {<br/>
                    doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "running with damaged hip actuator or gyro"));<br/>
                }<br/>
                firstStep = false;<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                break;<br/>
            }<br/>
            <br/>
            // check for charge<br/>
            if (step.getType() == MovementData.STEP_CHARGE) {<br/>
                Entity target = game.getEntity(step.getPosition());<br/>
<br/>
                distance = step.getDistance();<br/>
                entity.setCharging(true);<br/>
                <br/>
                pendingCharges.addElement(new ChargeAttackAction(entity.getId(), target.getId(), target.getPosition()));<br/>
                break;<br/>
            }<br/>
<br/>
            // check for dfa<br/>
            if (step.getType() == MovementData.STEP_DFA) {<br/>
                Entity target = game.getEntity(step.getPosition());<br/>
<br/>
                distance = step.getDistance();<br/>
                entity.setMakingDfa(true);<br/>
                <br/>
                pendingCharges.addElement(new DfaAttackAction(entity.getId(), target.getId(), target.getPosition()));<br/>
                break;<br/>
            }<br/>
<br/>
            // step...<br/>
            moveType = step.getMovementType();<br/>
            curPos = step.getPosition();<br/>
            curFacing = step.getFacing();<br/>
            distance = step.getDistance();<br/>
<br/>
            final Hex curHex = game.board.getHex(curPos);<br/>
<br/>
            // check if we've moved into rubble<br/>
            if (!lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
                    &amp;&amp; (curHex.getTerrainType() == Terrain.RUBBLE)) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Rubble"));<br/>
            }<br/>
<br/>
            // check if we've moved into water<br/>
            if (!lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != Entity.MOVE_JUMP<br/>
                    &amp;&amp; curHex.getTerrainType() == Terrain.WATER<br/>
                    &amp;&amp; curHex.getElevation() &lt; 0) {<br/>
                if (curHex.getElevation() == -1) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), -1, "entering Depth 1 Water"));<br/>
                } else if (curHex.getElevation() == -2) {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 0, "entering Depth 2 Water"));<br/>
                } else {<br/>
                    doSkillCheckWhileMoving(entity, lastPos, curPos, new PilotingRollData(entity.getId(), 1, "entering Depth 3+ Water"));<br/>
                }<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                break;<br/>
            }<br/>
<br/>
            // update lastPos<br/>
            lastPos = new Coords(curPos);<br/>
        }<br/>
<br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == Entity.MOVE_JUMP<br/>
                &amp;&amp; (entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO,Mech.LOC_CT) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, Mech.LOC_RLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, Mech.LOC_LLEG) &gt; 0<br/>
                    || entity.getDestroyedCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, Mech.LOC_LLEG) &gt; 0)) {<br/>
            doSkillCheckInPlace(entity, new PilotingRollData(entity.getId(), 0, "landing with damaged leg actuator or gyro"));<br/>
        }<br/>
<br/>
        // build up heat from movement<br/>
        if (moveType == Entity.MOVE_WALK) {<br/>
            entity.heatBuildup += 1;<br/>
        } else if (moveType == Entity.MOVE_RUN) {<br/>
            entity.heatBuildup += 2;<br/>
        } else if (moveType == Entity.MOVE_JUMP) {<br/>
            entity.heatBuildup += Math.max(3, distance);<br/>
        }<br/>
<br/>
        entity.ready = false;<br/>
<br/>
        // duhh.. send an outgoing packet to everybody<br/>
        send(createEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the movement phase)<br/>
     */<br/>
    private void doSkillCheckInPlace(Entity entity, PilotingRollData reason) {<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
<br/>
        // append the reason modifier<br/>
        roll.addModifier(reason.getValue(), reason.getDesc());<br/>
<br/>
        // okay, print the info<br/>
        phaseReport.append("\n" + entity.getDisplayName()<br/>
                   + " must make a piloting skill check (" + reason.getDesc() + ")"<br/>
                   + ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " + roll.getValue()<br/>
                   + " (" + roll.getDesc() + ")"<br/>
                   + ", rolls " + diceRoll + " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFall(entity, roll.getValue());<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while moving<br/>
     */<br/>
    private void doSkillCheckWhileMoving(Entity entity, Coords src, Coords dest,<br/>
                                         PilotingRollData reason) {<br/>
        final PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        boolean fallsInPlace;<br/>
        int fallElevation;<br/>
<br/>
        // append the reason modifier<br/>
        roll.addModifier(reason.getValue(), reason.getDesc());<br/>
<br/>
        // will the entity fall in the source or destination hex?<br/>
        if (src.equals(dest) || srcHex.getElevation() &lt; destHex.getElevation()) {<br/>
            fallsInPlace = true;<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
        }<br/>
<br/>
        // how far down did it fall?<br/>
        fallElevation = Math.abs(destHex.getElevation() - srcHex.getElevation());<br/>
        <br/>
        // okay, print the info<br/>
        phaseReport.append("\n" + entity.getDisplayName()<br/>
                + " must make a piloting skill check"<br/>
                + " while moving from hex " + src.getBoardNum()<br/>
                + " to hex " + dest.getBoardNum()<br/>
                + " (" + reason.getDesc() + ")" + ".\n");<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        phaseReport.append("Needs " + roll.getValue()<br/>
                + " (" + roll.getDesc() + ")"<br/>
                + ", rolls " + diceRoll + " : ");<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            phaseReport.append("falls.\n");<br/>
            doEntityFallsInto(entity, (fallsInPlace ? src : dest), (fallsInPlace ? dest : src), roll.getValue());<br/>
            //doEntityFall(entity, (fallsInPlace ? src : dest), fallElevation, roll.getValue());<br/>
        } else {<br/>
            phaseReport.append("succeeds.\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, int roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int fallElevation = Math.abs(destHex.getElevation() - srcHex.getElevation());<br/>
        int direction = src.direction(dest);<br/>
        // check entity in target hex<br/>
        Entity target = game.getEntity(dest);<br/>
        // check if we can fall in that hex<br/>
        if (target != null &amp;&amp; !target.equals(entity)<br/>
            &amp;&amp; !Compute.isValidDisplacement(game, target.getId(), src, dest)) {<br/>
            // if target can't be displaced, fall in source hex.<br/>
            // NOTE: source hex should never contain a non-displacable entity<br/>
            Coords temp = dest;<br/>
            dest = src;<br/>
            src = temp;<br/>
            target = game.getEntity(dest);<br/>
        }<br/>
<br/>
        // falling mech falls<br/>
        phaseReport.append(entity.getDisplayName() + " falls "<br/>
                + fallElevation + " level(s) into hex "<br/>
                + dest.getBoardNum() + ".\n");<br/>
<br/>
        // if hex was empty, deal damage and we're done<br/>
        if (target == null || target.equals(entity)) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
<br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2) {<br/>
            // accidental death from above<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            // target gets displaced<br/>
            doEntityDisplacement(target, dest, dest.translated(direction), new PilotingRollData(target.getId(), 0, "domino effect"));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
                                      PilotingRollData roll) {<br/>
        final Hex srcHex = game.board.getHex(src);<br/>
        final Hex destHex = game.board.getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
        int fallElevation = srcHex.getElevation() - destHex.getElevation();<br/>
        Entity target = game.getEntity(dest);<br/>
<br/>
        // can't fall upwards<br/>
        if (fallElevation &lt; 0) {<br/>
            fallElevation = 0;<br/>
        }<br/>
<br/>
        // if destination is empty, this could be easy...<br/>
        if (target == null || target.equals(entity)) {<br/>
            if (fallElevation &lt; 2) {<br/>
                // no cliff: move and roll normally<br/>
                phaseReport.append(entity.getDisplayName()<br/>
                           + " is displaced into hex "<br/>
                           + dest.getBoardNum() + ".\n");<br/>
                entity.setPosition(dest);<br/>
                if (roll != null) {<br/>
                    pilotRolls.addElement(roll);<br/>
                }<br/>
                return;<br/>
            } else {<br/>
                // cliff: fall off it, deal damage, prone immediately<br/>
                phaseReport.append(entity.getDisplayName() + " falls "<br/>
                           + fallElevation + " levels into hex "<br/>
                           + dest.getBoardNum() + ".\n");<br/>
                doEntityFall(entity, dest, fallElevation, PilotingRollData.AUTOMATIC_FALL);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // okay, destination occupied.  hmmm...<br/>
        System.err.println("server.doEntityDisplacement: destination occupied");<br/>
        if (fallElevation &lt; 2) {<br/>
            // domino effect: move &amp; displace target<br/>
            phaseReport.append(entity.getDisplayName()<br/>
                           + " is displaced into hex "<br/>
                           + dest.getBoardNum() + ", occupied by "<br/>
                           + target.getDisplayName() + ".\n");<br/>
            entity.setPosition(dest);<br/>
            if (roll != null) {<br/>
                pilotRolls.addElement(roll);<br/>
            }<br/>
            doEntityDisplacement(target, dest, dest.translated(direction), new PilotingRollData(target.getId(), 0, "domino effect"));<br/>
            return;<br/>
        } else {<br/>
            // accidental fall from above: havoc!<br/>
            phaseReport.append(entity.getDisplayName() + " falls "<br/>
                           + fallElevation + " levels into hex "<br/>
                           + dest.getBoardNum() + ", occupied by "<br/>
                           + target.getDisplayName() + ".\n");<br/>
<br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "7 (base)");<br/>
            toHit.append(Compute.getTargetMovementModifier(game, target.getId()));<br/>
            toHit.append(Compute.getTargetTerrainModifier(game, target.getId()));<br/>
<br/>
            // roll dice<br/>
            final int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("Collision occurs on a " + toHit.getValue()<br/>
                           + " or greater.  Rolls " + diceRoll);<br/>
            if (diceRoll &gt;= toHit.getValue()) {<br/>
                phaseReport.append(", hits!\n");<br/>
                // deal damage to target<br/>
                int damage = (int)Math.ceil(entity.getWeight() / 10);<br/>
                phaseReport.append(target.getDisplayName() + " takes "<br/>
                                   + damage + " from the collision.");<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = entity.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                    phaseReport.append(damageEntity(target, hit, cluster));<br/>
                    damage -= cluster;<br/>
                }<br/>
                phaseReport.append("\n");<br/>
<br/>
                // attacker falls as normal, on his back<br/>
                doEntityFall(entity, dest, fallElevation, 3, PilotingRollData.AUTOMATIC_FALL);<br/>
<br/>
                // defender pushed away, or destroyed<br/>
                Coords targetDest = Compute.getValidDisplacement(game, target.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(target, dest, targetDest, new PilotingRollData(target.getId(), 2, "fallen on"));<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append("*** " + target.getDisplayName()<br/>
                                       + " DESTROYED due to impossible displacement! ***");<br/>
                    target.setDoomed(true);<br/>
                }<br/>
            } else {<br/>
                phaseReport.append(", misses.\n");<br/>
                //TODO: this is not quite how the rules go<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                if (targetDest != null) {<br/>
                    doEntityDisplacement(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.AUTOMATIC_FALL, "pushed off a cliff"));<br/>
                } else {<br/>
                    // ack!  automatic death!<br/>
                    phaseReport.append("*** " + entity.getDisplayName()<br/>
                                       + " DESTROYED due to impossible displacement! ***");<br/>
                    entity.setDoomed(true);<br/>
                }<br/>
            }<br/>
            return;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets a bunch of entity actions from the packet<br/>
     */<br/>
    private void receiveAttack(Packet pkt) {<br/>
        Vector vector = (Vector)pkt.getObject(1);<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
<br/>
            // add to the list.<br/>
            attacks.addElement(ea);<br/>
<br/>
            // if torso twist, twist so that everybody can see it later<br/>
            if (ea instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)ea;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
            }<br/>
<br/>
            // send an outgoing packet to everybody<br/>
            send(createAttackPacket(ea));<br/>
        }<br/>
        send(createEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve all fire for the round<br/>
     */<br/>
    private void resolveWeaponAttacks() {<br/>
        roundReport.append("\nWeapon Attack Phase\n-------------------\n");<br/>
<br/>
        int cen = Entity.NONE;<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                resolveWeaponAttack(waa, cen);<br/>
                cen = waa.getEntityId();<br/>
            } else if (o instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)o;<br/>
                game.getEntity(tta.getEntityId()).setSecondaryFacing(tta.getFacing());<br/>
<br/>
                System.out.println("server.resolveFire: torso twisting "<br/>
                                   + game.getEntity(tta.getEntityId()).getDisplayName()<br/>
                                   + " in direction " + tta.getFacing());<br/>
            } else {<br/>
                // hmm, error<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     */<br/>
    private void resolveWeaponAttack(WeaponAttackAction waa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
        final MountedWeapon w = ae.getWeapon(waa.getWeaponId());<br/>
<br/>
        if (lastEntityId != waa.getEntityId()) {<br/>
            phaseReport.append("\nWeapons fire for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    " + w.getType().getName() + " at "<br/>
                   + te.getDisplayName());<br/>
<br/>
        // check ammo<br/>
        if (w.getAmmoFeed() != null) {<br/>
            if (w.getAmmoFeed().shots == 0) {<br/>
                // try reloading?<br/>
                ae.loadWeapon(w);<br/>
            }<br/>
            if (w.getAmmoFeed().shots == 0) {<br/>
                phaseReport.append(" but the weapon is out of ammo");<br/>
                return;<br/>
            }<br/>
            w.getAmmoFeed().shots--;<br/>
        }<br/>
<br/>
        // build up some heat<br/>
        ae.heatBuildup += w.getType().getHeat();<br/>
<br/>
        // set the weapon as having fired<br/>
        w.setFiredThisRound(true);<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitWeapon(game, waa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        // are we attacks normal weapons or missiles?<br/>
        if (w.getType().getDamage() != Weapon.DAMAGE_MISSILE) {<br/>
            // normal weapon; deal damage<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
            phaseReport.append(damageEntity(te, hit, w.getType().getDamage()));<br/>
        } else {<br/>
            // missiles; determine number of missiles hitting<br/>
            int hits = Compute.missilesHit(w.getType().getRackSize());<br/>
            phaseReport.append(hits + " missiles hit" + toHit.getTableDesc() + ".");<br/>
            // for SRMs, do each missile seperately<br/>
            if (w.getType().getAmmoType() == Ammo.TYPE_SRM) {<br/>
                for (int j = 0; j &lt; hits; j++) {<br/>
                    HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                    phaseReport.append(damageEntity(te, hit, 2));<br/>
                }<br/>
            }<br/>
            // LRMs, do salvos of 5<br/>
                if (w.getType().getAmmoType() == Ammo.TYPE_LRM) {<br/>
                    while (hits &gt; 0) {<br/>
                        int salvo = Math.min(5, hits);<br/>
                        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                        phaseReport.append(damageEntity(te, hit, salvo));<br/>
                        hits -= salvo;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        roundReport.append("\nPhysical Attack Phase\n-------------------\n");<br/>
<br/>
        int cen = Entity.NONE;<br/>
        <br/>
        // add any pending charges<br/>
        for (Enumeration i = pendingCharges.elements(); i.hasMoreElements();) {<br/>
            attacks.addElement(i.nextElement());<br/>
        }<br/>
        pendingCharges.removeAllElements();<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof PunchAttackAction) {<br/>
                PunchAttackAction paa = (PunchAttackAction)o;<br/>
                if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                    paa.setArm(PunchAttackAction.LEFT);<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                    paa.setArm(PunchAttackAction.RIGHT);<br/>
                    resolvePunchAttack(paa, cen);<br/>
                } else {<br/>
                    resolvePunchAttack(paa, cen);<br/>
                    cen = paa.getEntityId();<br/>
                }<br/>
            } else if (o instanceof KickAttackAction) {<br/>
                KickAttackAction kaa = (KickAttackAction)o;<br/>
                resolveKickAttack(kaa, cen);<br/>
                cen = kaa.getEntityId();<br/>
            } else if (o instanceof PushAttackAction) {<br/>
                PushAttackAction paa = (PushAttackAction)o;<br/>
                resolvePushAttack(paa, cen);<br/>
                cen = paa.getEntityId();<br/>
            }  else if (o instanceof ChargeAttackAction) {<br/>
                ChargeAttackAction caa = (ChargeAttackAction)o;<br/>
                resolveChargeAttack(caa, cen);<br/>
                cen = caa.getEntityId();<br/>
            }  else if (o instanceof DfaAttackAction) {<br/>
                DfaAttackAction daa = (DfaAttackAction)o;<br/>
                resolveDfaAttack(daa, cen);<br/>
                cen = daa.getEntityId();<br/>
            } else {<br/>
                // hmm, error.<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PunchAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
                               ? "Left Arm" : "Right Arm";<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Punch (" +armName + ") at " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPunch(game, paa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
        int damage = Compute.getPunchDamageFor(ae, paa.getArm());<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(KickAttackAction kaa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Entity te = game.getEntity(kaa.getTargetId());<br/>
        final String legName = kaa.getLeg() == KickAttackAction.LEFT <br/>
                                ? "Left Leg" <br/>
                                : "Right Leg";<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Kick (" + legName + ") at " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitKick(game, kaa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            phaseReport.append("misses.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        }<br/>
        <br/>
        int damage = Compute.getKickDamageFor(ae, kaa.getLeg());<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        phaseReport.append("hits" + toHit.getTableDesc() + " " + te.getLocationAbbr(hit.loc));<br/>
        phaseReport.append(damageEntity(te, hit, damage));<br/>
<br/>
        pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was kicked"));<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PushAttackAction paa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Pushing " + te.getDisplayName());<br/>
<br/>
        // should we even bother?<br/>
        if (te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitPush(game, paa);<br/>
        phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
<br/>
        // roll<br/>
        int roll = Compute.d6(2);<br/>
        phaseReport.append("rolls " + roll + " : ");<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            phaseReport.append("misses.\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            Coords src = te.getPosition();<br/>
            Coords dest = src.translated(direction);<br/>
            phaseReport.append("succeeds: target is pushed into hex "<br/>
                               + dest.getBoardNum()<br/>
                               + "\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
<br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (game.getEntity(src) == null) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            phaseReport.append("succeeds, but target can't be moved.\n");<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 0, "was pushed"));<br/>
        }<br/>
<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(ChargeAttackAction caa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Entity te = game.getEntity(caa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Charging " + te.getDisplayName());<br/>
        <br/>
        // entity isn't charging any more<br/>
        ae.setCharging(false);<br/>
<br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(caa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitCharge(game, caa);<br/>
<br/>
        // hack: if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne()) {<br/>
            roll = -12;<br/>
            phaseReport.append("; but the attaker is prone : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
            phaseReport.append("rolls " + roll + " : ");<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getChargeDamageFor(ae);<br/>
        int damageTaken = Compute.getChargeDamageTakenBy(ae, te);<br/>
<br/>
        phaseReport.append("hits.");<br/>
        phaseReport.append("\n  Defender takes " + damage + " damage" + toHit.getTableDesc() + ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " + damageTaken + " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = te.rollHitLocation(ToHitData.HIT_NORMAL, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            Coords src = te.getPosition();<br/>
            Coords dest = src.translated(direction);<br/>
            <br/>
            phaseReport.append("\n");<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, new PilotingRollData(ae.getId(), 2, "charging"));<br/>
        } else {<br/>
            // they stil have to roll<br/>
            pilotRolls.addElement(new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            pilotRolls.addElement(new PilotingRollData(ae.getId(), 2, "charging"));<br/>
        }<br/>
<br/>
        phaseReport.append("\n");<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveDfaAttack(DfaAttackAction daa, int lastEntityId) {<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Entity te = game.getEntity(daa.getTargetId());<br/>
        <br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
        <br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            phaseReport.append("\nPhysical attacks for " + ae.getDisplayName() + "\n");<br/>
        }<br/>
<br/>
        phaseReport.append("    Attempting death from above on " + te.getDisplayName());<br/>
<br/>
        // entity isn't charging any more<br/>
        ae.setMakingDfa(false);<br/>
<br/>
        // should we even bother?<br/>
        if (te == null || te.isDestroyed() || te.isDoomed() || te.crew.isDead()) {<br/>
            phaseReport.append(" but the target is already destroyed!\n");<br/>
            return;<br/>
        }<br/>
<br/>
        // target still in the same position?<br/>
        if (!te.getPosition().equals(daa.getTargetPos())) {<br/>
            phaseReport.append(" but the target has moved.\n");<br/>
            return;<br/>
        }<br/>
        <br/>
        // compute to-hit<br/>
        ToHitData toHit = Compute.toHitDfa(game, daa);<br/>
<br/>
        // hack: if the attacker's prone, fudge the roll<br/>
        int roll;<br/>
        if (ae.isProne()) {<br/>
            roll = -12;<br/>
            phaseReport.append("; but the attacker is prone : ");<br/>
        } else {<br/>
            // roll<br/>
            roll = Compute.d6(2);<br/>
            phaseReport.append("; needs " + toHit.getValue() + ", ");<br/>
            phaseReport.append("rolls " + roll + " : ");<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            phaseReport.append("misses.\n");<br/>
            if (targetDest != null) {<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, src, targetDest, null);<br/>
                // attacker falls into destination hex<br/>
                phaseReport.append(ae.getDisplayName() + " falls into hex " + dest.getBoardNum() + ".\n");<br/>
                doEntityFall(ae, dest, 2, 3, PilotingRollData.AUTOMATIC_FALL);<br/>
            } else {<br/>
                // attacker destroyed<br/>
                phaseReport.append("*** " + ae.getDisplayName()<br/>
                                   + " DESTROYED due to impossible displacement! ***");<br/>
                ae.setDoomed(true);<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int damage = Compute.getDfaDamageFor(ae);<br/>
        int damageTaken = Compute.getDfaDamageTakenBy(ae);<br/>
<br/>
        phaseReport.append("hits.");<br/>
<br/>
        phaseReport.append("\n  Defender takes " + damage + " damage" + toHit.getTableDesc() + ".");<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
            phaseReport.append(damageEntity(te, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
        phaseReport.append("\n  Attacker takes " + damageTaken + " damage.");<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = te.rollHitLocation(ToHitData.HIT_KICK, toHit.SIDE_FRONT);<br/>
            phaseReport.append(damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        phaseReport.append("\n");<br/>
        <br/>
        // defender pushed away or destroyed<br/>
        Coords src = ae.getPosition();<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (targetDest != null) {<br/>
            doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
        } else {<br/>
            // ack!  automatic death!<br/>
            phaseReport.append("*** " + te.getDisplayName()<br/>
                               + " DESTROYED due to impossible displacement! ***");<br/>
            te.setDoomed(true);<br/>
        }<br/>
        doEntityDisplacement(ae, src, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
<br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        roundReport.append("\nHeat Phase\n----------\n");<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
<br/>
            // should we even bother?<br/>
            if (entity.isDestroyed() || entity.isDoomed() || entity.crew.isDead()) {<br/>
                continue;<br/>
            }<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            if (!entity.isShutDown()) {<br/>
                entity.heatBuildup += 5 * entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
            }<br/>
<br/>
            // add the heat we've built up so far.<br/>
            roundReport.append(entity.getDisplayName() + " gains " + entity.heatBuildup + " heat,");<br/>
            entity.heat += entity.heatBuildup;<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = Math.min(entity.getHeatCapacityWithWater(game), entity.heat);<br/>
<br/>
            entity.heat -= tosink;<br/>
            roundReport.append(" sinks " + tosink + " heat and is now at " + entity.heat + " heat.\n");<br/>
<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; 30 &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    entity.setShutDown(false);<br/>
                    roundReport.append(entity.getDisplayName() + " automatically starts up.\n");<br/>
                } else {<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int suroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() + " needs a " + startup + "+ to start up, rolls " + suroll + " : ");<br/>
                    if (suroll &gt;= startup) {<br/>
                        entity.setShutDown(false);<br/>
                        roundReport.append("successful!\n");<br/>
                    } else {<br/>
                        roundReport.append("fails.\n");<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            if (entity.heat &gt;= 14 &amp;&amp; entity.isActive()) {<br/>
                if (entity.heat &gt;= 30) {<br/>
                    roundReport.append(entity.getDisplayName() + " automatically shuts down.\n");<br/>
                    // add a piloting roll and resolve immediately<br/>
                    pilotRolls.addElement(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    int sdroll = Compute.d6(2);<br/>
                    roundReport.append(entity.getDisplayName() + " needs a " + shutdown + "+ to avoid shutdown, rolls " + sdroll + " : ");<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        roundReport.append("avoids successfully!\n");<br/>
                    } else {<br/>
                        roundReport.append("shuts down.\n");<br/>
                        // add a piloting roll and resolve immediately<br/>
                        pilotRolls.addElement(new PilotingRollData(entity.getId(), 3, "reactor shutdown"));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) + (entity.heat &gt;= 28 ? 2 : 0);<br/>
                int boomroll = Compute.d6(2);<br/>
                roundReport.append(entity.getDisplayName() + " needs a " + boom + "+ to avoid ammo explosion, rolls " + boomroll + " : ");<br/>
                if (boomroll &gt;= boom) {<br/>
                    roundReport.append("avoids successfully!\n");<br/>
                } else {<br/>
                    roundReport.append("fails to avoid explosion.\n");<br/>
                    roundReport.append(explodeAmmo(entity));<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: mechwarrior damage<br/>
            if (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0<br/>
                &amp;&amp; entity.heat &gt;= 15) {<br/>
                if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    roundReport.append(entity.getDisplayName() + " has 25 or higher heat and damaged life support.  Mechwarrior takes 2 damage.\n");<br/>
                    damageCrew(entity, 2);<br/>
                } else {<br/>
                    // mechwarrior takes 1 damage<br/>
                    roundReport.append(entity.getDisplayName() + " has 15 or higher heat and damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                    damageCrew(entity, 1);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a piloting<br/>
     * skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            // if this mech has 20+ damage, add another roll to the list.<br/>
            if (entity.damageThisPhase &gt;= 20) {<br/>
                pilotRolls.addElement(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            final Hex curHex = game.board.getHex(entity.getPosition());<br/>
            if (curHex.getTerrainType() == Terrain.WATER<br/>
                    &amp;&amp; (curHex.getElevation() &lt;= -2<br/>
                        || (curHex.getElevation() == -1 &amp;&amp; entity.isProne()))<br/>
                    &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                roundReport.append("\n" + entity.getDisplayName() + " is underwater with damaged life support.  Mechwarrior takes 1 damage.\n");<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * (used at end of weapons, physical phases)<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.isProne() || entity.isDoomed() || entity.isDestroyed()) {<br/>
                continue;<br/>
            }<br/>
            int rolls = 0;<br/>
            StringBuffer reasons = new StringBuffer();<br/>
            PilotingRollData roll = Compute.getBasePilotingRoll(game, entity.getId());<br/>
            for (Enumeration j = pilotRolls.elements(); j.hasMoreElements();) {<br/>
                final PilotingRollData modifier = (PilotingRollData)j.nextElement();<br/>
                if (modifier.getEntityId() == entity.getId()) {<br/>
                    rolls++;<br/>
                    if (reasons.length() &gt; 0) {<br/>
                        reasons.append(", ");<br/>
                    }<br/>
                    reasons.append(modifier.getDesc());<br/>
                    roll.addModifier(modifier.getValue(), modifier.getDesc());<br/>
                }<br/>
            }<br/>
            // any rolls needed?<br/>
            if (rolls == 0) {<br/>
                continue;<br/>
            }<br/>
            if (roll.getValue() == PilotingRollData.AUTOMATIC_FALL) {<br/>
                phaseReport.append("\n" + entity.getDisplayName() + " must make " + rolls + " piloting skill roll(s) and automatically fails (" + roll.getDesc() + ").\n");<br/>
                doEntityFall(entity, roll.getValue());<br/>
            } else {<br/>
                phaseReport.append("\n" + entity.getDisplayName() + " must make " + rolls + " piloting skill roll(s) (" + reasons + ").\n");<br/>
                phaseReport.append("The target is " + roll.getValue() + " [" + roll.getDesc() + "].\n");<br/>
                for (int j = 0; j &lt; rolls; j++) {<br/>
                    final int diceRoll = Compute.d6(2);<br/>
                    phaseReport.append("    " + entity.getDisplayName() + " needs " + roll.getValue() + ", rolls " + diceRoll + " : ");<br/>
                    phaseReport.append((diceRoll &gt;= roll.getValue() ? "remains standing" : "falls") + ".\n");<br/>
                    if (diceRoll &lt; roll.getValue()) {<br/>
                        doEntityFall(entity, roll.getValue());<br/>
                        // break rolling loop<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        pilotRolls.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     */<br/>
    private String damageCrew(Entity en, int damage) {<br/>
        String s = new String();<br/>
<br/>
        if (!en.crew.isDead()) {<br/>
            en.crew.setHits(en.crew.getHits() + damage);<br/>
            s += "        Pilot of " + en.getDisplayName() + " \"" + en.crew.getName() + "\" takes " + damage + " damage.";<br/>
            if (en.crew.getHits() &lt; 6) {<br/>
                en.crew.setRollsNeeded(en.crew.getRollsNeeded() + damage);<br/>
            } else {<br/>
                en.crew.setDead(true);<br/>
                en.crew.setRollsNeeded(0);<br/>
                s += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
            }<br/>
        }<br/>
<br/>
        return s;<br/>
    }<br/>
<br/>
    /**<br/>
     * This checks if the mech pilot goes unconcious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
            e.crew.setRollsNeeded(0);<br/>
<br/>
            if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            for (int j = 0; j &lt; e.crew.getRollsNeeded(); j++) {<br/>
                int roll = Compute.d6(2);<br/>
                phaseReport.append("\nPilot of " + e.getDisplayName()<br/>
                   + " \"" + e.getCrew().getName() + "\""<br/>
                   + " needs a " + e.getCrew().getConciousnessNumber()<br/>
                   + " to stay concious.  Rolls " + roll + " : ");<br/>
                if (roll &gt;= e.crew.getConciousnessNumber()) {<br/>
                    phaseReport.append("successful!");<br/>
                } else {<br/>
                    e.crew.setUnconcious(true);<br/>
                    e.crew.setKoThisRound(true);<br/>
                    phaseReport.append("blacks out.");<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            phaseReport.append("\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Make the rolls indicating whether any unconcious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
<br/>
            if (!e.isTargetable() || !e.crew.isUnconcious() || e.crew.isKoThisRound()) {<br/>
                continue;<br/>
            }<br/>
            anyRolls = true;<br/>
            int roll = Compute.d6(2);<br/>
            roundReport.append("\nPilot of " + e.getDisplayName() + " \"" + e.crew.getName() + "\" needs a " + e.crew.getConciousnessNumber() + " to regain conciousness.  Rolls " + roll + " : ");<br/>
            if (roll &gt;= e.crew.getConciousnessNumber()) {<br/>
                roundReport.append("successful!");<br/>
                e.crew.setUnconcious(false);<br/>
            } else {<br/>
                roundReport.append("fails.");<br/>
                break;<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            roundReport.append("\n");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Deals the listed damage to a mech.  Returns a description<br/>
     * string for the log.<br/>
     *<br/>
     * Currently mech only.<br/>
     */<br/>
    private String damageEntity(Entity te, HitData hit, int damage) {<br/>
        String desc = new String();<br/>
<br/>
        int crits = hit.effect == HitData.EFFECT_CRITICAL ? 1 : 0;<br/>
<br/>
        int loc = hit.loc, nextLoc = Entity.LOC_NONE;<br/>
        while (damage &gt; 0 &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed()) {<br/>
            // let's resolve some damage!<br/>
            <span class="add"><span class="add"><span class="mv">desc</span> += <span class="add"><span class="mv">"\n        "</span> + <span class="mv">te.getDisplayName()</span> + <span class="mv">" takes "</span> + <span class="mv">damage</span> + <span class="mv">" damage to "</span> + <span class="mv">te.getLocationAbbr(loc)</span> + <span class="add">(<span class="add"><span class="add"><span class="add"><span class="mv">hit</span>.<span class="add">effect</span></span> == <span class="add"><span class="mv">HitData</span>.<span class="add">EFFECT_CRITICAL</span></span></span> ? <span class="add">" (critical.)"</span> : <span class="mv">"."</span></span>)</span></span></span>;</span><br/>
            te.damageThisPhase += damage;<br/>
<br/>
            // is there armor in the location hit?<br/>
            if (te.getArmor(loc) &gt; 0) {<br/>
                if (te.getArmor(loc) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(loc) - damage, loc);<br/>
                    damage = 0;<br/>
                    desc += " " + te.getArmor(loc) + " Armor remaining";<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    damage -= te.getArmor(loc);<br/>
                    te.setArmor(Entity.ARMOR_DESTROYED, loc);<br/>
                    desc += " Armor destroyed,";<br/>
                }<br/>
            }<br/>
<br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(loc) &gt; 0) {<br/>
                    // triggers a critical hit<br/>
                    crits++;<br/>
                    if (te.getInternal(loc) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(loc) - damage, loc);<br/>
                        damage = 0;<br/>
                        desc += " " + te.getInternal(loc) + " Internal Structure remaining";<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        damage -= te.getInternal(loc);<br/>
                        te.setInternal(Entity.ARMOR_DESTROYED, loc);<br/>
                        desc += " &lt;&lt;&lt;SECTION DESTROYED&gt;&gt;&gt;,";<br/>
                    }<br/>
                }<br/>
<br/>
                // is the internal structure gone?<br/>
                if (te.isLocationDestroyed(loc)) {<br/>
                    destroyLocation(te, loc);<br/>
                    if (loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
                        pilotRolls.addElement(new PilotingRollData(te.getId(),<br/>
                        PilotingRollData.AUTOMATIC_FALL, "leg destroyed"));<br/>
                    }<br/>
                    if (te.getTransferLocation(loc) == Entity.LOC_DESTROYED) {<br/>
                        // entity destroyed.<br/>
                        desc += " Entity destroyed!\n";<br/>
                        desc += "*** " + te.getDisplayName() + " DESTROYED! ***";<br/>
                        te.setDoomed(true);<br/>
                        // no need for further damage<br/>
                        damage = 0;<br/>
                        crits = 0;<br/>
                    } else {<br/>
                        // remaining damage transfers<br/>
                        nextLoc = te.getTransferLocation(loc);<br/>
                        desc += " " + damage + " damage transfers to "<br/>
                            + te.getLocationAbbr(nextLoc) + ";";<br/>
                    }<br/>
                }<br/>
            }<br/>
            // roll all critical hits against this location<br/>
            for (int i = 0; i &lt; crits; i++) {<br/>
                desc += "\n" + criticalEntity(te, loc);<br/>
            }<br/>
            crits = 0;<br/>
<br/>
            if (loc == Mech.LOC_HEAD) {<br/>
                desc += "\n" + damageCrew(te, 1);<br/>
            }<br/>
<br/>
            // loop to next location<br/>
            loc = nextLoc;<br/>
        }<br/>
<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits<br/>
     *<br/>
     * Currently mech only<br/>
     */<br/>
    private String criticalEntity(Entity en, int loc) {<br/>
        if (en.isRearLocation(loc)) {<br/>
            loc = en.getFrontLocation(loc);<br/>
        }<br/>
        String desc = "        Critical hit on " + en.getLocationAbbr(loc) + ". ";<br/>
        int hits = 0;<br/>
        int roll = Compute.d6(2);<br/>
        desc += "Roll = " + roll + ";";<br/>
        if (roll &lt;= 7) {<br/>
                desc += " no effect.";<br/>
                return desc;<br/>
        } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
                hits = 1;<br/>
                desc += " 1 location.";<br/>
        } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
                hits = 2;<br/>
                desc += " 2 locations.";<br/>
        } else if (roll == 12) {<br/>
            if (loc == Mech.LOC_HEAD ||<br/>
                    loc == Mech.LOC_RARM || loc == Mech.LOC_LARM ||<br/>
                    loc == Mech.LOC_RLEG || loc == Mech.LOC_LLEG) {<br/>
                desc += "&lt;&lt;&lt;LIMB BLOWN OFF&gt;&gt;&gt; " + en.getLocationName(loc) + " blown off.";<br/>
                destroyLocation(en, loc);<br/>
                if (loc == Mech.LOC_HEAD) {<br/>
                    en.crew.setDead(true);<br/>
                    desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                }<br/>
                return desc;<br/>
            }<br/>
            hits = 3;<br/>
            desc += " 3 locations.";<br/>
        }<br/>
        // transfer criticals, if needed<br/>
        if (hits &gt; 0 &amp;&amp; en.getHitableCriticals(loc) &lt;= 0<br/>
                &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_DESTROYED) {<br/>
            loc = en.getTransferLocation(loc);<br/>
            desc += "\n            Location is empty, so criticals transfer to " + en.getLocationAbbr(loc) +".";<br/>
        }<br/>
        // roll criticals<br/>
        while (hits &gt; 0) {<br/>
            if (en.getHitableCriticals(loc) &lt;= 0) {<br/>
                desc += "\n            Location empty.";<br/>
                break;<br/>
            }<br/>
            int slot = (int)(Compute.random.nextDouble() * en.getNumberOfCriticals(loc));<br/>
            CriticalSlot cs = en.getCritical(loc, slot);<br/>
            if (cs != null &amp;&amp; !cs.isHit()) {<br/>
                cs.setDoomed(true);<br/>
                en.setCritical(loc, slot, cs);<br/>
                switch(cs.getType()) {<br/>
                case CriticalSlot.TYPE_SYSTEM :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + Mech.systemNames[cs.getIndex()] + ".";<br/>
                    switch(cs.getIndex()) {<br/>
                    case Mech.SYSTEM_COCKPIT :<br/>
                        // boink!<br/>
                        en.crew.setDead(true);<br/>
                        desc += "\n*** " + en.getDisplayName() + " PILOT KILLED! ***";<br/>
                        break;<br/>
                    case Mech.SYSTEM_ENGINE :<br/>
                        if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, loc) &gt; 2) {<br/>
                            // third engine hit<br/>
                            en.setDoomed(true);<br/>
                            desc += "\n*** " + en.getDisplayName() + "ENGINE DESTROYED! ***";<br/>
                        }<br/>
                        break;<br/>
                    case Mech.SYSTEM_GYRO :<br/>
                        if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                            // gyro destroyed<br/>
                            pilotRolls.addElement(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FALL, "gyro destroyed"));<br/>
                        } else {<br/>
                            // first gyro hit<br/>
                            pilotRolls.addElement(new PilotingRollData(en.getId(), 3, "gyro hit"));<br/>
                        }<br/>
                        break;<br/>
                    case Mech.ACTUATOR_UPPER_LEG :<br/>
                    case Mech.ACTUATOR_LOWER_LEG :<br/>
                    case Mech.ACTUATOR_FOOT :<br/>
                        // leg/foot actuator piloting roll<br/>
                        pilotRolls.addElement(new PilotingRollData(en.getId(), 1, "leg/foot actuator hit"));<br/>
                        break;<br/>
                    case Mech.ACTUATOR_HIP :<br/>
                        // hip piloting roll<br/>
                        pilotRolls.addElement(new PilotingRollData(en.getId(), 2, "hip actuator hit"));<br/>
                        break;<br/>
                    }<br/>
                    break;<br/>
                case CriticalSlot.TYPE_WEAPON :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + en.getWeapon(cs.getIndex()).getType().getName() + ".";<br/>
                    en.getWeapon(cs.getIndex()).setDestroyed(true);<br/>
                    break;<br/>
                case CriticalSlot.TYPE_AMMO :<br/>
                    desc += "\n            &lt;&lt;&lt;CRITICAL HIT&gt;&gt;&gt; on " + en.getAmmo(cs.getIndex()).getName() + ".";<br/>
                    en.getWeapon(cs.getIndex()).setDestroyed(true);<br/>
                    desc += explodeAmmo(en, loc, slot);<br/>
                    break;<br/>
                }<br/>
                hits--;<br/>
                //System.err.println("s: critical loop, " + hits + " remaining");<br/>
            }<br/>
        }<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    private void destroyLocation(Entity en, int loc) {<br/>
        // mark armor, internal as destroyed<br/>
        en.setArmor(Entity.ARMOR_DESTROYED, loc);<br/>
        en.setInternal(Entity.ARMOR_DESTROYED, loc);<br/>
        if (en.getRearLocation(loc) != loc) {<br/>
            en.setArmor(Entity.ARMOR_DESTROYED, en.getRearLocation(loc));<br/>
        }<br/>
        // weapons destroyed<br/>
        for (int i = 0; i &lt; en.weapons.size(); i++) {<br/>
            if (en.getWeapon(i).getLocation() == loc) {<br/>
                en.getWeapon(i).setDestroyed(true);<br/>
            }<br/>
        }<br/>
        // ammo destroyed<br/>
        for (int i = 0; i &lt; en.ammo.size(); i++) {<br/>
            if (en.getAmmo(i).location == loc) {<br/>
                en.getAmmo(i).exploded = true;<br/>
            }<br/>
        }<br/>
        // all critical slots destroyed<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                cs.setDoomed(true);<br/>
            }<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Entity.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Explodes the ammo in the specified location and slot.<br/>
     */<br/>
    private String explodeAmmo(Entity en, int loc, int slot) {<br/>
        String desc = "";<br/>
        if (en.getCritical(loc, slot).getType() != CriticalSlot.TYPE_AMMO) {<br/>
            System.err.println("server: explodeAmmo called on non-ammo"<br/>
                               + " crititical slot (" + loc + " , " + slot + ")");<br/>
            return "";<br/>
        }<br/>
        // check amount of damage<br/>
        Ammo ammo = en.getAmmo(en.getCritical(loc, slot).getIndex());<br/>
        if (ammo.exploded) {<br/>
            System.err.println("server: explodeAmmo called already exploded ammo"<br/>
                               + " crititical slot (" + loc + " , " + slot + ")");<br/>
            return "";<br/>
        }<br/>
        int damage = ammo.damagePerShot * ammo.rackSize * ammo.shots;<br/>
        if (damage &lt;= 0) {<br/>
            return "";<br/>
        }<br/>
        // if there is damage, it's probably a lot<br/>
        desc += "\n*** AMMO EXPLOSION!  " + damage + " DAMAGE! ***";<br/>
        ammo.exploded = true;<br/>
        <span class="add"><span class="add"><span class="mv">desc</span> += <span class="add"><span class="add"><span class="mv">damageEntity</span>(<span class="mv">en</span>, <span class="add">new <span class="mv">HitData</span>(<span class="mv">loc</span>)</span>, <span class="mv">damage</span>)</span> + <span class="mv">"\n\n"</span></span></span>;</span><br/>
        // if the mech survives, the pilot takes damage<br/>
        if (!en.isDoomed() &amp;&amp; !en.isDestroyed()) {<br/>
            desc += damageCrew(en, 2) + "\n";<br/>
        }<br/>
<br/>
        return desc;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private String explodeAmmo(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                    if (cs != null &amp;&amp; !cs.isDestroyed()<br/>
                        &amp;&amp; cs.getType() == CriticalSlot.TYPE_AMMO) {<br/>
                      Ammo a = entity.getAmmo(cs.getIndex());<br/>
                      if (!a.exploded &amp;&amp; (rack &lt; a.damagePerShot * a.rackSize<br/>
                            || damage &lt; a.damagePerShot * a.rackSize * a.shots)) {<br/>
                            rack = a.damagePerShot * a.rackSize;<br/>
                            damage = a.damagePerShot * a.rackSize * a.shots;<br/>
                            boomloc = j;<br/>
                            boomslot = k;<br/>
                      }<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            return explodeAmmo(entity, boomloc, boomslot);<br/>
        } else {<br/>
            return "  Luckily, there is no ammo to explode.\n";<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height,<br/>
        int facing, int roll) {<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            phaseReport.append("But, since the 'mech is making a death from above attack, damage will be dealt during the physical phase.\n");<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }            <br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
        case 1:<br/>
        case 2:<br/>
            side = "right side";<br/>
            table = ToHitData.SIDE_RIGHT;<br/>
            break;<br/>
        case 3:<br/>
            side = "rear";<br/>
            table = ToHitData.SIDE_REAR;<br/>
            break;<br/>
        case 4:<br/>
        case 5:<br/>
            side = "left side";<br/>
            table = ToHitData.SIDE_LEFT;<br/>
            break;<br/>
        case 0:<br/>
        default:<br/>
            side = "front";<br/>
            table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        // calculate damage<br/>
        int damage = (int)Math.round(entity.getWeight() / 10) * (height + 1);<br/>
        <br/>
        // TODO: only fall to surface of water<br/>
        if (game.board.getHex(fallPos).getTerrainType() == Terrain.WATER) {<br/>
            damage = (int)Math.ceil(damage / 2.0);<br/>
        }<br/>
<br/>
        // report falling<br/>
        phaseReport.append("    " + entity.getDisplayName() + " falls on its " + side + ", suffering " + damage + " damage.");<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            <span class="add"><span class="add">HitData</span></span> <span class="mv">hit</span> = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            phaseReport.append(damageEntity(entity, <span class="add">hit</span>, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
<br/>
        // pilot damage?<br/>
        if (roll != PilotingRollData.AUTOMATIC_FALL) {<br/>
            roll += height;<br/>
        }<br/>
        if (roll &gt; 12) {<br/>
            phaseReport.append("\nPilot of " + entity.getDisplayName() + " \"" + entity.crew.getName() + "\" cannot avoid damage.\n");<br/>
            damageCrew(entity, 1);<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            phaseReport.append("\nPilot of " + entity.getDisplayName() + " \"" + entity.crew.getName() + "\" must roll " + roll + " to avoid damage; rolls " + diceRoll + " : " + (diceRoll &gt;= roll ? "succeeds" : "fails") + ".\n");<br/>
            if (diceRoll &lt; roll) {<br/>
                damageCrew(entity, 1);<br/>
            }<br/>
        }<br/>
<br/>
        entity.setProne(true);<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height,<br/>
                          int roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, int roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a random board filename<br/>
     *<br/>
     * TODO: make this search the boards directory for boards of the correct size<br/>
     */<br/>
    private String getRandomBoard() {<br/>
        String[] boards = {"battletech.board", "citytech.board",<br/>
                           "deepcanyon1.board", "deepcanyon2.board",<br/>
                           "deserthills.board",<br/>
                           "desertmountain1.board", "desertmountain2.board",<br/>
                           "heavyforest1.board", "heavyforest2.board",<br/>
                           "lakearea.board",<br/>
                           "largelakes1.board", "largelakes2.board",<br/>
                           "openterrain1.board", "openterrain2.board",<br/>
                           "rivervalley.board",<br/>
                           "rollinghills1.board", "rollinghills2.board",<br/>
                           "scatteredwoods.board",<br/>
                           "woodland.board"};<br/>
<br/>
        return boards[(int)(Compute.random.nextDouble() * boards.length)];<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Sets an entity ready status to false<br/>
     */<br/>
    private void receiveEntityReady(Packet pkt, int connIndex) {<br/>
        Entity entity = game.getEntity(pkt.getIntValue(0));<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)<br/>
            &amp;&amp; game.getTurn() == connIndex) {<br/>
            entity.ready = false;<br/>
        } else {<br/>
            System.out.println("server.receiveEntityReady: got an invalid ready message");<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
      * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
      */<br/>
     private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
<br/>
        entity.restore();<br/>
        entity.setOwner(getPlayer(connIndex));<br/>
        entity.setId(entityCounter++);<br/>
        game.addEntity(entity.getId(), entity);<br/>
<br/>
        send(createEntitiesPacket());<br/>
     }<br/>
<br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int enum = c.getIntValue(0);<br/>
        Entity entity = game.getEntity(enum);<br/>
        if (entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex)) {<br/>
            game.removeEntity(enum);<br/>
            send(createEntitiesPacket());<br/>
        } else {<br/>
            // hey! that's not your entity<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerReady(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        // don't let them enter the game with no entities<br/>
        if (ready &amp;&amp; game.phase == Game.PHASE_LOUNGE<br/>
            &amp;&amp; game.getEntitiesOwnedBy(getPlayer(connIndex)) &lt; 1) {<br/>
            ready = false;<br/>
        }<br/>
        getPlayer(connIndex).setReady(ready);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerReadys() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerReadyPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerReadyPacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isReady());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, gameSettings);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.board);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet containing the round report<br/>
     */<br/>
    private Packet createReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORT, roundReport.toString());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChatToAll(String origin, String message) {<br/>
        send(new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(EntityAction ea) {<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, ea);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
    for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
        final Connection conn = (Connection)i.nextElement();<br/>
            conn.connSend(packet);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        getClient(connId).connSend(packet);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        getPendingConnection(connId).connSend(packet);<br/>
    }<br/>
<br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
<br/>
                int id = connectionCounter++;<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
<br/>
                connectionsPending.addElement(new Connection(s, id));<br/>
<br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
                ;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
    * Listens for player messages and calls the appropriate<br/>
    * server functions.<br/>
    */<br/>
    class Connection implements Runnable {<br/>
        public Socket     socket;<br/>
        //public Player     player;<br/>
<br/>
        public int                id;<br/>
<br/>
        public Thread            receiver;<br/>
<br/>
<br/>
        public Connection(Socket socket, int id) {<br/>
            this.socket = socket;<br/>
            this.id = id;<br/>
<br/>
            // start pump thread<br/>
            receiver = new Thread(this);<br/>
            receiver.start();<br/>
        }<br/>
<br/>
        public int getId() {<br/>
            return id;<br/>
        }<br/>
<br/>
        /**<br/>
         * Kill off the thread<br/>
         */<br/>
        public void die() {<br/>
            receiver = null;<br/>
        }<br/>
<br/>
<br/>
        /**<br/>
         * Allow the player to set whatever parameters he is able to<br/>
         */<br/>
        private void receivePlayerInfo(Packet c) {<br/>
            Player player = (Player)c.getObject(0);<br/>
            game.getPlayer(id).setColorIndex(player.getColorIndex());<br/>
            game.getPlayer(id).setStartingPos(player.getStartingPos());<br/>
        }<br/>
<br/>
        /**<br/>
         * Reads a complete net command from the given socket<br/>
         */<br/>
        private Packet readCommand() {<br/>
            try {<br/>
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());<br/>
                Packet packet = (Packet)ois.readObject();<br/>
                return packet;<br/>
            } catch (IOException ex) {<br/>
                System.err.println("s(" + id + "): IO error reading command");<br/>
                disconnected(id);<br/>
                return null;<br/>
            } catch (ClassNotFoundException ex) {<br/>
                System.err.println("s(" + id + "): curPosass not found error reading command");<br/>
                disconnected(id);<br/>
                return null;<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Sends a packet!<br/>
         *<br/>
         * synchronized seems to keep this from getting munged.<br/>
         */<br/>
        public synchronized void connSend(Packet packet) {<br/>
            try {<br/>
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());<br/>
                oos.flush();<br/>
                oos.writeObject(packet);<br/>
                oos.flush();<br/>
                //System.out.println("s(" + cn + "): command #" + c.getCommand() + " sent");<br/>
            } catch(IOException ex) {<br/>
                System.err.println("s(" + id + "): error sending command.  dropping player");<br/>
                System.err.println(ex);<br/>
                System.err.println(ex.getMessage());<br/>
                disconnected(id);<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Process a packet<br/>
         */<br/>
        private void handle(Packet c) {<br/>
            //System.out.println("s(" + cn + "): received command");<br/>
            // act on it<br/>
            switch(c.getCommand()) {<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receiveClientName(c, id);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(c);<br/>
                validatePlayerInfo(id);<br/>
                send(createPlayerUpdatePacket(id));<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_READY :<br/>
                receiveEntityReady(c, id);<br/>
                send(createEntityPacket(c.getIntValue(0)));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerReady(c, id);<br/>
                send(createPlayerReadyPacket(id));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)c.getObject(0);<br/>
                sendChatToAll(getPlayer(id).getName(), chat);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                doEntityMovement(c, id);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(c);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(c, id);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(c, id);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                gameSettings = (GameSettings)c.getObject(0);<br/>
                resetPlayerReady();<br/>
                transmitAllPlayerReadys();<br/>
                send(createSettingsPacket());<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
<br/>
        /**<br/>
         * listen for packets &amp; handle them<br/>
         */<br/>
        public void run() {<br/>
            while (receiver == Thread.currentThread()) {<br/>
                handle(readCommand());<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>