<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_TilesetManager_1.22.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek - Copyright (C) 2002,2003,2004 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
/*<br/>
 * TilesetManager.java<br/>
 *<br/>
 * Created on April 15, 2002, 11:41 PM<br/>
 */<br/>
<br/>
package megamek.client;<br/>
<br/>
import com.sun.java.util.collections.*;<br/>
import java.awt.image.*;<br/>
import megamek.common.*;<br/>
<br/>
import java.awt.Component;<br/>
import java.awt.Image;<br/>
import java.awt.MediaTracker;<br/>
import java.io.File;<br/>
import megamek.client.util.ImageFileFactory;<br/>
import megamek.client.util.RotateFilter;<br/>
import megamek.client.util.TintFilter;<br/>
import megamek.client.util.widget.BufferedPanel;<br/>
import megamek.client.util.widget.BackGroundDrawer;<br/>
import megamek.common.util.DirectoryItems;<br/>
<br/>
/**<br/>
 * Handles loading and manipulating images from both the mech tileset and the<br/>
 * terrain tileset.<br/>
 *<br/>
 * @author  Ben<br/>
 * @version <br/>
 */<br/>
public class TilesetManager {<br/>
    // component to load images to<br/>
    private Component comp;<br/>
    <br/>
    // keep tracking of loading images<br/>
    private MediaTracker tracker;<br/>
    private boolean started = false;<br/>
    private boolean loaded = false;<br/>
<br/>
    // keep track of camo images<br/>
    private DirectoryItems camos;<br/>
    <br/>
    // mech images<br/>
    private MechTileset mechTileset = new MechTileset("data/mex/");<br/>
    private MechTileset wreckTileset = new MechTileset("data/mex/wrecks/");<br/>
    private ArrayList mechImageList = new ArrayList();<br/>
    private HashMap mechImages = new HashMap();<br/>
    <br/>
    // hex images<br/>
    private HexTileset hexTileset = new HexTileset();<br/>
    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;private Image minefieldSign;    <br/>
<br/>
    /** Creates new TilesetManager */<br/>
    public TilesetManager(Component comp) {<br/>
        this.comp = comp;<br/>
        this.tracker = new MediaTracker(comp);<br/>
        camos = new DirectoryItems( new File("data/camo"), "",<br/>
                                    ImageFileFactory.getInstance() );<br/>
<br/>
        mechTileset.loadFromFile("mechset.txt");<br/>
        wreckTileset.loadFromFile("wreckset.txt");<br/>
        hexTileset.loadFromFile(Settings.mapTileset);<br/>
<br/>
    }<br/>
    <br/>
    public Image iconFor(Entity entity) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == null) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == null) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
            }            <br/>
        }<br/>
        return entityImage.getIcon();<br/>
    }<br/>
<br/>
    public Image wreckMarkerFor(Entity entity) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == null) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == null) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
                <span class="del">return;</span><br/>
            }            <br/>
        }<br/>
        return entityImage.getWreckFacing(entity.getFacing());<br/>
    }<br/>
    /**<br/>
     * Return the image for the entity<br/>
     */<br/>
    public Image imageFor(Entity entity) {<br/>
        // mechs look like they're facing their secondary facing<br/>
        if (entity instanceof Mech) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;return imageFor(entity, entity.getSecondaryFacing());<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;return imageFor(entity, entity.getFacing());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
    }<br/>
<br/>
    public Image imageFor(Entity entity, int facing) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == <span class="mv">null</span>) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == <span class="mv">null</span>) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
            }            <br/>
        }<br/>
        // get image rotated for facing<br/>
        return entityImage.getFacing(facing);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return the base image for the hex<br/>
     */<br/>
    public Image baseFor(Hex hex) {<br/>
        if (hex.getBase() == <span class="mv">null</span>) {<br/>
            hexTileset.assignMatch(hex, comp);<br/>
        }<br/>
        return hex.getBase();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return a list of superimposed images for the hex<br/>
     */<br/>
    public List supersFor(Hex hex) {<br/>
        return hex.getSupers();<br/>
    }<br/>
    <br/>
    public Image getMinefieldSign() {<br/>
        return minefieldSign;<br/>
    }    <br/>
    <br/>
    /**<br/>
     * @returns true if we're in the process of loading some images<br/>
     */<br/>
    public boolean isStarted() {<br/>
        return started;<br/>
    }<br/>
    <br/>
    /**<br/>
     * @returns true if we're done loading images<br/>
     */<br/>
    public boolean isLoaded() {<br/>
        if (!loaded) {<br/>
            loaded = tracker.checkAll(true);<br/>
        }<br/>
        return started &amp;&amp; loaded;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Load all the images we'll need for the game and place them in the tracker<br/>
     */<br/>
    public void loadNeededImages(Game game) {<br/>
        loaded = false;<br/>
        <br/>
        // pre-match all hexes with images, load hex images<br/>
        for (int y = 0; y &lt; game.board.height; y++) {<br/>
            for (int x = 0; x &lt; game.board.width; x++) {<br/>
                Hex hex = game.board.getHex(x, y);<br/>
                loadHexImage(hex);<br/>
            }<br/>
        }<br/>
        <br/>
        // load all mech images<br/>
        for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            loadImage((Entity)i.nextElement());<br/>
        }<br/>
        <br/>
        // load minefield sign<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minefieldSign = comp.getToolkit().getImage(Minefield.IMAGE_FILE);<br/>
<br/>
        started = true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Loads the image(s) for this hex into the tracker.<br/>
     * @param hex the hex to load<br/>
     */<br/>
    private void loadHexImage(Hex hex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexTileset.assignMatch(hex, comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexTileset.trackHexImages(hex, tracker);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Waits until a certain hex's images are done loading.<br/>
     * @param hex the hex to wait for<br/>
     */<br/>
    public void waitForHex(Hex hex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadHexImage(hex);<br/>
        try {<br/>
            tracker.waitForID(1);<br/>
        } catch (InterruptedException e) {<br/>
            e.printStackTrace();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Loads all the hex tileset images<br/>
     */<br/>
    public void loadAllHexes() {<br/>
        hexTileset.loadAllImages(comp, tracker);<br/>
    }<br/>
    <br/>
    // Loads a preview image of the unit into the BufferedPanel.<br/>
    public void loadPreviewImage(Entity entity, Image camo, int tint, BufferedPanel bp) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image base = mechTileset.imageFor(entity, comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntityImage entityImage = new EntityImage(base, tint, camo, bp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image preview = entityImage.loadPreviewImage();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BackGroundDrawer bgdPreview = new BackGroundDrawer(preview);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bp.removeBgDrawers();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bp.addBgDrawer(bgdPreview);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker tracker = new MediaTracker(comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(preview, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the camo pattern for the given player.<br/>
     *<br/>
     * @param   player - the &lt;code&gt;Player&lt;/code&gt; whose camo pattern is needed.<br/>
     * @return  The &lt;code&gt;Image&lt;/code&gt; of the player's camo pattern.<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the player has selected<br/>
     *          no camo pattern or if there was an error loading it.<br/>
     */<br/>
    public Image getPlayerCamo( Player player ) {<br/>
<br/>
        // Return a null if the player has selected no camo file.<br/>
        if ( <span class="mv">null</span> == player.getCamoCategory() ||<br/>
             Player.NO_CAMO.equals( player.getCamoCategory() ) ) <span class="del">{<br/>
            <span class="del">return <span class="mv">null</span>;</span><br/>
        }</span><br/>
<br/>
        // Try to get the player's camo file.<br/>
        Image camo = <span class="mv">null</span>;<br/>
        try {<br/>
<br/>
            // Translate the root camo directory name.<br/>
            String category = player.getCamoCategory();<br/>
            if ( Player.ROOT_CAMO.equals( category ) ) category = "";<br/>
            camo = (Image) camos.getItem( category, player.getCamoFileName() );<br/>
<br/>
        } catch ( Exception err ) {<br/>
            err.printStackTrace();<br/>
        }<br/>
        return camo;<br/>
    }<br/>
<br/>
    /**<br/>
     * Load a single entity image<br/>
     */<br/>
    public void loadImage(Entity entity)<br/>
    {<br/>
        Image base = mechTileset.imageFor(entity, comp);<br/>
        Image wreck = <span class="mv">null</span>;<br/>
        if ( !(entity instanceof Infantry) &amp;&amp;<br/>
             !(entity instanceof Protomech) ) {<br/>
            wreck = wreckTileset.imageFor(entity, comp);<br/>
        }<br/>
        Player player = entity.getOwner();<br/>
        int tint = player.getColorRGB();<br/>
<br/>
        Image camo = getPlayerCamo( player );<br/>
        EntityImage entityImage = <span class="mv">null</span>;<br/>
<br/>
        // check if we have a duplicate image already loaded<br/>
        for (Iterator j = mechImageList.iterator(); j.hasNext();) {<br/>
            EntityImage onList = (EntityImage)j.next();<br/>
            if (onList.getBase() == base &amp;&amp; onList.tint == tint) {<br/>
                entityImage = onList;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // if we don't have a cached image, make a new one<br/>
        if (entityImage == <span class="mv">null</span>) {<br/>
            entityImage = new EntityImage(base, wreck, tint, camo, comp);<br/>
            mechImageList.add(entityImage);<br/>
            entityImage.loadFacings();<br/>
            for (int j = 0; j &lt; 6; j++) {<br/>
                tracker.addImage(entityImage.getFacing(j), 1);<br/>
            }<br/>
        }<br/>
<br/>
        // relate this id to this image set<br/>
        mechImages.put(new Integer(entity.getId()), entityImage);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resets the started and loaded flags<br/>
     */<br/>
    public void reset() {<br/>
        loaded = false;<br/>
        started = false;<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * A class to handle the image permutations for an entity<br/>
     */<br/>
    private class EntityImage {<br/>
        private Image base;<br/>
        private Image wreck;<br/>
        private Image icon;<br/>
        private int tint;<br/>
        private Image camo;<br/>
        private Image[] facings = new Image[6];<br/>
        private Image[] wreckFacings = new Image[6];<br/>
        private Component comp;<br/>
        <br/>
        private final int IMG_WIDTH = 84;        <br/>
        private final int IMG_HEIGHT = 72;<br/>
        private final int IMG_SIZE = IMG_WIDTH * IMG_HEIGHT;<br/>
        <br/>
        public EntityImage(Image base, int tint, Image camo, Component comp) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;this(base, <span class="mv">null</span>, tint, camo, comp);<br/>
        }<br/>
<br/>
        public EntityImage(Image base, Image wreck, int tint, Image camo, Component comp) {<br/>
            this.base = base;<br/>
            this.tint = tint;<br/>
            this.camo = camo;<br/>
            this.comp = comp;<br/>
            this.wreck = wreck;<br/>
        }<br/>
<br/>
        public void loadFacings() {<br/>
            base = applyColor(base);<br/>
            <br/>
            icon = base.getScaledInstance(56, 48, Image.SCALE_SMOOTH);<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                ImageProducer rotSource = new FilteredImageSource(base.getSource(), new RotateFilter((Math.PI / 3) * (6 - i)));<br/>
                facings[i] = comp.createImage(rotSource);<br/>
            }<br/>
<br/>
            if (wreck != <span class="mv">null</span>) {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;wreck = applyColor(wreck);<br/>
                for (int i = 0; i &lt; 6; i++) {<br/>
                    ImageProducer rotSource = new FilteredImageSource(wreck.getSource(), new RotateFilter((Math.PI / 3) * (6 - i)));<br/>
                    wreckFacings[i] = comp.createImage(rotSource);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        public Image loadPreviewImage() {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base = applyColor(base);<br/>
            return base;<br/>
        }<br/>
<br/>
        public Image getFacing(int facing) {<br/>
            return facings[facing];<br/>
        }<br/>
        <br/>
        public Image getWreckFacing(int facing) {<br/>
            return wreckFacings[facing];<br/>
        }<br/>
        <br/>
        public Image getBase() {<br/>
            return base;<br/>
        }<br/>
        <br/>
        public Image getIcon() {<br/>
            return icon;<br/>
        }<br/>
<br/>
        private Image applyColor(Image image) {<br/>
          Image iMech;<br/>
          boolean useCamo = (camo != <span class="mv">null</span>);<br/>
          <br/>
          iMech = image;<br/>
    <br/>
          int[] pMech = new int[IMG_SIZE];<br/>
          int[] pCamo = new int[IMG_SIZE];<br/>
          PixelGrabber pgMech = new PixelGrabber(iMech, 0, 0, IMG_WIDTH, IMG_HEIGHT, pMech, 0, IMG_WIDTH);<br/>
    <br/>
          try {<br/>
              pgMech.grabPixels();<br/>
          } catch (InterruptedException e) {<br/>
              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image." + e.getMessage());<br/>
              return image;<br/>
          }<br/>
          if ((pgMech.getStatus() &amp; ImageObserver.ABORT) != 0) {<br/>
              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image. ImageObserver aborted.");<br/>
              return image;<br/>
          }<br/>
          <br/>
          if (useCamo) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          PixelGrabber pgCamo = new PixelGrabber(camo, 0, 0, IMG_WIDTH, IMG_HEIGHT, pCamo, 0, IMG_WIDTH);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              pgCamo.grabPixels();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          } catch (InterruptedException e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("EntityImage.applyColor(): Failed to grab pixels for camo image." + e.getMessage());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              return image;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          if ((pgCamo.getStatus() &amp; ImageObserver.ABORT) != 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image. ImageObserver aborted.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              return image;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;      }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;      <br/>
          for (int i = 0; i &lt; IMG_SIZE; i++) {<br/>
            int pixel = pMech[i];<br/>
            int alpha = (pixel &gt;&gt; 24) &amp; 0xff;<br/>
          <br/>
            if (alpha != 0) {<br/>
              int pixel1 = useCamo ? pCamo[i] : tint;<br/>
              float red1   = ((float) ((pixel1 &gt;&gt; 16) &amp; 0xff)) / 255;<br/>
              float green1 = ((float) ((pixel1 &gt;&gt;  8) &amp; 0xff)) / 255;<br/>
              float blue1  = ((float) ((pixel1      ) &amp; 0xff)) / 255;<br/>
              <br/>
              float black = (float) ((pMech[i]) &amp; 0xff);<br/>
<br/>
              int red2   = (int)Math.round(red1   * black);<br/>
              int green2 = (int)Math.round(green1 * black);<br/>
              int blue2  = (int)Math.round(blue1  * black);<br/>
<br/>
              pMech[i] = (alpha &lt;&lt; 24) | (red2 &lt;&lt; 16) | (green2 &lt;&lt; 8) | blue2;<br/>
            }<br/>
          }<br/>
        <br/>
          image = comp.createImage(new MemoryImageSource(IMG_WIDTH, IMG_HEIGHT, pMech, 0, IMG_WIDTH));<br/>
          return image;<br/>
        }<br/>
    }<br/>
<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_TilesetManager_1.23.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek - Copyright (C) 2002,2003,2004 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
/*<br/>
 * TilesetManager.java<br/>
 *<br/>
 * Created on April 15, 2002, 11:41 PM<br/>
 */<br/>
<br/>
package megamek.client;<br/>
<br/>
import com.sun.java.util.collections.*;<br/>
import java.awt.image.*;<br/>
import megamek.common.*;<br/>
<br/>
import java.awt.Component;<br/>
import java.awt.Image;<br/>
import java.awt.MediaTracker;<br/>
import java.io.File;<br/>
import megamek.client.util.ImageFileFactory;<br/>
import megamek.client.util.RotateFilter;<br/>
import megamek.client.util.TintFilter;<br/>
import megamek.client.util.widget.BufferedPanel;<br/>
import megamek.client.util.widget.BackGroundDrawer;<br/>
import megamek.common.util.DirectoryItems;<br/>
<br/>
/**<br/>
 * Handles loading and manipulating images from both the mech tileset and the<br/>
 * terrain tileset.<br/>
 *<br/>
 * @author  Ben<br/>
 * @version <br/>
 */<br/>
public class TilesetManager {<br/>
    // component to load images to<br/>
    private Component comp;<br/>
    <br/>
    // keep tracking of loading images<br/>
    private MediaTracker tracker;<br/>
    private boolean started = false;<br/>
    private boolean loaded = false;<br/>
<br/>
    // keep track of camo images<br/>
    private DirectoryItems camos;<br/>
    <br/>
    // mech images<br/>
    private MechTileset mechTileset = new MechTileset("data/mex/");<br/>
    private MechTileset wreckTileset = new MechTileset("data/mex/wrecks/");<br/>
    private ArrayList mechImageList = new ArrayList();<br/>
    private HashMap mechImages = new HashMap();<br/>
    <br/>
    // hex images<br/>
    private HexTileset hexTileset = new HexTileset();<br/>
    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;private Image minefieldSign;    <br/>
<br/>
    /** Creates new TilesetManager */<br/>
    public TilesetManager(Component comp) {<br/>
        this.comp = comp;<br/>
        this.tracker = new MediaTracker(comp);<br/>
        camos = new DirectoryItems( new File("data/camo"), "",<br/>
                                    ImageFileFactory.getInstance() );<br/>
<br/>
        mechTileset.loadFromFile("mechset.txt");<br/>
        wreckTileset.loadFromFile("wreckset.txt");<br/>
        hexTileset.loadFromFile(Settings.mapTileset);<br/>
<br/>
    }<br/>
    <br/>
    public Image iconFor(Entity entity) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == null) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == null) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
            }            <br/>
        }<br/>
        return entityImage.getIcon();<br/>
    }<br/>
<br/>
    public Image wreckMarkerFor(Entity entity) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == null) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == null) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
                <span class="add">return <span class="mv">null</span>;</span><br/>
            }            <br/>
        }<br/>
        return entityImage.getWreckFacing(entity.getFacing());<br/>
    }<br/>
    /**<br/>
     * Return the image for the entity<br/>
     */<br/>
    public Image imageFor(Entity entity) {<br/>
        // mechs look like they're facing their secondary facing<br/>
        if (entity instanceof Mech) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;return imageFor(entity, entity.getSecondaryFacing());<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;&nbsp;&nbsp;return imageFor(entity, entity.getFacing());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
    }<br/>
<br/>
    public Image imageFor(Entity entity, int facing) {<br/>
        EntityImage entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
        if (entityImage == <span class="mv">null</span>) {<br/>
            // probably double_blind.  Try to load on the fly<br/>
            System.out.println("Loading image for " + entity.getShortName() + " on the fly.");<br/>
            loadImage(entity);<br/>
            entityImage = (EntityImage)mechImages.get(new Integer(entity.getId()));<br/>
            if (entityImage == <span class="mv">null</span>) {<br/>
                // now it's a real problem<br/>
                System.out.println("Unable to load image for entity: " + entity.getShortName());<br/>
            }            <br/>
        }<br/>
        // get image rotated for facing<br/>
        return entityImage.getFacing(facing);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return the base image for the hex<br/>
     */<br/>
    public Image baseFor(Hex hex) {<br/>
        if (hex.getBase() == <span class="mv">null</span>) {<br/>
            hexTileset.assignMatch(hex, comp);<br/>
        }<br/>
        return hex.getBase();<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return a list of superimposed images for the hex<br/>
     */<br/>
    public List supersFor(Hex hex) {<br/>
        return hex.getSupers();<br/>
    }<br/>
    <br/>
    public Image getMinefieldSign() {<br/>
        return minefieldSign;<br/>
    }    <br/>
    <br/>
    /**<br/>
     * @returns true if we're in the process of loading some images<br/>
     */<br/>
    public boolean isStarted() {<br/>
        return started;<br/>
    }<br/>
    <br/>
    /**<br/>
     * @returns true if we're done loading images<br/>
     */<br/>
    public boolean isLoaded() {<br/>
        if (!loaded) {<br/>
            loaded = tracker.checkAll(true);<br/>
        }<br/>
        return started &amp;&amp; loaded;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Load all the images we'll need for the game and place them in the tracker<br/>
     */<br/>
    public void loadNeededImages(Game game) {<br/>
        loaded = false;<br/>
        <br/>
        // pre-match all hexes with images, load hex images<br/>
        for (int y = 0; y &lt; game.board.height; y++) {<br/>
            for (int x = 0; x &lt; game.board.width; x++) {<br/>
                Hex hex = game.board.getHex(x, y);<br/>
                loadHexImage(hex);<br/>
            }<br/>
        }<br/>
        <br/>
        // load all mech images<br/>
        for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            loadImage((Entity)i.nextElement());<br/>
        }<br/>
        <br/>
        // load minefield sign<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minefieldSign = comp.getToolkit().getImage(Minefield.IMAGE_FILE);<br/>
<br/>
        started = true;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Loads the image(s) for this hex into the tracker.<br/>
     * @param hex the hex to load<br/>
     */<br/>
    private void loadHexImage(Hex hex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexTileset.assignMatch(hex, comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexTileset.trackHexImages(hex, tracker);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Waits until a certain hex's images are done loading.<br/>
     * @param hex the hex to wait for<br/>
     */<br/>
    public void waitForHex(Hex hex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadHexImage(hex);<br/>
        try {<br/>
            tracker.waitForID(1);<br/>
        } catch (InterruptedException e) {<br/>
            e.printStackTrace();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Loads all the hex tileset images<br/>
     */<br/>
    public void loadAllHexes() {<br/>
        hexTileset.loadAllImages(comp, tracker);<br/>
    }<br/>
    <br/>
    // Loads a preview image of the unit into the BufferedPanel.<br/>
    public void loadPreviewImage(Entity entity, Image camo, int tint, BufferedPanel bp) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image base = mechTileset.imageFor(entity, comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntityImage entityImage = new EntityImage(base, tint, camo, bp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image preview = entityImage.loadPreviewImage();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BackGroundDrawer bgdPreview = new BackGroundDrawer(preview);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bp.removeBgDrawers();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bp.addBgDrawer(bgdPreview);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker tracker = new MediaTracker(comp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(preview, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the camo pattern for the given player.<br/>
     *<br/>
     * @param   player - the &lt;code&gt;Player&lt;/code&gt; whose camo pattern is needed.<br/>
     * @return  The &lt;code&gt;Image&lt;/code&gt; of the player's camo pattern.<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the player has selected<br/>
     *          no camo pattern or if there was an error loading it.<br/>
     */<br/>
    public Image getPlayerCamo( Player player ) {<br/>
<br/>
        // Return a null if the player has selected no camo file.<br/>
        if ( <span class="mv">null</span> == player.getCamoCategory() ||<br/>
             Player.NO_CAMO.equals( player.getCamoCategory() ) ) <span class="add">{<br/>
            <span class="add">return <span class="mv">null</span>;</span><br/>
        }</span><br/>
<br/>
        // Try to get the player's camo file.<br/>
        Image camo = <span class="mv">null</span>;<br/>
        try {<br/>
<br/>
            // Translate the root camo directory name.<br/>
            String category = player.getCamoCategory();<br/>
            if ( Player.ROOT_CAMO.equals( category ) ) category = "";<br/>
            camo = (Image) camos.getItem( category, player.getCamoFileName() );<br/>
<br/>
        } catch ( Exception err ) {<br/>
            err.printStackTrace();<br/>
        }<br/>
        return camo;<br/>
    }<br/>
<br/>
    /**<br/>
     * Load a single entity image<br/>
     */<br/>
    public void loadImage(Entity entity)<br/>
    {<br/>
        Image base = mechTileset.imageFor(entity, comp);<br/>
        Image wreck = <span class="mv">null</span>;<br/>
        if ( !(entity instanceof Infantry) &amp;&amp;<br/>
             !(entity instanceof Protomech) ) {<br/>
            wreck = wreckTileset.imageFor(entity, comp);<br/>
        }<br/>
        Player player = entity.getOwner();<br/>
        int tint = player.getColorRGB();<br/>
<br/>
        Image camo = getPlayerCamo( player );<br/>
        EntityImage entityImage = <span class="mv">null</span>;<br/>
<br/>
        // check if we have a duplicate image already loaded<br/>
        for (Iterator j = mechImageList.iterator(); j.hasNext();) {<br/>
            EntityImage onList = (EntityImage)j.next();<br/>
            if (onList.getBase() == base &amp;&amp; onList.tint == tint) {<br/>
                entityImage = onList;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // if we don't have a cached image, make a new one<br/>
        if (entityImage == <span class="mv">null</span>) {<br/>
            entityImage = new EntityImage(base, wreck, tint, camo, comp);<br/>
            mechImageList.add(entityImage);<br/>
            entityImage.loadFacings();<br/>
            for (int j = 0; j &lt; 6; j++) {<br/>
                tracker.addImage(entityImage.getFacing(j), 1);<br/>
            }<br/>
        }<br/>
<br/>
        // relate this id to this image set<br/>
        mechImages.put(new Integer(entity.getId()), entityImage);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resets the started and loaded flags<br/>
     */<br/>
    public void reset() {<br/>
        loaded = false;<br/>
        started = false;<br/>
    }<br/>
    <br/>
    <br/>
    /**<br/>
     * A class to handle the image permutations for an entity<br/>
     */<br/>
    private class EntityImage {<br/>
        private Image base;<br/>
        private Image wreck;<br/>
        private Image icon;<br/>
        private int tint;<br/>
        private Image camo;<br/>
        private Image[] facings = new Image[6];<br/>
        private Image[] wreckFacings = new Image[6];<br/>
        private Component comp;<br/>
        <br/>
        private final int IMG_WIDTH = 84;        <br/>
        private final int IMG_HEIGHT = 72;<br/>
        private final int IMG_SIZE = IMG_WIDTH * IMG_HEIGHT;<br/>
        <br/>
        public EntityImage(Image base, int tint, Image camo, Component comp) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;this(base, <span class="mv">null</span>, tint, camo, comp);<br/>
        }<br/>
<br/>
        public EntityImage(Image base, Image wreck, int tint, Image camo, Component comp) {<br/>
            this.base = base;<br/>
            this.tint = tint;<br/>
            this.camo = camo;<br/>
            this.comp = comp;<br/>
            this.wreck = wreck;<br/>
        }<br/>
<br/>
        public void loadFacings() {<br/>
            base = applyColor(base);<br/>
            <br/>
            icon = base.getScaledInstance(56, 48, Image.SCALE_SMOOTH);<br/>
            for (int i = 0; i &lt; 6; i++) {<br/>
                ImageProducer rotSource = new FilteredImageSource(base.getSource(), new RotateFilter((Math.PI / 3) * (6 - i)));<br/>
                facings[i] = comp.createImage(rotSource);<br/>
            }<br/>
<br/>
            if (wreck != <span class="mv">null</span>) {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;wreck = applyColor(wreck);<br/>
                for (int i = 0; i &lt; 6; i++) {<br/>
                    ImageProducer rotSource = new FilteredImageSource(wreck.getSource(), new RotateFilter((Math.PI / 3) * (6 - i)));<br/>
                    wreckFacings[i] = comp.createImage(rotSource);<br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
        public Image loadPreviewImage() {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base = applyColor(base);<br/>
            return base;<br/>
        }<br/>
<br/>
        public Image getFacing(int facing) {<br/>
            return facings[facing];<br/>
        }<br/>
        <br/>
        public Image getWreckFacing(int facing) {<br/>
            return wreckFacings[facing];<br/>
        }<br/>
        <br/>
        public Image getBase() {<br/>
            return base;<br/>
        }<br/>
        <br/>
        public Image getIcon() {<br/>
            return icon;<br/>
        }<br/>
<br/>
        private Image applyColor(Image image) {<br/>
          Image iMech;<br/>
          boolean useCamo = (camo != <span class="add">null</span>);<br/>
          <br/>
          iMech = image;<br/>
    <br/>
          int[] pMech = new int[IMG_SIZE];<br/>
          int[] pCamo = new int[IMG_SIZE];<br/>
          PixelGrabber pgMech = new PixelGrabber(iMech, 0, 0, IMG_WIDTH, IMG_HEIGHT, pMech, 0, IMG_WIDTH);<br/>
    <br/>
          try {<br/>
              pgMech.grabPixels();<br/>
          } catch (InterruptedException e) {<br/>
              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image." + e.getMessage());<br/>
              return image;<br/>
          }<br/>
          if ((pgMech.getStatus() &amp; ImageObserver.ABORT) != 0) {<br/>
              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image. ImageObserver aborted.");<br/>
              return image;<br/>
          }<br/>
          <br/>
          if (useCamo) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          PixelGrabber pgCamo = new PixelGrabber(camo, 0, 0, IMG_WIDTH, IMG_HEIGHT, pCamo, 0, IMG_WIDTH);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              pgCamo.grabPixels();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          } catch (InterruptedException e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("EntityImage.applyColor(): Failed to grab pixels for camo image." + e.getMessage());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              return image;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          if ((pgCamo.getStatus() &amp; ImageObserver.ABORT) != 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              System.err.println("EntityImage.applyColor(): Failed to grab pixels for mech image. ImageObserver aborted.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;              return image;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;          }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;      }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;      <br/>
          for (int i = 0; i &lt; IMG_SIZE; i++) {<br/>
            int pixel = pMech[i];<br/>
            int alpha = (pixel &gt;&gt; 24) &amp; 0xff;<br/>
          <br/>
            if (alpha != 0) {<br/>
              int pixel1 = useCamo ? pCamo[i] : tint;<br/>
              float red1   = ((float) ((pixel1 &gt;&gt; 16) &amp; 0xff)) / 255;<br/>
              float green1 = ((float) ((pixel1 &gt;&gt;  8) &amp; 0xff)) / 255;<br/>
              float blue1  = ((float) ((pixel1      ) &amp; 0xff)) / 255;<br/>
              <br/>
              float black = (float) ((pMech[i]) &amp; 0xff);<br/>
<br/>
              int red2   = (int)Math.round(red1   * black);<br/>
              int green2 = (int)Math.round(green1 * black);<br/>
              int blue2  = (int)Math.round(blue1  * black);<br/>
<br/>
              pMech[i] = (alpha &lt;&lt; 24) | (red2 &lt;&lt; 16) | (green2 &lt;&lt; 8) | blue2;<br/>
            }<br/>
          }<br/>
        <br/>
          image = comp.createImage(new MemoryImageSource(IMG_WIDTH, IMG_HEIGHT, pMech, 0, IMG_WIDTH));<br/>
          return image;<br/>
        }<br/>
    }<br/>
<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>