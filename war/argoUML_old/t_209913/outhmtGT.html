<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_ModelFacade_1.209.java</h1>
<div class="code">
<div class="id">
// $Id: ModelFacade.java,v 1.209 2004-08-26 23:03:17 bobtarling Exp $<br/>
// Copyright (c) 2003-2004 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.Collections;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.argouml.model.uml.UmlFactory;<br/>
import org.argouml.model.uml.foundation.core.CoreHelper;<br/>
import org.argouml.model.uml.foundation.extensionmechanisms.ExtensionMechanismsHelper;<br/>
import org.argouml.uml.diagram.static_structure.ui.CommentEdge;<br/>
import org.tigris.gef.base.Diagram;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.MElementListener;<br/>
import ru.novosoft.uml.MExtension;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActionState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MCallState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MSubactivityState;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MActionSequence;<br/>
import ru.novosoft.uml.behavior.common_behavior.MArgument;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCallAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCreateAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDataValue;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDestroyAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MException;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MObject;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReturnAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSendAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.common_behavior.MStimulus;<br/>
import ru.novosoft.uml.behavior.common_behavior.MTerminateAction;<br/>
import ru.novosoft.uml.behavior.state_machines.MCallEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MChangeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MFinalState;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MSignalEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateImpl;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MSubmachineState;<br/>
import ru.novosoft.uml.behavior.state_machines.MTimeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtensionPoint;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationClass;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElement;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MPermission;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.core.MUsage;<br/>
import ru.novosoft.uml.foundation.data_types.MActionExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MExpressionEditor;<br/>
import ru.novosoft.uml.foundation.data_types.MIterationExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMessageDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicityRange;<br/>
import ru.novosoft.uml.foundation.data_types.MObjectSetExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MOperationDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MTimeExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MModel;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
import ru.novosoft.uml.model_management.MSubsystem;<br/>
<br/>
/**<br/>
 * Facade object for the Model component in ArgoUML.&lt;p&gt;<br/>
 *<br/>
 * The purpose of this Facade object is to allow for decoupling other modules<br/>
 * from the insides of the model. For this purpose all of the methods in this<br/>
 * class give away and accept handles (of type java.lang.Object) to the<br/>
 * objects within the model.&lt;p&gt;<br/>
 *<br/>
 * This is just getters and recognizers. This is because the Model<br/>
 * component has an extremely complicated internal data structure<br/>
 * with lots of internal dependencies. To manipulate these there is<br/>
 * a whole set of factories and helpers within the Model that is to<br/>
 * be used but to use them you need knowledge of the internals of<br/>
 * the Model, specifically the NS-UML objects.&lt;p&gt;<br/>
 *<br/>
 * All methods in this facade are static.&lt;p&gt;<br/>
 *<br/>
 * Signature for all recognizers in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static boolean isA&lt;TYPE&gt;(Object handle)<br/>
 * &lt;li&gt;public static boolean is&lt;PROPERTY&gt;(Object handle)<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * Signature for all getters in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static Object get&lt;TYPE&gt;(Object handle) - 1..1<br/>
 * &lt;li&gt;public static Iterator get&lt;TYPES&gt;(Object handle) - 0..*<br/>
 * &lt;li&gt;public static String getName(Object handle) - Name<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * @stereotype utility<br/>
 * @author Linus Tolke<br/>
 */<br/>
public class ModelFacade {<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // constants<br/>
<br/>
    // TODO: deprecate all of these constants in favor of a separate declaration<br/>
<br/>
    public static final short ACC_PUBLIC = 1;<br/>
    public static final short ACC_PRIVATE = 2;<br/>
    public static final short ACC_PROTECTED = 3;<br/>
<br/>
    public static final short CLASSIFIER_SCOPE = 1;<br/>
    public static final short INSTANCE_SCOPE = 2;<br/>
<br/>
    public static final short GUARDED = 1;<br/>
    public static final short SEQUENTIAL = 2;<br/>
<br/>
    // Types of line<br/>
    public static final Object ABSTRACTION = MAbstraction.class;<br/>
    public static final Object ASSOCIATION = MAssociation.class;<br/>
    public static final Object ASSOCIATION_CLASS = MAssociationClass.class;<br/>
    public static final Object ASSOCIATION_ROLE = MAssociationRole.class;<br/>
    public static final Object COLLABORATION = MCollaboration.class;<br/>
    public static final Object DEPENDENCY = MDependency.class;<br/>
    public static final Object EXTEND = MExtend.class;<br/>
    public static final Object GENERALIZATION = MGeneralization.class;<br/>
    public static final Object INCLUDE = MInclude.class;<br/>
    public static final Object LINK = MLink.class;<br/>
    public static final Object MESSAGE = MMessage.class;<br/>
    public static final Object PERMISSION = MPermission.class;<br/>
    public static final Object SIGNAL = MSignal.class;<br/>
    public static final Object USAGE = MUsage.class;<br/>
    public static final Object TRANSITION = MTransition.class;<br/>
<br/>
    // Types of node<br/>
    public static final Object ACTOR = MActor.class;<br/>
    public static final Object CLASS = MClass.class;<br/>
    public static final Object CLASSIFIER = MClassifier.class;<br/>
    public static final Object CLASSIFIER_ROLE = MClassifierRole.class;<br/>
    public static final Object COMMENT = MComment.class;<br/>
    public static final Object COMPONENT = MComponent.class;<br/>
    public static final Object COMPONENT_INSTANCE = MComponentInstance.class;<br/>
    public static final Object EXCEPTION = MException.class;<br/>
    public static final Object INSTANCE = MInstance.class;<br/>
    public static final Object INTERFACE = MInterface.class;<br/>
    public static final Object NODE = MNode.class;<br/>
    public static final Object NODE_INSTANCE = MNodeInstance.class;<br/>
    public static final Object OBJECT = MObject.class;<br/>
    public static final Object PACKAGE = MPackage.class;<br/>
    public static final Object MODEL = MModel.class;<br/>
    public static final Object SUBSYSTEM = MSubsystem.class;<br/>
    public static final Object STATE = MState.class;<br/>
    public static final Object STATEIMPL = MStateImpl.class;<br/>
    public static final Object COMPOSITESTATE = MCompositeState.class;<br/>
    public static final Object STATEVERTEX = MStateVertex.class;<br/>
    public static final Object PSEUDOSTATE = MPseudostate.class;<br/>
    public static final Object FINALSTATE = MFinalState.class;<br/>
    public static final Object USE_CASE = MUseCase.class;<br/>
    public static final Object CALLSTATE = MCallState.class;<br/>
    public static final Object OBJECTFLOWSTATE = MObjectFlowState.class;<br/>
    public static final Object SUBACTIVITYSTATE = MSubactivityState.class;<br/>
<br/>
    // Invisible model elements<br/>
    public static final Object ACTION = MAction.class;<br/>
    public static final Object ACTION_EXPRESSION = MActionExpression.class;<br/>
    public static final Object ACTION_STATE = MActionState.class;<br/>
    public static final Object ASSOCIATION_END = MAssociationEnd.class;<br/>
    public static final Object ASSOCIATION_END_ROLE = MAssociationEndRole.class;<br/>
    public static final Object CALL_ACTION = MCallAction.class;<br/>
    public static final Object CALLCONCURRENCYKIND = MCallConcurrencyKind.class;<br/>
    public static final Object CREATE_ACTION = MCreateAction.class;<br/>
    public static final Object DESTROY_ACTION = MDestroyAction.class;<br/>
    public static final Object TERMINATE_ACTION = MTerminateAction.class;<br/>
    public static final Object NAMESPACE = MNamespace.class;<br/>
    public static final Object RECEPTION = MReception.class;<br/>
    public static final Object RETURN_ACTION = MReturnAction.class;<br/>
    public static final Object SCOPEKIND = MScopeKind.class;<br/>
    public static final Object SEND_ACTION = MSendAction.class;<br/>
    public static final Object STEREOTYPE = MStereotype.class;<br/>
    public static final Object PARTITION = MPartition.class;<br/>
    public static final Object PARAMETER = MParameter.class;<br/>
    public static final Object PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.class;<br/>
    public static final Object GENERALAIZABLE_ELEMENT =<br/>
        MGeneralizableElement.class;<br/>
    public static final Object DATATYPE = MDataType.class;<br/>
    public static final Object STATEMACHINE = MStateMachine.class;<br/>
<br/>
    public static final Object ATTRIBUTE = MAttribute.class;<br/>
    public static final Object OPERATION = MOperation.class;<br/>
<br/>
    public static final Object MULTIPLICITY = MMultiplicity.class;<br/>
<br/>
    public static final Object VISIBILITYKIND = MVisibilityKind.class;<br/>
<br/>
    public static final Object MODELELEMENT = MModelElement.class;<br/>
    public static final Object STIMULUS = MStimulus.class;<br/>
<br/>
    public static final Object AGGREGATIONKIND = MAggregationKind.class;<br/>
    public static final Object BOOLEAN_EXPRESSION = MBooleanExpression.class;<br/>
    public static final Object GUARD = MGuard.class;<br/>
    public static final Object EVENT = MEvent.class;<br/>
<br/>
    public static final Object ADD_ONLY_CHANGEABLEKIND =<br/>
        MChangeableKind.ADD_ONLY;<br/>
    public static final Object CHANGEABLE_CHANGEABLEKIND =<br/>
        MChangeableKind.CHANGEABLE;<br/>
    public static final Object FROZEN_CHANGEABLEKIND = MChangeableKind.FROZEN;<br/>
<br/>
    public static final Object CONCURRENT_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.CONCURRENT;<br/>
<br/>
    public static final Object GUARDED_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.GUARDED;<br/>
<br/>
    public static final Object SEQUENTIAL_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.SEQUENTIAL;<br/>
<br/>
    public static final Object PSEUDOSTATEKIND = MPseudostateKind.class;<br/>
    public static final Object INITIAL_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.INITIAL;<br/>
    public static final Object DEEPHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.DEEP_HISTORY;<br/>
    public static final Object SHALLOWHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.SHALLOW_HISTORY;<br/>
    public static final Object FORK_PSEUDOSTATEKIND = MPseudostateKind.FORK;<br/>
    public static final Object JOIN_PSEUDOSTATEKIND = MPseudostateKind.JOIN;<br/>
    public static final Object JUNCTION_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.JUNCTION;<br/>
    public static final Object BRANCH_PSEUDOSTATEKIND = MPseudostateKind.BRANCH;<br/>
<br/>
    public static final Object PUBLIC_VISIBILITYKIND = MVisibilityKind.PUBLIC;<br/>
    public static final Object PRIVATE_VISIBILITYKIND = MVisibilityKind.PRIVATE;<br/>
    public static final Object PROTECTED_VISIBILITYKIND =<br/>
        MVisibilityKind.PROTECTED;<br/>
<br/>
    public static final Object AGGREGATE_AGGREGATIONKIND =<br/>
        MAggregationKind.AGGREGATE;<br/>
    public static final Object COMPOSITE_AGGREGATIONKIND =<br/>
        MAggregationKind.COMPOSITE;<br/>
    public static final Object NONE_AGGREGATIONKIND = MAggregationKind.NONE;<br/>
<br/>
    public static final Object ORDERED_ORDERINGKIND = MOrderingKind.ORDERED;<br/>
    public static final Object UNORDERED_ORDERINGKIND = MOrderingKind.UNORDERED;<br/>
    public static final Object SORTED_ORDERINGKIND = MOrderingKind.SORTED;<br/>
<br/>
    public static final Object M1_1_MULTIPLICITY = MMultiplicity.M1_1;<br/>
    public static final Object M0_1_MULTIPLICITY = MMultiplicity.M0_1;<br/>
    public static final Object M0_N_MULTIPLICITY = MMultiplicity.M0_N;<br/>
    public static final Object M1_N_MULTIPLICITY = MMultiplicity.M1_N;<br/>
<br/>
    public static final Object CLASSIFIER_SCOPEKIND = MScopeKind.CLASSIFIER;<br/>
    public static final Object INSTANCE_SCOPEKIND = MScopeKind.INSTANCE;<br/>
<br/>
    public static final Object INOUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.INOUT;<br/>
<br/>
    public static final Object IN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.IN;<br/>
<br/>
    public static final Object OUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.OUT;<br/>
<br/>
    public static final Object RETURN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.RETURN;<br/>
<br/>
<br/>
    /**<br/>
     * This tag is set on elements that are generated by reference when<br/>
     * importing.<br/>
     * If it is set, then the critics could ignore those objects if they want.<br/>
     */<br/>
    public static final String GENERATED_TAG = "GeneratedFromImport";<br/>
<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Object Creation methods<br/>
<br/>
    /**<br/>
     * Create a model object from the implementation.&lt;P&gt;<br/>
     *<br/>
     * This will allow abstraction of the create mechanism at a single point.<br/>
     *<br/>
     * TODO: Document the intention of this function.<br/>
     * It is not used anywhere in ArgoUML. <br/>
     * BTW: Does it work? I (MVW) once did a test, and it didn't.<br/>
     *<br/>
     * @param entity Class to create -<br/>
     * must implement {@link org.argouml.model.UmlModelEntity}<br/>
     * @return the created object or null if it cannot create the class.<br/>
     */<br/>
    public static Object create(ModelEntity entity) {<br/>
        if (entity instanceof UmlModelEntity) {<br/>
            return UmlFactory.getFactory().create((UmlModelEntity) entity);<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Abstraction.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Abstraction<br/>
     */<br/>
    public static boolean isAAbstraction(Object handle) {<br/>
        return handle instanceof MAbstraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action<br/>
     */<br/>
    public static boolean isAAction(Object handle) {<br/>
        return handle instanceof MAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionExpression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ActionExpression<br/>
     */<br/>
    public static boolean isAActionExpression(Object handle) {<br/>
        return handle instanceof MActionExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionSequence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an action sequence<br/>
     */<br/>
    public static boolean isAActionSequence(Object handle) {<br/>
        return handle instanceof MActionSequence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action state<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action state<br/>
     */<br/>
    public static boolean isAActionState(Object handle) {<br/>
        return handle instanceof MActionState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an call state<br/>
     */<br/>
    public static boolean isACallState(Object handle) {<br/>
        return handle instanceof MCallState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ObjectFlowState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an objectflow state<br/>
     */<br/>
    public static boolean isAObjectFlowState(Object handle) {<br/>
        return handle instanceof MObjectFlowState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SubactivityState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an subactivity state<br/>
     */<br/>
    public static boolean isASubactivityState(Object handle) {<br/>
        return handle instanceof MSubactivityState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Actor<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Actor<br/>
     */<br/>
    public static boolean isAActor(Object handle) {<br/>
        return handle instanceof MActor;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AggregationKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AggregationKind<br/>
     */<br/>
    public static boolean isAAggregationKind(Object handle) {<br/>
        return handle instanceof MAggregationKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Association.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Association<br/>
     */<br/>
    public static boolean isAAssociation(Object handle) {<br/>
        return handle instanceof MAssociation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEnd.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEnd<br/>
     */<br/>
    public static boolean isAAssociationEnd(Object handle) {<br/>
        return handle instanceof MAssociationEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationRole<br/>
     */<br/>
    public static boolean isAAssociationRole(Object handle) {<br/>
        return handle instanceof MAssociationRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEndRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEndRole<br/>
     */<br/>
    public static boolean isAAssociationEndRole(Object handle) {<br/>
        return handle instanceof MAssociationEndRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Attribute<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Attribute<br/>
     */<br/>
    public static boolean isAAttribute(Object handle) {<br/>
        return handle instanceof MAttribute;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for asynchronisity of an action<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the argument is asynchronous<br/>
     */<br/>
    public static boolean isAsynchronous(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).isAsynchronous();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for abstract classes and operations.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is abstract.<br/>
     */<br/>
    public static boolean isAbstract(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).isAbstract();<br/>
        if (handle instanceof MGeneralizableElement)<br/>
            return ((MGeneralizableElement) handle).isAbstract();<br/>
        if (handle instanceof MAssociation)<br/>
            return ((MAssociation) handle).isAbstract();<br/>
        // isAbstarct() is not a typo! mistake in nsuml!<br/>
        if (handle instanceof MReception)<br/>
            return ((MReception) handle).isAbstarct();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for ActivityGraph<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is ActivityGraph.<br/>
     */<br/>
    public static boolean isAActivityGraph(Object handle) {<br/>
        return handle instanceof MActivityGraph;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for bases. A base is an object that is some form of<br/>
     * an element in the model. MBase in Novosoft terms.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a base.<br/>
     */<br/>
    public static boolean isABase(Object handle) {<br/>
        return handle instanceof MBase;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for behavioral features.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a behavioral feature<br/>
     */<br/>
    public static boolean isABehavioralFeature(Object handle) {<br/>
        return handle instanceof MBehavioralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallAction<br/>
     */<br/>
    public static boolean isACallAction(Object handle) {<br/>
        return handle instanceof MCallAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallEvent<br/>
     */<br/>
    public static boolean isACallEvent(Object handle) {<br/>
        return handle instanceof MCallEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ChangeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ChangeEvent<br/>
     */<br/>
    public static boolean isAChangeEvent(Object handle) {<br/>
        return handle instanceof MChangeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Class<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Class<br/>
     */<br/>
    public static boolean isAClass(Object handle) {<br/>
        return handle instanceof MClass;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Classifier<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Classifier<br/>
     */<br/>
    public static boolean isAClassifier(Object handle) {<br/>
        return handle instanceof MClassifier;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierInState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierInState<br/>
     */<br/>
    public static boolean isAClassifierInState(Object handle) {<br/>
        return handle instanceof MClassifierInState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierRole<br/>
     */<br/>
    public static boolean isAClassifierRole(Object handle) {<br/>
        return handle instanceof MClassifierRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Comment<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Comment<br/>
     */<br/>
    public static boolean isAComment(Object handle) {<br/>
        return handle instanceof MComment;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Collaboration<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Collaboration<br/>
     */<br/>
    public static boolean isACollaboration(Object handle) {<br/>
        return handle instanceof MCollaboration;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Component<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Component<br/>
     */<br/>
    public static boolean isAComponent(Object handle) {<br/>
        return handle instanceof MComponent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ComponentInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ComponentInstance<br/>
     */<br/>
    public static boolean isAComponentInstance(Object handle) {<br/>
        return handle instanceof MComponentInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Constraint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Constraint<br/>
     */<br/>
    public static boolean isAConstraint(Object handle) {<br/>
        return handle instanceof MConstraint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CreateAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CreateAction<br/>
     */<br/>
    public static boolean isACreateAction(Object handle) {<br/>
        return handle instanceof MCreateAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataType<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataType<br/>
     */<br/>
    public static boolean isADataType(Object handle) {<br/>
        return handle instanceof MDataType;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataValue<br/>
     */<br/>
    public static boolean isADataValue(Object handle) {<br/>
        return handle instanceof MDataValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Dependency<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Dependency<br/>
     */<br/>
    public static boolean isADependency(Object handle) {<br/>
        return handle instanceof MDependency;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DestroyAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DestroyAction<br/>
     */<br/>
    public static boolean isADestroyAction(Object handle) {<br/>
        return handle instanceof MDestroyAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CompositeState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CompositeState<br/>
     */<br/>
    public static boolean isACompositeState(Object handle) {<br/>
        return handle instanceof MCompositeState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Element<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Element<br/>
     */<br/>
    public static boolean isAElement(Object handle) {<br/>
        return handle instanceof MElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementImport<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementImport<br/>
     */<br/>
    public static boolean isAElementImport(Object handle) {<br/>
        return handle instanceof MElementImport;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementListener<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementListener<br/>
     */<br/>
    public static boolean isAElementListener(Object handle) {<br/>
        return handle instanceof MElementListener;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementResidence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementResidence<br/>
     */<br/>
    public static boolean isAElementResidence(Object handle) {<br/>
        return handle instanceof MElementResidence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Event<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Event<br/>
     */<br/>
    public static boolean isAEvent(Object handle) {<br/>
        return handle instanceof MEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Exception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Exception<br/>
     */<br/>
    public static boolean isAException(Object handle) {<br/>
        return handle instanceof MException;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Expression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Expression<br/>
     */<br/>
    public static boolean isAExpression(Object handle) {<br/>
        return handle instanceof MExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Extend<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Extend<br/>
     */<br/>
    public static boolean isAExtend(Object handle) {<br/>
        return handle instanceof MExtend;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ExtensionPoint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ExtensionPoint<br/>
     */<br/>
    public static boolean isAExtensionPoint(Object handle) {<br/>
        return handle instanceof MExtensionPoint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Feature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Feature<br/>
     */<br/>
    public static boolean isAFeature(Object handle) {<br/>
        return handle instanceof MFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for FinalState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a FinalState<br/>
     */<br/>
    public static boolean isAFinalState(Object handle) {<br/>
        return handle instanceof MFinalState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Flow<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Flow<br/>
     */<br/>
    public static boolean isAFlow(Object handle) {<br/>
        return handle instanceof MFlow;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Guard<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Guard<br/>
     */<br/>
    public static boolean isAGuard(Object handle) {<br/>
        return handle instanceof MGuard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralizableElement(Object handle) {<br/>
        return handle instanceof MGeneralizableElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralization(Object handle) {<br/>
        return handle instanceof MGeneralization;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Include<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Include<br/>
     */<br/>
    public static boolean isAInclude(Object handle) {<br/>
        return handle instanceof MInclude;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Instance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Instance<br/>
     */<br/>
    public static boolean isAInstance(Object handle) {<br/>
        return handle instanceof MInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interaction<br/>
     */<br/>
    public static boolean isAInteraction(Object handle) {<br/>
        return handle instanceof MInteraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interface<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interface<br/>
     */<br/>
    public static boolean isAInterface(Object handle) {<br/>
        return handle instanceof MInterface;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Link<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Link<br/>
     */<br/>
    public static boolean isALink(Object handle) {<br/>
        return handle instanceof MLink;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for LinkEnd<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a LinkEnd<br/>
     */<br/>
    public static boolean isALinkEnd(Object handle) {<br/>
        return handle instanceof MLinkEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Message<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMessage(Object handle) {<br/>
        return handle instanceof MMessage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Method<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMethod(Object handle) {<br/>
        return handle instanceof MMethod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Model<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Model<br/>
     */<br/>
    public static boolean isAModel(Object handle) {<br/>
        return handle instanceof MModel;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ModelElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ModelElement<br/>
     */<br/>
    public static boolean isAModelElement(Object handle) {<br/>
        return handle instanceof MModelElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Multiplicity<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Multiplicity<br/>
     */<br/>
    public static boolean isAMultiplicity(Object handle) {<br/>
        return handle instanceof MMultiplicity;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MultiplicityRange<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a MultiplicityRange<br/>
     */<br/>
    public static boolean isAMultiplicityRange(Object handle) {<br/>
        return handle instanceof MMultiplicityRange;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Namespace<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Namespace<br/>
     */<br/>
    public static boolean isANamespace(Object handle) {<br/>
        return handle instanceof MNamespace;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Node<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Node<br/>
     */<br/>
    public static boolean isANode(Object handle) {<br/>
        return handle instanceof MNode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a NodeInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a NodeInstance<br/>
     */<br/>
    public static boolean isANodeInstance(Object handle) {<br/>
        return handle instanceof MNodeInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Operation<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Operation<br/>
     */<br/>
    public static boolean isAOperation(Object handle) {<br/>
        return handle instanceof MOperation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Object<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Object<br/>
     */<br/>
    public static boolean isAObject(Object handle) {<br/>
        return handle instanceof MObject;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Parameter<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Parameter<br/>
     */<br/>
    public static boolean isAParameter(Object handle) {<br/>
        return handle instanceof MParameter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Partition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Partition<br/>
     */<br/>
    public static boolean isAPartition(Object handle) {<br/>
        return handle instanceof MPartition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Permission<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Permission<br/>
     */<br/>
    public static boolean isAPermission(Object handle) {<br/>
        return handle instanceof MPermission;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Package<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Package<br/>
     */<br/>
    public static boolean isAPackage(Object handle) {<br/>
        return handle instanceof MPackage;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Pseudostate<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Pseudostate<br/>
     */<br/>
    public static boolean isAPseudostate(Object handle) {<br/>
        return handle instanceof MPseudostate;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for PseudostateKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a PseudostateKind<br/>
     */<br/>
    public static boolean isAPseudostateKind(Object handle) {<br/>
        return handle instanceof MPseudostateKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate<br/>
     * <br/>
     * TODO: - Do we need this as well as getKind - I think not<br/>
     * <br/>
     * @param handle the Pseudostate<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getPseudostateKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate or Parameter<br/>
     * @param handle the Pseudostate or Parameter<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receiver object of a message or stimulus<br/>
     * @param handle candidate<br/>
     * @return receiver<br/>
     */<br/>
    public static Object getReceiver(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getReceiver();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getReceiver();<br/>
        }<br/>
    return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the Link belonging to the given LinkEnd<br/>
     * @param handle the LinkEnd<br/>
     * @return the Link<br/>
     */<br/>
    public static Object getLink(Object handle) {<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getLink();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Check whether two pseudostatekinds are equal/of the same type.<br/>
     *<br/>
     * @return true if the are the same type<br/>
     * @param ps1 one kind<br/>
     * @param ps2 one kind<br/>
     */<br/>
    public static boolean equalsPseudostateKind(Object ps1, Object ps2) {<br/>
        if (isAPseudostateKind(ps1)) {<br/>
            return ((MPseudostateKind) ps1).equals(ps2);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(ps1);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Reception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Reception<br/>
     */<br/>
    public static boolean isAReception(Object handle) {<br/>
        return handle instanceof MReception;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Returnaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a returnaction<br/>
     */<br/>
    public static boolean isAReturnAction(Object handle) {<br/>
        return handle instanceof MReturnAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Relationship<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Relationship<br/>
     */<br/>
    public static boolean isARelationship(Object handle) {<br/>
        return handle instanceof MRelationship;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SendAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SendAction<br/>
     */<br/>
    public static boolean isASendAction(Object handle) {<br/>
        return handle instanceof MSendAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Signal<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Signal<br/>
     */<br/>
    public static boolean isASignal(Object handle) {<br/>
        return handle instanceof MSignal;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SignalEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SignalEvent<br/>
     */<br/>
    public static boolean isASignalEvent(Object handle) {<br/>
        return handle instanceof MSignalEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateMachine<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateMachine<br/>
     */<br/>
    public static boolean isAStateMachine(Object handle) {<br/>
        return handle instanceof MStateMachine;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for stimulus<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a stimulus<br/>
     */<br/>
    public static boolean isAStimulus(Object handle) {<br/>
        return handle instanceof MStimulus;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateVertex<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateVertex<br/>
     */<br/>
    public static boolean isAStateVertex(Object handle) {<br/>
        return handle instanceof MStateVertex;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Stereotype<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Stereotype<br/>
     */<br/>
    public static boolean isAStereotype(Object handle) {<br/>
        return handle instanceof MStereotype;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StructuralFeature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StructuralFeature<br/>
     */<br/>
    public static boolean isAStructuralFeature(Object handle) {<br/>
        return handle instanceof MStructuralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for State<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a State<br/>
     */<br/>
    public static boolean isAState(Object handle) {<br/>
        return handle instanceof MState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Subsystem<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Subsystem<br/>
     */<br/>
    public static boolean isASubsystem(Object handle) {<br/>
        return handle instanceof MSubsystem;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TaggedValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TaggedValue<br/>
     */<br/>
    public static boolean isATaggedValue(Object handle) {<br/>
        return handle instanceof MTaggedValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Transition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isATransition(Object handle) {<br/>
        return handle instanceof MTransition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TimeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TimeEvent<br/>
     */<br/>
    public static boolean isATimeEvent(Object handle) {<br/>
        return handle instanceof MTimeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Usage<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Usage<br/>
     */<br/>
    public static boolean isAUsage(Object handle) {<br/>
        return handle instanceof MUsage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Use Case<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isAUseCase(Object handle) {<br/>
        return handle instanceof MUseCase;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for VisibilityKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a VisibilityKind<br/>
     */<br/>
    public static boolean isAVisibilityKind(Object handle) {<br/>
        return handle instanceof MVisibilityKind;<br/>
    }<br/>
<br/>
    /** <br/>
     * Recognizer for Classes that are Active<br/>
     *  <br/>
     * @param handle candidate<br/>
     * @return true if Class is Active<br/>
     */<br/>
    public static boolean isActive(Object handle) {<br/>
        if (handle instanceof MClass) {<br/>
            return ((MClass) handle).isActive();<br/>
        }<br/>
    return illegalArgumentBoolean(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for attributes that are changeable<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is changeable<br/>
     */<br/>
    public static boolean isChangeable(Object handle) {<br/>
        if (handle != null &amp;&amp; handle instanceof MStructuralFeature) {<br/>
            MChangeableKind changeability =<br/>
                ((MStructuralFeature) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
<br/>
        } else if (handle != null &amp;&amp; handle instanceof MAssociationEnd) {<br/>
            MChangeableKind changeability =<br/>
                ((MAssociationEnd) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with classifier scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has classifier scope.<br/>
     */<br/>
    public static boolean isClassifierScope(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MAttribute a = (MAttribute) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(a.getOwnerScope());<br/>
        }<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature f = (MFeature) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(f.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for concurent composite state.<br/>
     *<br/>
     * @param handle composite state<br/>
     * @return true if concurent.<br/>
     */<br/>
    public static boolean isConcurent(Object handle) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            return ((MCompositeState) handle).isConcurent();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for constructor.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a constructor.<br/>
     */<br/>
    public static boolean isConstructor(Object handle) {<br/>
        Object stereo = null;<br/>
        if (isAOperation(handle)) {<br/>
            if (ModelFacade.getStereotypes(handle).size() &gt; 0) {<br/>
                stereo = ModelFacade.getStereotypes(handle).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
        if (isAMethod(handle)) {<br/>
            Object specification =<br/>
                CoreHelper.getHelper().getSpecification(handle);<br/>
            if (ModelFacade.getStereotypes(specification).size() &gt; 0) {<br/>
                stereo =<br/>
                    ModelFacade.getStereotypes(specification).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the given element is Frozen<br/>
     * @param handle candidate<br/>
     * @return boolean true if Frozen<br/>
     */<br/>
    public static boolean isFrozen(Object handle) {<br/>
        if (handle instanceof MChangeableKind) {<br/>
            MChangeableKind ck = (MChangeableKind) handle;<br/>
            return MChangeableKind.FROZEN.equals(ck);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isComposite(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.COMPOSITE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isAggregate(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.AGGREGATE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes that are initialized.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the attribute is initialized.<br/>
     */<br/>
    public static boolean isInitialized(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MExpression init = ((MAttribute) handle).getInitialValue();<br/>
<br/>
            if (init != null<br/>
                &amp;&amp; init.getBody() != null<br/>
                &amp;&amp; init.getBody().trim().length() &gt; 0)<br/>
                return true;<br/>
            return false;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with instance scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has instance scope.<br/>
     */<br/>
    public static boolean isInstanceScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature a = (MFeature) handle;<br/>
            return MScopeKind.INSTANCE.equals(a.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for internal transitions.<br/>
     *<br/>
     * @author mvw<br/>
     * @param handle candidate<br/>
     * @return true if handle is an internal transition.<br/>
     */<br/>
    public static boolean isInternal(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            Object state = getState(handle);<br/>
            Object end0 = getSource(handle);<br/>
            Object end1 = getTarget(handle);<br/>
            if (end0 != null) {<br/>
                return ((state == end0) &amp;&amp; (state == end1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
        }<br/>
        return illegalArgumentBoolean(handle);<br/>
    }<br/>
    /**<br/>
     * Recognizer for leafs<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isLeaf(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isLeaf();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for roots<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isRoot(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isRoot();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for specifications<br/>
     *<br/>
     * @param handle candidate ModelElement<br/>
     * @return true if handle is a specification<br/>
     */<br/>
    public static boolean isSpecification(Object handle) {<br/>
<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).isSpecification();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Navigable elements<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is navigable<br/>
     */<br/>
    public static boolean isNavigable(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).isNavigable();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for primary objects.&lt;p&gt;<br/>
     *<br/>
     * A primary object is an object that is created by the parser or<br/>
     * by a user.<br/>
     * Object that are created when importing some other object are not.&lt;p&gt;<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if primary object.<br/>
     */<br/>
    public static boolean isPrimaryObject(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            for (Iterator i = element.getTaggedValues().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.hasNext(); ) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if ((GENERATED_TAG).equals(tv.getTag())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
            return true;<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with private<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has private<br/>
     */<br/>
    public static boolean isPrivate(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PRIVATE.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with public<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has public<br/>
     */<br/>
    public static boolean isPublic(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PUBLIC.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MBehaviouralFeature's that are queries.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if it is a query<br/>
     */<br/>
    public static boolean isQuery(Object handle) {<br/>
<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MBehavioralFeature) handle).isQuery();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with protected<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has protected<br/>
     */<br/>
    public static boolean isProtected(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PROTECTED.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for realize<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has a realize stereotype<br/>
     */<br/>
    public static boolean isRealize(Object handle) {<br/>
        return isStereotype(handle, "realize");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for return<br/>
     *<br/>
     * @param handle candidate parameter<br/>
     * @return true if handle is a return parameter.<br/>
     */<br/>
    public static boolean isReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            MParameter p = (MParameter) handle;<br/>
            return MParameterDirectionKind.RETURN.equals(p.getKind());<br/>
<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for singleton.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a singleton.<br/>
     */<br/>
    public static boolean isSingleton(Object handle) {<br/>
        return isStereotype(handle, "singleton");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for model elements with a given stereotype.<br/>
     *<br/>
     * @param handle candidate model element<br/>
     * @param stereotypename a string that is the stereotype name.<br/>
     * @return true if handle is an object that has the given stereotype.<br/>
     */<br/>
    public static boolean isStereotype(Object handle, String stereotypename) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            MStereotype meSt = element.getStereotype();<br/>
<br/>
            if (meSt == null)<br/>
                return false;<br/>
<br/>
            String name = meSt.getName();<br/>
            if (name == null)<br/>
                return false;<br/>
<br/>
            return name.equalsIgnoreCase(stereotypename);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /** Returns true if the given CompositeState is the top state<br/>
     * @param handle CompositeState<br/>
     * @return boolean true if top state<br/>
     */<br/>
    public static boolean isTop(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getStateMachine() != null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for type.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a type.<br/>
     */<br/>
    public static boolean isType(Object handle) {<br/>
        return isStereotype(handle, "type");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for utility.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a utility.<br/>
     */<br/>
    public static boolean isUtility(Object handle) {<br/>
        return isStereotype(handle, "utility");<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the diagrams (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Diagram.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a diagram.<br/>
     */<br/>
    public static boolean isADiagram(Object handle) {<br/>
        return handle instanceof Diagram;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Getters for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Returns the association connected to an association end or<br/>
     * the association belonging to the given link.<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociation(Object handle) {<br/>
<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAssociation();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((MLink) handle).getAssociation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the association end between some classifier and some associaton.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param assoc is the association<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociationEnd(Object handle, Object assoc) {<br/>
        if (handle instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; assoc instanceof MAssociation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifier classifier = (MClassifier) handle;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = classifier.getAssociationEnds().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAssociationEnd end = (MAssociationEnd) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((MAssociation) assoc).getConnections().contains(end))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return end;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, assoc);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Association Ends<br/>
     *<br/>
     * @param handle the object that we get the association ends from.<br/>
     * @return Collection with association ends.<br/>
     */<br/>
    public static Collection getAssociationEnds(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection endc = ((MClassifier) handle).getAssociationEnds();<br/>
            return endc;<br/>
        }<br/>
<br/>
        //...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of association roles<br/>
     *<br/>
     * @param handle the object that we get the association roles from.<br/>
     * @return Collection of association roles.<br/>
     */<br/>
    public static Collection getAssociationRoles(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getAssociationRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Attributes.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return iterator with attributes.<br/>
     */<br/>
    public static Collection getAttributes(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            //return getStructuralFeatures(c).iterator();<br/>
            //...But I (thn) got CVS conflicts, so:<br/>
            return getStructuralFeatures(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The baseclass of some stereotype<br/>
     * @param handle the stereotype<br/>
     * @return the baseclass<br/>
     */<br/>
    public static Object getBaseClass(Object handle) {<br/>
        if (isAStereotype(handle)) {<br/>
            return ((MStereotype) handle).getBaseClass();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The base of some model element<br/>
     * There is a bug in NSUML which gets the addition and base <br/>
     * relationships back to front for include relationships. Solve<br/>
     * by reversing their accessors in the code<br/>
     * @param handle the model element<br/>
     * @return the base<br/>
     */<br/>
    public static Object getBase(Object handle) {<br/>
        if (handle instanceof MAssociationEndRole) {<br/>
            return ((MAssociationEndRole) handle).getBase();<br/>
        } else if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getBase();<br/>
        } else if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getBase();<br/>
        } else if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getAddition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the bases of a classifier role.<br/>
     *<br/>
     *<br/>
     * @param handle classifier role.<br/>
     * @return the bases.<br/>
     */<br/>
    public static Collection getBases(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getBases();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behaviors of a Modelelement.<br/>
     *<br/>
     *<br/>
     * @param handle modelelement to examine.<br/>
     * @return the behaviors.<br/>
     */<br/>
    public static Collection getBehaviors(Object handle) {<br/>
        if (isAModelElement(handle))<br/>
            return ((MModelElement) handle).getBehaviors();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behavioral feature of an parameter.<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the behavioral feature.<br/>
     */<br/>
    public static Object getBehavioralFeature(Object handle) {<br/>
        if (handle instanceof MParameter)<br/>
            return ((MParameter) handle).getBehavioralFeature();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the body of an method/constraint/expression.<br/>
     *<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the body.<br/>
     */<br/>
    public static Object getBody(Object handle) {<br/>
        if (handle instanceof MMethod)<br/>
            return ((MMethod) handle).getBody();<br/>
        if (handle instanceof MConstraint)<br/>
            return ((MConstraint) handle).getBody();<br/>
        if (handle instanceof MExpression)<br/>
            return ((MExpression) handle).getBody();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return Changeability of a StructuralFeature or a AssociationEnd<br/>
     * @param handle the StructuralFeature or AssociationEnd<br/>
     * @return the Changeability<br/>
     */<br/>
    public static Object getChangeability(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getChangeability();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getChangeability();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Get the child of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the child.<br/>
     */<br/>
    public static Object getChild(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getChild();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the children of some generalizable element<br/>
     *<br/>
     * @param handle to the generalizable element.<br/>
     * @return a collection with all children.<br/>
     */<br/>
    public static Collection getChildren(Object handle) {<br/>
        if (isAGeneralizableElement(handle)) {<br/>
            return ((MGeneralizableElement) handle).getChildren();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers roles of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifiers roles of the instance<br/>
     */<br/>
    public static Collection getClassifierRoles(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getClassifierRoles();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifierRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifierss of some instance<br/>
     * @param handle the instance<br/>
     * @return the classifierss of the instance<br/>
     */<br/>
    public static Collection getClassifiers(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getClassifiers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers in state of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifierss in state<br/>
     */<br/>
    public static Collection getClassifiersInState(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifiersInState();<br/>
        }<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getClassifiersInState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the clients of some dependency<br/>
     * @param handle the dependency<br/>
     * @return the clients of the dependency<br/>
     */<br/>
    public static Collection getClients(Object handle) {<br/>
        if (isADependency(handle)) {<br/>
            return ((MDependency) handle).getClients();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the client dependencies of some classifier<br/>
     *<br/>
     * @param handle to the classifier.<br/>
     * @return an iterator with all client dependencies.<br/>
     */<br/>
    public static Collection getClientDependencies(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            Collection c = ((MModelElement) handle).getClientDependencies();<br/>
            return c;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the condition of an extend.<br/>
     *<br/>
     * @param handle The extend.<br/>
     * @return the condition<br/>
     */<br/>
    public static Object getCondition(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getCondition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the concurrency of an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @return the concurrency.<br/>
     */<br/>
    public static Object getConcurrency(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getConcurrency();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    //    public static short getConcurrency(Object handle) {<br/>
    //        if (handle != null &amp;&amp; handle instanceof MOperation) {<br/>
    //            return ((MOperation) handle).getConcurrency()<br/>
    //                == MCallConcurrencyKind.GUARDED<br/>
    //                ? GUARDED<br/>
    //                : SEQUENTIAL;<br/>
    //        }<br/>
    //        illegalArgument(handle);<br/>
    //        return (short) 0;<br/>
    //    }<br/>
<br/>
    /**<br/>
     * The list of connections to an association or link.<br/>
     *<br/>
     * @param handle to the association or link<br/>
     * @return a Collection with all connections.<br/>
     */<br/>
    public static Collection getConnections(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
            return ((MLink) handle).getConnections();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a model element contains a connection.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param connection is the connection that is searched for.<br/>
     * @return true if the model element contains a connection<br/>
     */<br/>
    public boolean containsConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections().contains(<br/>
                connection);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return the effect<br/>
     */<br/>
    public static Object getEffect(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getEffect();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the residences of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the residences of<br/>
     * @return the residence collection<br/>
     */<br/>
    public static Collection getElementResidences(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getElementResidences();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the ElementImports of this ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of ElementImports<br/>
     */<br/>
    public static Collection getElementImports2(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getElementImports2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the entry action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the entry<br/>
     */<br/>
    public static Object getEntry(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getEntry();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the exit action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the exit action<br/>
     */<br/>
    public static Object getExit(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getExit();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Expression belonging to a Guard, ChangeEvent or timeEvent<br/>
     * @param handle the Object to get the Expression from<br/>
     * @return Object the Expression<br/>
     */<br/>
    public static Object getExpression(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getExpression();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MChangeEvent) {<br/>
            return ((MChangeEvent) handle).getChangeExpression();<br/>
        }<br/>
        if (handle instanceof MTimeEvent) {<br/>
            return ((MTimeEvent) handle).getWhen();<br/>
        }       <br/>
        return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case or extension point<br/>
     *<br/>
     * @param handle is the use case or the extension point<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends();<br/>
        }<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getExtends();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the use case extension of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @return The extension<br/>
     */<br/>
    public static Object getExtension(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtension();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Extensionpoint at given index-number<br/>
     * @param handle Extend<br/>
     * @param index int<br/>
     * @return ExtensionPoint<br/>
     */<br/>
    public static Object getExtensionPoint(Object handle, int index) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoint(index);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case or the extend<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtensionPoints(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtensionPoints();<br/>
        }<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Features from a Classifier.<br/>
     *<br/>
     * @param handle Classifier to retrieve from.<br/>
     * @return Collection with Features<br/>
     */<br/>
    public static Collection getFeatures(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getFeatures();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.<br/>
     *<br/>
     * @param handle is the child<br/>
     * @param parent is the parent<br/>
     * @return The generalization<br/>
     */<br/>
    public static Object getGeneralization(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralizableElement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = getGeneralizations(handle).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MGeneralization gen = (MGeneralization) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gen.getParent() == parent) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return gen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Generalizations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Generalizations<br/>
     */<br/>
    public static Collection getGeneralizations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getGeneralizations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the guard for some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getGuard(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getGuard();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Icon of a Stereotype<br/>
     * @param handle the Stereotype to get the Icon from<br/>
     * @return the Icon<br/>
     */<br/>
    public static Object getIcon(Object handle) {<br/>
        if (handle instanceof MStereotype) {<br/>
            return ((MStereotype) handle).getIcon();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the component of some element residence<br/>
     *<br/>
     * @param handle is an element residence<br/>
     * @return component<br/>
     */<br/>
    public static Object getImplementationLocation(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getImplementationLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the incoming transitions for some statevertex<br/>
     *<br/>
     * @param handle is the state vertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getIncomings(Object handle) {<br/>
        if (isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getIncomings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the initial value for some attribute.<br/>
     *<br/>
     * @param handle is the attribute<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInitialValue(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            return ((MAttribute) handle).getInitialValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the instance of an AttributeLink or LinkEnd<br/>
     *<br/>
     * @param handle is the attribute link or link end<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInstance(Object handle) {<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getInstance();<br/>
        }<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getInstance();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Instances for some Clasifier<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInstances(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getInstances();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of States for some ClasifierInState<br/>
     *<br/>
     * @param handle is the classifierInState<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInStates(Object handle) {<br/>
        if (handle instanceof MClassifierInState) {<br/>
            return ((MClassifierInState) handle).getInStates();<br/>
        }<br/>
    return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interaction for some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the interaction<br/>
     */<br/>
    public static Object getInteraction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getInteraction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interactions belonging to a collaboration<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInteractions(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getInteractions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the internal transitions belonging to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInternalTransitions(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getInternalTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages(Object handle) {<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getMessages();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some other message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages3(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the messages that are activated by the given message<br/>
     * @param handle Message<br/>
     * @return the Collection of Messages<br/>
     */<br/>
    public static Collection getMessages4(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages4();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages received by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages1(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages1();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages send by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages2(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the model of some model element<br/>
     *<br/>
     * @param handle to the model element.<br/>
     * @return model for the model element.<br/>
     */<br/>
    public static Object getModel(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            MModel m = ((MModelElement) handle).getModel();<br/>
            return m;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle an Element Import.<br/>
     * @return the model element<br/>
     */<br/>
    public static Object getModelElement(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MElementImport) handle).getModelElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Multiplicity from a model element.<br/>
     *<br/>
     * @param handle model element to retrieve from.<br/>
     * @return multiplicity<br/>
     */<br/>
    public static Object getMultiplicity(Object handle) {<br/>
        if ((handle instanceof MAssociationEnd)) {<br/>
            return ((MAssociationEnd) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MAssociationRole)) {<br/>
            return ((MAssociationRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MClassifierRole)) {<br/>
            return ((MClassifierRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MStructuralFeature)) {<br/>
            return ((MStructuralFeature) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Ranges from a Multiplicity.<br/>
     *<br/>
     * @param handle multiplicity to retrieve from.<br/>
     * @return iterator containing ranges<br/>
     */<br/>
    public static Iterator getRanges(Object handle) {<br/>
        if ((handle instanceof MMultiplicity)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection c = ((MMultiplicity) handle).getRanges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (c == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return c.iterator();<br/>
        }<br/>
        illegalArgument(handle);<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the comments of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the comments of<br/>
     * @return the comment (or null)<br/>
     */<br/>
    public static Collection getComments(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getComments();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication connection of an message.<br/>
     *<br/>
     * @param handle the message that we are getting the communication<br/>
     * connection<br/>
     * @return the communication connection<br/>
     */<br/>
    public static Object getCommunicationConnection(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getCommunicationConnection();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication link of a stimulus.<br/>
     *<br/>
     * @param handle the message that we are getting the communication link<br/>
     * @return the communication link<br/>
     */<br/>
    public static Object getCommunicationLink(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getCommunicationLink();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the collaborations of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the<br/>
     * collaborations of.<br/>
     * @return the collaborations<br/>
     */<br/>
    public static Collection getCollaborations(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public static void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the component instance of an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @return the component instance<br/>
     */<br/>
    public static Object getComponentInstance(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getComponentInstance();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the collection of ConstrainingElements of a Collaboration<br/>
     * @param handle the Collaboration<br/>
     * @return the collection of ConstrainingElements<br/>
     */<br/>
    public static Collection getConstrainingElements(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getConstrainingElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the collection of all constraints of the given ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of all constraints<br/>
     */<br/>
    public static Collection getConstraints(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getConstraints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the container for the given modelelement. The container is the<br/>
     * owner of the modelelement. It will be null for elements that don't have<br/>
     * an owner. All elements except for the root element in a project should<br/>
     * have an owner. The root element is allways a model.&lt;p&gt;<br/>
     *<br/>
     * In  the future, this function could return the container of Figs too.<br/>
     *<br/>
     * @param handle is the base<br/>
     * @return Object<br/>
     */<br/>
    public static Object getModelElementContainer(Object handle) {<br/>
        if (handle instanceof MBase) {<br/>
            return ((MBase) handle).getModelElementContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the CompositeState that is the container of the given StateVertex<br/>
     * @param handle the StateVertex<br/>
     * @return the CompositeState that is the container <br/>
     */<br/>
    public static Object getContainer(Object handle) {<br/>
        if (handle instanceof MStateVertex) {<br/>
            return ((MStateVertex) handle).getContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the collection of ModelElements contained in a Partition<br/>
     * @param handle the Partition<br/>
     * @return the contents of the Partition<br/>
     */<br/>
    public static Collection getContents(Object handle) {<br/>
        if (handle instanceof MPartition) {<br/>
            return ((MPartition) handle).getContents();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction.<br/>
     *<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */<br/>
    public static Object getContext(Object handle) {<br/>
        if (isAStateMachine(handle)) {<br/>
            return ((MStateMachine) handle).getContext();<br/>
        }<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getContext();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the collection of the Contexts of a given Signal<br/>
     * @param handle the Signal<br/>
     * @return a collection of the Contexts<br/>
     */<br/>
    public static Collection getContexts(Object handle) {<br/>
        if (handle instanceof MSignal) {<br/>
            return ((MSignal) handle).getContexts();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the collection of Actions that create/instantiate<br/>
     *  the given Classifier <br/>
     * <br/>
     * @param handle the Classifier<br/>
     * @return a collection containing all the creating actions<br/>
     */<br/>
    public static Collection getCreateActions(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCreateActions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the default value of a parameter<br/>
     *<br/>
     * @param handle the parameter that we are getting the defaultvalue from<br/>
     * @return the default value<br/>
     */<br/>
    public static Object getDefaultValue(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getDefaultValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get deferrable events of a state<br/>
     *<br/>
     * @param handle the state that we are getting the deferrable event from<br/>
     * @return the deferrable events collection<br/>
     */<br/>
    public static Collection getDeferrableEvents(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getDeferrableEvents();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */<br/>
    public static Collection getDeploymentLocations(Object handle) {<br/>
        if (isAComponent(handle)) {<br/>
            return ((MComponent) handle).getDeploymentLocations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the discriminator.<br/>
     *<br/>
     * @param handle the Generalization<br/>
     * @return the discriminator a String<br/>
     */<br/>
    public static Object getDiscriminator(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getDiscriminator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * <br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */<br/>
    public static void setDiscriminator(Object handle, String discriminator) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the dispatchaction of a stimulus.<br/>
     *<br/>
     * @param handle the stimulus that we are getting the dispatchaction of<br/>
     * @return the dispatchaction (or null)<br/>
     */<br/>
    public static Object getDispatchAction(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getDispatchAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the do activity action of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the do activity<br/>
     */<br/>
    public static Object getDoActivity(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getDoActivity();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the Links of a given Association<br/>
     * @param handle the Association<br/>
     * @return the collection of Links<br/>
     */<br/>
    public static Collection getLinks(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getLinks();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the LinkEnds of a given Instance or AssociationEnd<br/>
     * @param handle the candidate<br/>
     * @return the collection of LinkEnds<br/>
     */<br/>
    public static Collection getLinkEnds(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getLinkEnds();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getLinkEnds();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets a location of some extension point.<br/>
     *<br/>
     * @param handle extension point<br/>
     * @return the location<br/>
     */<br/>
    public static String getLocation(Object handle) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the methods of an operation.<br/>
     *<br/>
     * @param handle the operation that we are getting the methods of<br/>
     * @return methods collection (or null)<br/>
     */<br/>
    public static Collection getMethods(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).getMethods();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the namespace of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the namespace of<br/>
     * @return the namespace (or null)<br/>
     */<br/>
    public static Object getNamespace(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getNamespace();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the node instance of a component instance.<br/>
     *<br/>
     * @param handle the model element that we are getting the node instance of<br/>
     * @return the node instance<br/>
     */<br/>
    public static Object getNodeInstance(Object handle) {<br/>
        if (handle instanceof MComponentInstance)<br/>
            return ((MComponentInstance) handle).getNodeInstance();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The collection of object flow states<br/>
     *<br/>
     * @param handle the classifier<br/>
     * @return collection of object flow states<br/>
     */<br/>
    public static Collection getObjectFlowStates(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getObjectFlowStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the operation of a Call Action or Call Event.<br/>
     *<br/>
     * @param handle the model element that we are getting the operation of<br/>
     * @return the Operation<br/>
     */<br/>
    public static Object getOperation(Object handle) {<br/>
        if (handle instanceof MCallAction) {<br/>
            return ((MCallAction) handle).getOperation();<br/>
        }<br/>
        if (handle instanceof MCallEvent) {<br/>
            return ((MCallEvent) handle).getOperation();<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of operations.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Collection with operations.<br/>
     */<br/>
    public static Collection getOperations(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            return getOperations(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of Operations of this classifier and all inherited.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Iterator with operations.<br/>
     */<br/>
    public static Iterator getOperationsInh(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            return CoreHelper.getHelper().getOperationsInh(c).iterator();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the opposite end of an association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @return Object the opposite end.<br/>
     */<br/>
    public static Object getOppositeEnd(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getOppositeEnd();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get ordering of an association end<br/>
     *<br/>
     * @param handle association end to retrieve from<br/>
     * @return ordering<br/>
     */<br/>
    public static Object getOrdering(Object handle) {<br/>
        if (handle instanceof MAssociationEnd)<br/>
            return ((MAssociationEnd) handle).getOrdering();<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the list of Transitions outgoing from the given stateVertex.<br/>
     *<br/>
     * @param handle statevertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getOutgoings(Object handle) {<br/>
        if (ModelFacade.isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getOutgoings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of Associations Ends connected to this association end.<br/>
     *<br/>
     * @param handle association end to start from<br/>
     * @return Iterator with all connected association ends.<br/>
     */<br/>
    public static Collection getOtherAssociationEnds(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            MAssociation a = ((MAssociationEnd) handle).getAssociation();<br/>
<br/>
            if (a == null)<br/>
                return emptyCollection();<br/>
<br/>
            Collection allEnds = a.getConnections();<br/>
            if (allEnds == null)<br/>
                return emptyCollection();<br/>
<br/>
            // TODO: An Iterator filter would be nice here instead of the<br/>
            // mucking around with the Collection.<br/>
            allEnds = new ArrayList(allEnds);<br/>
            allEnds.remove(handle);<br/>
            return allEnds;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of owned elements of the the package.<br/>
     *<br/>
     * @param handle package to retrieve from.<br/>
     * @return Iterator with operations<br/>
     */<br/>
    public static Collection getOwnedElements(Object handle) {<br/>
        if (handle instanceof MNamespace) {<br/>
            return ((MNamespace) handle).getOwnedElements();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the owner scope of a feature<br/>
     *<br/>
     * @param handle feature<br/>
     * @return owner scope<br/>
     */<br/>
    public static Object getOwnerScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getOwnerScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the powertype of a generalization<br/>
     *<br/>
     * @param handle generalization<br/>
     * @return powertype<br/>
     */<br/>
    public static Object getPowertype(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getPowertype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the powertype ranges of a classifier.<br/>
     *<br/>
     * @param handle classifier to retrieve from<br/>
     * @return collection of poertype ranges<br/>
     */<br/>
    public static Collection getPowertypeRanges(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getPowertypeRanges();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the predecessors of a message.<br/>
     *<br/>
     * @param handle message to retrieve from<br/>
     * @return collection of predecessors<br/>
     */<br/>
    public static Collection getPredecessors(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getPredecessors();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if the passed parameter has a RETURN direction kind<br/>
     *<br/>
     * @return true if it is a return direction kind<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static boolean hasReturnParameterDirectionKind(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MParameter parameter = (MParameter) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameterDirectionKind.RETURN.equals(parameter.getKind()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Package that is connected by the given ElementImport <br/>
     * @param handle the ElementImport <br/>
     * @return the Package<br/>
     */<br/>
    public static Object getPackage(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
            return ((MElementImport) handle).getPackage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get a parameter of a behavioral feature.<br/>
     *<br/>
     * @param handle behavioral feature to retrieve from<br/>
     * @param n parameter number<br/>
     * @return parameter.<br/>
     */<br/>
    public static Object getParameter(Object handle, int n) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) handle).getParameter(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the parameters of a Object Flow State, Behavioral Feature, <br/>
     * Classifier or Event.<br/>
     *<br/>
     * @param handle operation to retrieve from<br/>
     * @return Iterator with operations.<br/>
     */<br/>
    public static Collection getParameters(Object handle) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MEvent) {<br/>
            return ((MEvent) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getParameters();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the parent.<br/>
     */<br/>
    public static Object getParent(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getParent();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the raised signals of an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @return raised signals<br/>
     */<br/>
    public static Collection getRaisedSignals(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getRaisedSignals();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receptions of a signal.<br/>
     *<br/>
     * @param handle is the signal<br/>
     * @return receptions<br/>
     */<br/>
    public static Collection getReceptions(Object handle) {<br/>
        if (handle instanceof MSignal) {<br/>
            return ((MSignal) handle).getReceptions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the recurrence iteration expression of an action.<br/>
     *<br/>
     * @param handle is the action.<br/>
     * @return the recurrence<br/>
     */<br/>
    public static Object getRecurrence(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getRecurrence();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the represented classifier of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented classifier<br/>
     */<br/>
    public static Object getRepresentedClassifier(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getRepresentedClassifier();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the represented operation of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented operation<br/>
     */<br/>
    public static Object getRepresentedOperation(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getRepresentedOperation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the script belonging to a given action<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the script<br/>
     */<br/>
    public static Object getScript(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getScript();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     *<br/>
     * @param handle is the stimulus or message<br/>
     * @return the sender<br/>
     */<br/>
    public static Object getSender(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getSender();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getSender();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     * TODO: Check if this javadoc comment is really correct?<br/>
     *<br/>
     * @param handle is the object<br/>
     * @return the signal<br/>
     */<br/>
    public static Object getSignal(Object handle) {<br/>
        if (handle instanceof MSendAction) {<br/>
            return ((MSendAction) handle).getSignal();<br/>
        }<br/>
        if (handle instanceof MSignalEvent) {<br/>
            return ((MSignalEvent) handle).getSignal();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).getSignal();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the resident element<br/>
     *<br/>
     * @param handle is the element residence<br/>
     * @return resident element<br/>
     */<br/>
    public static Object getResident(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getResident();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of elements in a given component<br/>
     * @param handle the component<br/>
     * @return the Collection of ResidentElements<br/>
     */<br/>
    public static Collection getResidentElements(Object handle) {<br/>
        if (handle instanceof MComponent) {<br/>
            return ((MComponent) handle).getResidentElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a collection with all residents belonging to the given<br/>
     * node.<br/>
     *<br/>
     * @param handle is the node, nodeinstance, componentinstance<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getResidents(Object handle) {<br/>
        if (isANode(handle)) {<br/>
            return ((MNode) handle).getResidents();<br/>
        }<br/>
        if (isANodeInstance(handle)) {<br/>
            return ((MNodeInstance) handle).getResidents();<br/>
        }<br/>
        if (isAComponentInstance(handle)) {<br/>
            return ((MComponentInstance) handle).getResidents();<br/>
        }<br/>
            <br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the source for a given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object (MStateVertex)<br/>
     */<br/>
    public static Object getSource(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getSource();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the source for some given flow.<br/>
     *<br/>
     * @param handle is the flow<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getSources(Object handle) {<br/>
        if (handle instanceof MFlow) {<br/>
            return ((MFlow) handle).getSources();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sourceflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of sourceflows<br/>
     */<br/>
    public static Collection getSourceFlows(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getSourceFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Specializations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Collection of Specializations.<br/>
     */<br/>
    public static Collection getSpecializations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getSpecializations();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the state machine belonging to some given state or transition<br/>
     * If you need to find the StateMachine for an internal transition,<br/>
     * or for ANY state, <br/>
     * use StateMachinesHelper.getStateMachine() instead.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getStateMachine(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getStateMachine();<br/>
        }<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the state belonging to some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getState(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the states from a deferable event<br/>
     *<br/>
     * @param handle is the event<br/>
     * @return Object<br/>
     */<br/>
    public static Collection getStates(Object handle) {<br/>
        if (handle instanceof MEvent) {<br/>
            return ((MEvent) handle).getStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stereotype belonging to some given model element<br/>
     *<br/>
     * @param handle is a model element<br/>
     * @return Object<br/>
     * @deprecated 0.15 in favor of getStereotypes since UML 1.5 supports <br/>
     * multiple stereotypes<br/>
     */<br/>
    public static Object getStereoType(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            return ((MModelElement) handle).getStereotype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stereotypes belonging to some given model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return stereotype collection<br/>
     */<br/>
    public static Collection getStereotypes(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            // This returns a collection as we have an eye on the future<br/>
            // and multiple stereotypes in UML1.5<br/>
            ArrayList list = new ArrayList(1);<br/>
            list.add(((MModelElement) handle).getStereotype());<br/>
            return list;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stimuli belonging to some given link<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return Object<br/>
     */<br/>
    public static Collection getStimuli(Object handle) {<br/>
        if (isALink(handle)) {<br/>
            return ((MLink) handle).getStimuli();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Stimuli that are received by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */<br/>
    public static Collection getStimuli2(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getStimuli2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Stimuli that are send by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */<br/>
    public static Collection getStimuli3(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getStimuli3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a collection with all subvertices belonging to the given<br/>
     * composite state.<br/>
     *<br/>
     * @param handle is the composite state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getSubvertices(Object handle) {<br/>
        if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getSubvertices();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the submachie of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */<br/>
    public static Object getSubmachine(Object handle) {<br/>
        if (handle instanceof MSubmachineState) {<br/>
            return ((MSubmachineState) handle).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the submachine of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */<br/>
    public static Collection getSubmachineStates(Object handle) {<br/>
        if (handle instanceof MStateMachine) {<br/>
            return ((MStateMachine) handle).getSubmachineStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of SupplierDependencies from a ModelElement.<br/>
     *<br/>
     * @param handle model element.<br/>
     * @return Iterator with the supplier dependencies.<br/>
     */<br/>
    public static Collection getSupplierDependencies(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            return me.getSupplierDependencies();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The top of a state machine<br/>
     *<br/>
     * @param handle the state machine<br/>
     * @return the top<br/>
     */<br/>
    public static Object getTop(Object handle) {<br/>
        if (handle instanceof MStateMachine) {<br/>
            return ((MStateMachine) handle).getTop();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the transition of a guard or action<br/>
     *<br/>
     * @param handle the guard or action<br/>
     * @return the transition<br/>
     */<br/>
    public static Object getTransition(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getTransition();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getTransition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the trigger of a transition<br/>
     *<br/>
     * @param handle the transition<br/>
     * @return the trigger<br/>
     */<br/>
    public static Object getTrigger(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getTrigger();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The type of a StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     *<br/>
     * @param handle the StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     * @return the type<br/>
     */<br/>
    public static Object getType(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MAttribute) handle).getType();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getType();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getType();<br/>
        }<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) handle).getType();<br/>
        }<br/>
        <br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the target of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getTarget(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getTarget();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the target scope of some model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Object<br/>
     */<br/>
    public static Object getTargetScope(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getTargetScope();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getTargetScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the targetflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of targetflows<br/>
     */<br/>
    public static Collection getTargetFlows(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTargetFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */<br/>
    public static int getUpper(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            int upper = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getMultiplicity() != null)<br/>
                upper = end.getMultiplicity().getUpper();<br/>
            return upper;<br/>
        }<br/>
        if (isAMultiplicity(handle)) {<br/>
            MMultiplicity up = (MMultiplicity) handle;<br/>
            return up.getUpper();<br/>
        }<br/>
        if (isAMultiplicityRange(handle)) {<br/>
            MMultiplicityRange up = (MMultiplicityRange) handle;<br/>
            return up.getUpper();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the use case of an extension point<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @return a use case<br/>
     */<br/>
    public static Object getUseCase(Object handle) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getUseCase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */<br/>
    public static int getLower(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            int lower = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getMultiplicity() != null)<br/>
                lower = end.getMultiplicity().getLower();<br/>
            return lower;<br/>
        }<br/>
        if (isAMultiplicity(handle)) {<br/>
            MMultiplicity low = (MMultiplicity) handle;<br/>
            return low.getLower();<br/>
        }<br/>
        if (isAMultiplicityRange(handle)) {<br/>
            MMultiplicityRange low = (MMultiplicityRange) handle;<br/>
            return low.getLower();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the transitions belonging to the given handle. The handle can be<br/>
     * a statemachine or a composite state or an event. <br/>
     * If it's a statemachine the<br/>
     * transitions will be given back belonging to that statemachine. If it's a<br/>
     * compositestate the internal transitions of that compositestate will be<br/>
     * given back. <br/>
     * If it's an event, all transitions triggered by this event <br/>
     * will be given back.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getTransitions(Object handle) {<br/>
        if (isAStateMachine(handle)) {<br/>
            return ((MStateMachine) handle).getTransitions();<br/>
        } else if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getInternalTransitions();<br/>
        } else if (isAEvent(handle)) {<br/>
            return ((MEvent) handle).getTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param handle is the classifier you want to have the attributes for.<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public static Collection getStructuralFeatures(Object handle) {<br/>
        Collection result = new ArrayList();<br/>
        if (ModelFacade.isAClassifier(handle)) {<br/>
            MClassifier mclassifier = (MClassifier) handle;<br/>
<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (ModelFacade.isAStructuralFeature(feature))<br/>
                    result.add(feature);<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier<br/>
     *<br/>
     * @param mclassifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    protected static Collection getOperations(MClassifier mclassifier) {<br/>
        Collection result = new ArrayList();<br/>
        Iterator features = mclassifier.getFeatures().iterator();<br/>
        while (features.hasNext()) {<br/>
            MFeature feature = (MFeature) features.next();<br/>
            if (ModelFacade.isAOperation(feature))<br/>
                result.add(feature);<br/>
        }<br/>
        return result;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the Specification of a given Reception<br/>
     * @param handle the Reception<br/>
     * @return String the Specification<br/>
     */<br/>
    public static String getSpecification(Object handle) {<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).getSpecification();<br/>
        }<br/>
        return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all Interfaces of which this class is a realization.<br/>
     *<br/>
     * @param handle  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */<br/>
    public static Collection getSpecifications(Object handle) {<br/>
        Collection result = new Vector();<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getSpecifications();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection deps = ((MClassifier) handle).getClientDependencies();<br/>
            Iterator depIterator = deps.iterator();<br/>
            while (depIterator.hasNext()) {<br/>
                MDependency dep = (MDependency) depIterator.next();<br/>
                if ((dep instanceof MAbstraction)<br/>
                        &amp;&amp; dep.getStereotype() != null<br/>
                        &amp;&amp; dep.getStereotype().getName() != null<br/>
                        &amp;&amp; dep.getStereotype().getName().equals("realize")) {<br/>
                    MInterface i =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MInterface) dep.getSuppliers().toArray()[0];<br/>
                    result.add(i);<br/>
                }<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the suppliers of a dependency.<br/>
     *<br/>
     * @param handle is the dependency<br/>
     * @return a collection of the suppliers<br/>
     */<br/>
    public static Collection getSuppliers(Object handle) {<br/>
        if (handle instanceof MDependency) {<br/>
            return ((MDependency) handle).getSuppliers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the action belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the action<br/>
     */<br/>
    public static Object getAction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the activator belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the activator<br/>
     */<br/>
    public static Object getActivator(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getActivator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the actual arguments for a given action.<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the actual arguments<br/>
     */<br/>
    public static Collection getActualArguments(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getActualArguments();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns an addition for a given inlcude.<br/>
     * There is a bug in NSUML which gets the addition and base<br/>
     * relationships back to front for include relationships. Solve<br/>
     * reversing their accessors in the code<br/>
     *<br/>
     * @param handle is the include<br/>
     * @return the addition<br/>
     */<br/>
    public static Object getAddition(Object handle) {<br/>
        if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getBase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the AggregationKind of a given AssociationEnd<br/>
     * @param handle the AssociationEnd<br/>
     * @return the AggregationKind<br/>
     */<br/>
    public static Object getAggregation(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAggregation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all associated classes for some given classifier.<br/>
     * Returns an empty collection if the given argument handle is not<br/>
     * a classifier.  The given parameter is included in the returned<br/>
     * collection if it has a self-referencing association.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getAssociatedClasses(Object handle) {<br/>
        Collection col = new ArrayList();<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) handle;<br/>
            Collection ends = classifier.getAssociationEnds();<br/>
            Iterator it = ends.iterator();<br/>
            Set associations = new HashSet();<br/>
            while (it.hasNext()) {<br/>
                MAssociationEnd ae = (MAssociationEnd) it.next();<br/>
                associations.add(ae.getAssociation());<br/>
            }<br/>
            Collection otherEnds = new ArrayList();<br/>
            it = associations.iterator();<br/>
            while (it.hasNext()) {<br/>
                otherEnds.addAll(((MAssociation) it.next()).getConnections());<br/>
            }<br/>
            otherEnds.removeAll(ends);<br/>
            it = otherEnds.iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getType());<br/>
            }<br/>
            return col;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Common getters<br/>
<br/>
    /**<br/>
     * The name of a model element or some diagram part.<br/>
     *<br/>
     * @param handle that points out the object.<br/>
     * @return the name<br/>
     */<br/>
    public static String getName(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getName();<br/>
        }<br/>
        if (handle instanceof Diagram) {<br/>
            return ((Diagram) handle).getName();<br/>
        }<br/>
        if (handle instanceof MOrderingKind) {<br/>
            return ((MOrderingKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MAggregationKind) {<br/>
            return ((MAggregationKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MVisibilityKind) {<br/>
            return ((MVisibilityKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MCallConcurrencyKind) {<br/>
            return ((MCallConcurrencyKind) handle).getName();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the owner of a feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @return classifier<br/>
     */<br/>
    public static Object getOwner(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getOwner();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tag of a tagged value.<br/>
     *<br/>
     * @param handle The tagged value belongs to this.<br/>
     * @return The found tag as a String.<br/>
     */<br/>
    public static String getTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tagged values iterator of a model element.<br/>
     *<br/>
     * @param handle The tagged values belong to this.<br/>
     * @return The tagged values iterator<br/>
     */<br/>
    public static Iterator getTaggedValues(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTaggedValues().iterator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the TaggedValues of a ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the Collection of TaggedValues<br/>
     */<br/>
    public static Collection getTaggedValuesCollection(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTaggedValues();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The found tag, null if not found<br/>
     */<br/>
    public static Object getTaggedValue(Object handle, String name) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = ((MModelElement) handle);<br/>
            Iterator i = me.getTaggedValues().iterator();<br/>
            while (i.hasNext()) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if (tv.getTag().equals(name)) {<br/>
                    return tv;<br/>
                }<br/>
            }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return the value of a tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element that the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The value of the found tag. "" if not found.<br/>
     */<br/>
    public static String getTaggedValueValue(Object handle, String name) {<br/>
        Object taggedValue = getTaggedValue(handle, name);<br/>
        if (taggedValue == null) {<br/>
            return "";<br/>
        }<br/>
        return getValueOfTag(taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the key (tag) of some tagged value.<br/>
     * <br/>
     * TODO: This does exactly the same as getTag(Object). Remove one of them.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */<br/>
    public static String getTagOfTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Value of some UML Object<br/>
     * @param handle Object<br/>
     * @return Object the exact type depends on the handle type<br/>
     * (String, Expression, Instance, TaggedValue...)<br/>
     */<br/>
    public static Object getValue(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MArgument) {<br/>
            return ((MArgument) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MExtension) {<br/>
            return ((MExtension) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MAggregationKind) {<br/>
            return new Integer(((MAggregationKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MOrderingKind) {<br/>
            return new Integer(((MOrderingKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MOperationDirectionKind) {<br/>
            return new Integer(((MOperationDirectionKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MVisibilityKind) {<br/>
            return new Integer(((MVisibilityKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MScopeKind) {<br/>
            return new Integer(((MScopeKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MMessageDirectionKind) {<br/>
            return new Integer(((MMessageDirectionKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MChangeableKind) {<br/>
            return new Integer(((MChangeableKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MPseudostateKind) {<br/>
            return new Integer(((MPseudostateKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MCallConcurrencyKind) {<br/>
            return new Integer(((MCallConcurrencyKind) handle).getValue());<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the value of some tagged value.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */<br/>
    public static String getValueOfTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the UUID of this element<br/>
     *<br/>
     * @param base base element (MBase type)<br/>
     * @return UUID<br/>
     */<br/>
    public static String getUUID(Object base) {<br/>
        if (isABase(base)) {<br/>
            return ((MBase) base).getUUID();<br/>
        }<br/>
        if (base instanceof CommentEdge) {<br/>
            return (String) ((CommentEdge) base).getUUID();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(base);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    /**<br/>
     *  Return the visibility of this element<br/>
     *  @param handle an nsuml model element<br/>
     *  @return visibility<br/>
     */<br/>
    public static Object getVisibility(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getVisibility();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Other querying methods<br/>
<br/>
    /**<br/>
     * Returns a named object in the given object by calling it's lookup method.<br/>
     *<br/>
     * @param handle the object that we search through<br/>
     * @param name of the model element<br/>
     * @return found object, null otherwise<br/>
     */<br/>
    public static Object lookupIn(Object handle, String name) {<br/>
        if (handle instanceof MModel)<br/>
            return ((MModel) handle).lookup(name);<br/>
        if (handle instanceof MNamespace)<br/>
            return ((MNamespace) handle).lookup(name);<br/>
        if (handle instanceof MClassifier)<br/>
            return ((MClassifier) handle).lookup(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Model modifying methods<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */<br/>
    public static void addFeature(Object handle, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) handle).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an instance to a classifier role.<br/>
     *<br/>
     * @param classifierRole is the classifier role<br/>
     * @param instance is the instance to add<br/>
     */<br/>
    public static void addInstance(Object classifierRole, Object instance) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if (classifierRole instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; instance instanceof MInstance) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifierRole clr = (MClassifierRole) classifierRole;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    clr.addInstance((MInstance) instance);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(classifierRole, instance);<br/>
    }<br/>
<br/>
    /**<br/>
     * @author mvw<br/>
     * @param classifierInState the classifierInState<br/>
     * @param state the state that will be linked<br/>
     */<br/>
    public static void addInState(Object classifierInState, Object state) {<br/>
        if (classifierInState instanceof MClassifierInState <br/>
                &amp;&amp; state instanceof MState) {<br/>
            ((MClassifierInState) classifierInState).addInState((MState) state);<br/>
        } else<br/>
            illegalArgument(classifierInState, state);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */<br/>
    public static void addFeature(Object handle, int index, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) handle).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, f);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add the given Link to the given Link or Association<br/>
     * @param handle the Link or Association <br/>
     * @param link Link<br/>
     */<br/>
    public static void addLink(Object handle, Object link) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAssociation) handle).addLink((MLink) link);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, link);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add Message to a predecessor Message<br/>
     * @param handle predecessor Message<br/>
     * @param mess Message to be added<br/>
     */<br/>
    public static void addMessage3(Object handle, Object mess) {<br/>
        if (handle instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) handle).addMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */<br/>
    public static void addMethod(Object handle, Object m) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) handle).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) handle).getOwnerScope());<br/>
            ((MOperation) handle).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, m);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a model element to some namespace.<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */<br/>
    public static void addOwnedElement(Object handle, Object me) {<br/>
        if (handle instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) handle).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, me);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MObjectFlowState, MEvent, MBehavioralFeature, MClassifier<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public static void addParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).addParameter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object at given location<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MEvent, MBehavioralFeature<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public static void addParameter(<br/>
        Object handle,<br/>
        int index,<br/>
        Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a predecessor to a message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param predecessor is the predecessor<br/>
     */<br/>
    public static void addPredecessor(Object handle, Object predecessor) {<br/>
        if (handle != null<br/>
            &amp;&amp; handle instanceof MMessage<br/>
            &amp;&amp; predecessor != null<br/>
            &amp;&amp; predecessor instanceof MMessage) {<br/>
            ((MMessage) handle).addPredecessor((MMessage) predecessor);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, predecessor);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a raised Signal to a Message or Operation<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */<br/>
    public static void addRaisedSignal(Object handle, Object sig) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (handle instanceof MMessage) {<br/>
                ((MBehavioralFeature) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MOperation) {<br/>
                ((MOperation) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, sig);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a stimulus to a action or link<br/>
     *<br/>
     * @param handle the action or link<br/>
     * @param stimulus is the stimulus<br/>
     */<br/>
    public static void addStimulus(Object handle, Object stimulus) {<br/>
        if (handle != null<br/>
            &amp;&amp; stimulus != null<br/>
            &amp;&amp; stimulus instanceof MStimulus) {<br/>
            if (handle instanceof MAction) {<br/>
                ((MAction) handle).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stimulus);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a subvertex to a composite state<br/>
     * @param handle the CompositeState<br/>
     * @param subvertex the StateVertex<br/>
     */<br/>
    public static void addSubvertex(Object handle, Object subvertex) {<br/>
        if (handle instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) handle).addSubvertex((MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertex);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */<br/>
    public static void addSupplier(Object handle, Object element) {<br/>
        if (isADependency(handle) &amp;&amp; isAModelElement(element)) {<br/>
            ((MDependency) handle).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public static void addSupplierDependency(<br/>
            Object supplier, <br/>
            Object dependency) {<br/>
        if (isAModelElement(supplier) &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        illegalArgument(supplier, dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an actual argument to an action<br/>
     * @param handle the action<br/>
     * @param argument the argument<br/>
     */<br/>
    public static void addActualArgument(Object handle, Object argument) {<br/>
        if (handle instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) handle).addActualArgument((MArgument) argument);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, argument);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Adds an annotated element to a comment.<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */<br/>
    public static void addAnnotatedElement(Object comment, <br/>
            Object annotatedElement) {<br/>
        if (comment instanceof MComment <br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        illegalArgument(comment, annotatedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method adds a classifier to a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */<br/>
    public static void addBase(Object handle, Object c) {<br/>
        if (handle instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) handle).addBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Classifier to an Instance<br/>
     * @param handle Instance<br/>
     * @param classifier Classifier<br/>
     */<br/>
    public static void addClassifier(Object handle, Object classifier) {<br/>
        if (handle instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) handle).addClassifier((MClassifier) classifier);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */<br/>
    public static void addClient(Object handle, Object element) {<br/>
        if (handle instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client dependency to some modelelement<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public static void addClientDependency(Object handle, Object dependency) {<br/>
        if (isAModelElement(handle)<br/>
                &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a TaggedValue to a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */<br/>
    public static void addTaggedValue(Object handle, Object taggedValue) {<br/>
        if (isAModelElement(handle) &amp;&amp; isATaggedValue(taggedValue)) {<br/>
            ((MModelElement) handle).addTaggedValue((MTaggedValue) taggedValue);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the actual Argument from an Action<br/>
     * @param handle Action<br/>
     * @param argument Argument<br/>
     */<br/>
    public static void removeActualArgument(Object handle, Object argument) {<br/>
        if (handle instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) handle).removeActualArgument((MArgument) argument);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, argument);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a classifier from a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */<br/>
    public static void removeBase(Object handle, Object c) {<br/>
        if (handle instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) handle).removeBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */<br/>
    public static void removeClientDependency(Object handle, Object dep) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) handle).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, dep);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given constraint from a given ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */<br/>
    public static void removeConstraint(Object handle, Object cons) {<br/>
        if (handle instanceof MModelElement &amp;&amp; cons instanceof MConstraint) {<br/>
            ((MModelElement) handle).removeConstraint((MConstraint) cons);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, cons);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given context (BehavioralFeature) from a Signal<br/>
     * @param handle Signal<br/>
     * @param context BehavioralFeature<br/>
     */<br/>
    public static void removeContext(Object handle, Object context) {<br/>
        if (handle instanceof MSignal<br/>
            &amp;&amp; context instanceof MBehavioralFeature) {<br/>
            ((MSignal) handle).removeContext((MBehavioralFeature) context);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, context);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method classifier from an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param classifier is the classifier<br/>
     */<br/>
    public static void removeClassifier(Object handle, Object classifier) {<br/>
        if (handle instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) handle).removeClassifier((MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param feature to remove<br/>
     */<br/>
    public static void removeFeature(Object handle, Object feature) {<br/>
        if (handle instanceof MClassifier<br/>
                &amp;&amp; feature instanceof MFeature) {<br/>
            ((MClassifier) handle).removeFeature((MFeature) feature);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, feature);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes an extension point from a use case.<br/>
     *<br/>
     * @param uc is the use case<br/>
     * @param ep is the extension point<br/>
     */<br/>
    public static void removeExtensionPoint(Object uc, Object ep) {<br/>
        if (uc instanceof MUseCase<br/>
                &amp;&amp; ep instanceof MExtensionPoint) {<br/>
            ((MUseCase) uc).removeExtensionPoint((MExtensionPoint) ep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(uc, ep);<br/>
    }<br/>
<br/>
    /**Removes a successor message<br/>
     * @param handle the Message that needs to loose a successor<br/>
     * @param mess the Message that is removed<br/>
     */<br/>
    public static void removeMessage3(Object handle, Object mess) {<br/>
        if (handle instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) handle).removeMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */<br/>
    public static void removeOwnedElement(Object handle, Object value) {<br/>
        if (handle instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) handle).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param p is the parameter<br/>
     */<br/>
    public static void removeParameter(Object handle, Object p) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; p instanceof MParameter) {<br/>
            ((MOperation) handle).removeParameter((MParameter) p);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, p);<br/>
    }<br/>
<br/>
    /** <br/>
     * Removes a predecessor message<br/>
     * @param handle the Message that needs to loose a predecessor<br/>
     * @param message the Message that is removed<br/>
     */<br/>
    public static void removePredecessor(Object handle, Object message) {<br/>
        if (handle instanceof MMessage &amp;&amp; message instanceof MMessage) {<br/>
            ((MMessage) handle).removePredecessor((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, message);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a given Reception from a given Signal<br/>
     * @param handle the Signal<br/>
     * @param reception the Reception<br/>
     */<br/>
    public static void removeReception(Object handle, Object reception) {<br/>
        if (handle instanceof MSignal &amp;&amp; reception instanceof MReception) {<br/>
            ((MSignal) handle).removeReception((MReception) reception);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, reception);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a given subvertex from a given composite state<br/>
     * @param handle the composite state<br/>
     * @param subvertex the StateVertex<br/>
     */<br/>
    public static void removeSubvertex(Object handle, Object subvertex) {<br/>
        if (handle instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) handle).removeSubvertex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertex);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */<br/>
    public static void removeTaggedValue(Object handle, String name) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    me.removeTaggedValue(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the base of some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param base is the base<br/>
     */<br/>
    public static void setBase(Object handle, Object base) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(base);<br/>
<br/>
        if (handle instanceof MAssociationRole<br/>
            &amp;&amp; base instanceof MAssociation) {<br/>
            ((MAssociationRole) handle).setBase((MAssociation) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MAssociationEndRole<br/>
            &amp;&amp; base instanceof MAssociationEnd) {<br/>
            ((MAssociationEndRole) handle).setBase((MAssociationEnd) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MExtend &amp;&amp; base instanceof MUseCase) {<br/>
            ((MExtend) handle).setBase((MUseCase) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MInclude &amp;&amp; base instanceof MUseCase) {<br/>
            ((MInclude) handle).setAddition((MUseCase) base);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, base);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the baseclass of some stereotype.<br/>
     *<br/>
     * @param handle the stereotype<br/>
     * @param baseClass the baseclass<br/>
     */<br/>
    public static void setBaseClass(Object handle, Object baseClass) {<br/>
        if (isAStereotype(handle) &amp;&amp; baseClass instanceof String) {<br/>
            ((MStereotype) handle).setBaseClass((String) baseClass);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, baseClass);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a body of a given Method, Constraint or Expression.<br/>
     *<br/>
     * @param handle is the method, expression<br/>
     * @param expr is the body string for the expression<br/>
     */<br/>
    public static void setBody(Object handle, Object expr) {<br/>
        if (handle instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) handle).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        if (handle instanceof MConstraint<br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)) {<br/>
            ((MConstraint) handle).setBody((MBooleanExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        /* TODO: MVW: The next part is fooling the user of setBody()<br/>
         * in thinking that the body of the object is changed.<br/>
         * Instead, a new object is created and as a side-effect <br/>
         * the language is lost.<br/>
         * Maybe we should just copy the language?<br/>
         */<br/>
        if (handle instanceof MExpression) {<br/>
            MExpressionEditor expressionEditor =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MExpressionEditor) UmlFactory.getFactory().getDataTypes()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .createExpressionEditor(handle);<br/>
            expressionEditor.setBody((String) expr);<br/>
            handle = (Object) expressionEditor.toExpression();<br/>
            // this last step creates a new MExpression<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the language of an expression.<br/>
     *<br/>
     * TODO: This operation is fooling the user<br/>
     * in thinking that the body of the object is changed.<br/>
     * Instead, a new object is created and as a side-effect the body is lost.<br/>
     * There is no other way: a MExpression can not be altered,<br/>
     * once created!<br/>
     * So, this operation should return the created object instead! <br/>
     * Or should it simply copy the body?<br/>
     *<br/>
     * @param handle is the expression<br/>
     * @param language is the lang<br/>
     */<br/>
    public static void setLanguage(Object handle, String language) {<br/>
        if (handle instanceof MExpression) {<br/>
            MExpression expression = (MExpression) handle;<br/>
            MExpressionEditor expressionEditor = (MExpressionEditor)<br/>
                UmlFactory.getFactory().getDataTypes().<br/>
                    createExpressionEditor(handle);<br/>
            expressionEditor.setLanguage(language);<br/>
            handle = expressionEditor.toExpression();<br/>
<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, language);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the language attribute of an Expression.<br/>
     *<br/>
     * @param handle is the Expression of which the language is retrieved<br/>
     * @return String the language<br/>
     */<br/>
    public static String getLanguage(Object handle) {<br/>
        if (handle instanceof MExpression) {<br/>
            return ((MExpression) handle).getLanguage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */<br/>
    public static void setDefaultValue(Object handle, Object expr) {<br/>
        if (handle instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) handle).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the guard of a transition.<br/>
     *<br/>
     * @param handle to the transition<br/>
     * @param guard to be set. Can be null.<br/>
     */<br/>
    public static void setGuard(Object handle, Object guard) {<br/>
        if (handle instanceof MTransition<br/>
                &amp;&amp; (guard == null || guard instanceof MGuard)) {<br/>
            ((MTransition) handle).setGuard((MGuard) guard);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, guard);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Transition of a guard or effect (Action).<br/>
     * @param handle the Guard or Action<br/>
     * @param trans the Transition<br/>
     */<br/>
    public static void setTransition(Object handle, Object trans) {<br/>
        if (trans instanceof MTransition) {<br/>
            if (handle instanceof MGuard) {<br/>
                ((MGuard) handle).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAction) {<br/>
                ((MAction) handle).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, trans);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the trigger event of a transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param event is the trigger event<br/>
     */<br/>
    public static void setTrigger(Object handle, Object event) {<br/>
        if (handle instanceof MTransition<br/>
                &amp;&amp; (event == null || event instanceof MEvent)) {<br/>
            ((MTransition) handle).setTrigger((MEvent) event);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, event);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the icon for a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param icon String<br/>
     */<br/>
    public static void setIcon(Object handle, Object icon) {<br/>
        if (handle instanceof MStereotype<br/>
                &amp;&amp; (icon == null || icon instanceof String)) {<br/>
            ((MStereotype) handle).setIcon((String) icon);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, icon);<br/>
    }<br/>
<br/>
    /** Set the ImplementationLocation of the given ElementResidence <br/>
     * to the given Component.<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     */<br/>
    public static void setImplementationLocation(<br/>
        Object handle,<br/>
        Object component) {<br/>
        if (handle instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) handle).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of Include relationships for a usecase<br/>
     * @param handle UseCase<br/>
     * @param includes the collection of Include relationships <br/>
     */<br/>
    public static void setIncludes(Object handle, Collection includes) {<br/>
        if (handle instanceof MUseCase) {<br/>
            ((MUseCase) handle).setIncludes(includes);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, includes);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setInitialValue(Object at, Object expr) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(at, expr);<br/>
    }<br/>
<br/>
    /** Sets the given Instance to the given LinkEnd or AttributeLink<br/>
     * @param handle LinkEnd or AttributeLink<br/>
     * @param inst null or Instance<br/>
     */<br/>
    public static void setInstance(Object handle, Object inst) {<br/>
        if (inst == null || inst instanceof MInstance) {<br/>
            if (handle instanceof MLinkEnd) {<br/>
                ((MLinkEnd) handle).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAttributeLink) {<br/>
                ((MAttributeLink) handle).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, inst);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle is the target.<br/>
     * @param intTrans is a collection of transitions.<br/>
     */<br/>
    public static void setInternalTransitions(<br/>
        Object handle,<br/>
        Collection intTrans) {<br/>
        if (handle instanceof MState) {<br/>
            ((MState) handle).setInternalTransitions(intTrans);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Message<br/>
     * @param messages Collection of predecessor messages<br/>
     */<br/>
    public static void setMessages3(Object handle, Collection messages) {<br/>
        if (handle instanceof MMessage) {<br/>
            ((MMessage) handle).setMessages3(messages);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a location of some extension point.<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @param loc is the location<br/>
     */<br/>
    public static void setLocation(Object handle, String loc) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            ((MExtensionPoint) handle).setLocation(loc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * &lt;p&gt;Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/b&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/b&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;/p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */<br/>
    public static void setModelElementContainer(<br/>
        Object handle,<br/>
        Object container) {<br/>
        if (handle instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) handle).setActivityGraph((MActivityGraph) container);<br/>
        } else if (handle instanceof MModelElement <br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) handle);<br/>
        } else if (<br/>
            handle instanceof MConstraint<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            MConstraint c = (MConstraint) handle;<br/>
            c.setConstrainedElement2((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) handle).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            handle instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) handle;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) handle).setInstance((MInstance) container);<br/>
        } else if (<br/>
            handle instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) handle).setInteraction((MInteraction) container);<br/>
        } else if (handle instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) handle).setLink((MLink) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) handle).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) handle).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) handle).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            handle instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) handle).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            handle instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) handle).setPackage((MPackage) container);<br/>
        } else if (<br/>
            handle instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) container);<br/>
        } else if (<br/>
            handle instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) container);<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    illegalArgument(handle, container);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */<br/>
    public static void setMultiplicity(Object handle, Object arg) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg instanceof MMultiplicity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MAssociationRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationRole) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MClassifierRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierRole) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, arg);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the classifiers of some instance.<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param v is the classifier vector<br/>
     */<br/>
    public static void setClassifiers(Object handle, Vector v) {<br/>
        if (handle instanceof MInstance) {<br/>
            ((MInstance) handle).setClassifiers(v);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */<br/>
    public static void setName(Object handle, String name) {<br/>
        if ((handle instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            ((MModelElement) handle).setName(name);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, name);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setNamespace(Object handle, Object ns) {<br/>
        if (handle instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ns);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */<br/>
    public static void setNavigable(Object handle, boolean flag) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /** Set the value of a given object<br/>
     * <br/>
     * @param handle the Object of which the value will be set<br/>
     * @param value Object <br/>
     */<br/>
    public static void setValue(Object handle, Object value) {<br/>
        if (handle instanceof MArgument) {<br/>
            ((MArgument) handle).setValue((MExpression) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MAttributeLink) {<br/>
            ((MAttributeLink) handle).setValue((MInstance) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MExtension) {<br/>
            ((MExtension) handle).setValue(value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTaggedValue) {<br/>
            ((MTaggedValue) handle).setValue((String) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */<br/>
    public static void setVisibility(Object handle, Object visibility) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (handle instanceof MModelElement) {<br/>
                ((MModelElement) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MElementResidence) {<br/>
                ((MElementResidence) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (handle instanceof MElementImport) {<br/>
                ((MElementImport) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, visibility);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param v is the visibility<br/>
     */<br/>
    public static void setVisibility(Object handle, short v) {<br/>
        if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) handle;<br/>
<br/>
            if (v == ACC_PRIVATE) {<br/>
                me.setVisibility(MVisibilityKind.PRIVATE);<br/>
            } else if (v == ACC_PROTECTED) {<br/>
                me.setVisibility(MVisibilityKind.PROTECTED);<br/>
            } else if (v == ACC_PUBLIC) {<br/>
                me.setVisibility(MVisibilityKind.PUBLIC);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the NodeInstance of a ComponentInstance<br/>
     * @param handle ComponentInstance<br/>
     * @param nodeInstance NodeInstance<br/>
     */<br/>
    public static void setNodeInstance(Object handle, Object nodeInstance) {<br/>
        if (handle instanceof MComponentInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; nodeInstance instanceof MNodeInstance) {<br/>
            ((MComponentInstance) handle).setNodeInstance(<br/>
                (MNodeInstance) nodeInstance);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, nodeInstance);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner of a Feature<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */<br/>
    public static void setOwner(Object handle, Object owner) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) handle).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, owner);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Operation of a CallAction or CallEvent<br/>
     * @param handle CallAction or CallEvent<br/>
     * @param operation Operation<br/>
     */<br/>
    public static void setOperation(Object handle, Object operation) {<br/>
        if (handle instanceof MCallAction) {<br/>
            ((MCallAction) handle).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MCallEvent) {<br/>
            ((MCallEvent) handle).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, operation);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the OrderingKind of a given AssociationEnd <br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */<br/>
    public static void setOrdering(Object handle, Object ok) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) handle).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ok);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner scope of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param os is the owner scope<br/>
     */<br/>
    public static void setOwnerScope(Object handle, short os) {<br/>
        if (handle instanceof MFeature) {<br/>
            if (os == CLASSIFIER_SCOPE) {<br/>
                ((MFeature) handle).setOwnerScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (os == INSTANCE_SCOPE) {<br/>
                ((MFeature) handle).setOwnerScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */<br/>
    public static void setOwnerScope(Object handle, Object os) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) handle).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, os);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param parameters is a Collection of extensionPoints<br/>
     */<br/>
    public static void setParameters(Object handle, Collection parameters) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            ((MClassifier) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameters);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the target of some action or transition.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param element the target of the model elemnet<br/>
     */<br/>
    public static void setTarget(Object handle, Object element) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; element instanceof MObjectSetExpression) {<br/>
            ((MAction) handle).setTarget((MObjectSetExpression) element);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; element instanceof MStateVertex) {<br/>
            ((MTransition) handle).setTarget((MStateVertex) element);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, element);<br/>
    }<br/>
    /**<br/>
     * Sets the state of an internal transition.<br/>
     *<br/>
     * @param handle the internal transition<br/>
     * @param element the state that contains this transition<br/>
     */<br/>
    public static void setState(Object handle, Object element) {<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; element instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */<br/>
    public static void setTargetScope(Object handle, Object scopeKind) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, scopeKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param ts is the target scope<br/>
     */<br/>
    public static void setTargetScope(Object handle, short ts) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd ae = (MAssociationEnd) handle;<br/>
<br/>
            if (ts == CLASSIFIER_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (ts == INSTANCE_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Instance<br/>
     * @param c ComponentInstance or null<br/>
     */<br/>
    public static void setComponentInstance(Object handle, Object c) {<br/>
        if (handle instanceof MInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; (c == null || c instanceof MComponentInstance)) {<br/>
            ((MInstance) handle).setComponentInstance((MComponentInstance) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the communicationLink between a link c and a stimulus handle.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param c the link<br/>
     */<br/>
    public static void setCommunicationLink(Object handle, Object c) {<br/>
        if (handle instanceof MStimulus &amp;&amp; c instanceof MLink) {<br/>
            ((MStimulus) handle).setCommunicationLink((MLink) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param c is the concurrency<br/>
     */<br/>
    public static void setConcurrency(Object handle, short c) {<br/>
        if (handle instanceof MOperation) {<br/>
            MOperation oper = (MOperation) handle;<br/>
<br/>
            if (c == GUARDED) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.GUARDED);<br/>
                return;<br/>
            } else if (c == SEQUENTIAL) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.SEQUENTIAL);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */<br/>
    public static void setConcurrency(<br/>
        Object handle,<br/>
        Object concurrencyKind) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) handle).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, concurrencyKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a Composite State concurrent<br/>
     * @param handle the CompositState<br/>
     * @param concurrent boolean<br/>
     */<br/>
    public static void setConcurent(Object handle, boolean concurrent) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            ((MCompositeState) handle).setConcurent(concurrent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the condition of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @param booleanExpression is the condition<br/>
     */<br/>
    public static void setCondition(Object handle, Object booleanExpression) {<br/>
        if (handle instanceof MExtend<br/>
            &amp;&amp; booleanExpression instanceof MBooleanExpression) {<br/>
            ((MExtend) handle).setCondition(<br/>
                (MBooleanExpression) booleanExpression);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, booleanExpression);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the container of a statevertex.<br/>
     *<br/>
     * @param handle is the stateVertex<br/>
     * @param compositeState is the container. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setContainer(Object handle, Object compositeState) {<br/>
        if (handle instanceof MStateVertex<br/>
            &amp;&amp; (compositeState == null<br/>
                || compositeState instanceof MCompositeState)) {<br/>
            ((MStateVertex) handle).setContainer(<br/>
                (MCompositeState) compositeState);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, compositeState);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the contexts for a Signal<br/>
     * @param handle the Signal<br/>
     * @param c the collection of contexts<br/>
     */<br/>
    public static void setContexts(Object handle, Collection c) {<br/>
        if (handle instanceof MSignal) {<br/>
            ((MSignal) handle).setContexts(c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the dispatch action for some stimulus.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param value the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setDispatchAction(Object handle, Object value) {<br/>
        if (handle instanceof MStimulus<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MStimulus) handle).setDispatchAction((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the do activity of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value the activity. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setDoActivity(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setDoActivity((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param value is the effect. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setEffect(Object handle, Object value) {<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MTransition) handle).setEffect((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the entry action of some state.<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setEntry(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setEntry((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the exit action of some state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setExit(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setExit((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**Set the Expression of a Guard or ChangeEvent<br/>
     * @param handle Guard or ChangeEvent<br/>
     * @param value BooleanExpression or null<br/>
     */<br/>
    public static void setExpression(Object handle, Object value) {<br/>
        if (handle instanceof MGuard<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
            ((MGuard) handle).setExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MChangeEvent<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeEvent ce = (MChangeEvent) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ce.setChangeExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the time-expression for a TimeEvent. <br/>
     * @param handle Object (MTimeEvent)<br/>
     * @param value Object (MTimeExpression)<br/>
     */<br/>
    public static void setWhen(Object handle, Object value) {<br/>
        if (handle instanceof MTimeEvent<br/>
            &amp;&amp; (value == null || value instanceof MTimeExpression)) {<br/>
            ((MTimeEvent) handle).setWhen((MTimeExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the extension of a usecase<br/>
     * @param handle Extend<br/>
     * @param ext UseCase or null<br/>
     */<br/>
    public static void setExtension(Object handle, Object ext) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(ext);<br/>
<br/>
        if (handle instanceof MExtend<br/>
            &amp;&amp; (ext == null || ext instanceof MUseCase)) {<br/>
            ((MExtend) handle).setExtension((MUseCase) ext);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ext);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param extensionPoints is the extension points<br/>
     */<br/>
    public static void setExtensionPoints(<br/>
        Object handle,<br/>
        Collection extensionPoints) {<br/>
        if (handle instanceof MUseCase &amp;&amp; extensionPoints instanceof List) {<br/>
            ((MUseCase) handle).setExtensionPoints(extensionPoints);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extensionPoints);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the list of features<br/>
     */<br/>
    public static void setFeatures(Object handle, Collection features) {<br/>
        if (handle instanceof MClassifier<br/>
            &amp;&amp; features instanceof List) {<br/>
            ((MClassifier) handle).setFeatures((List) features);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */<br/>
    public static void setAggregation(Object handle, Object aggregationKind) {<br/>
        if (handle instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) handle).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, aggregationKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */<br/>
    public static void setAssociation(Object handle, Object association) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, association);<br/>
    }<br/>
<br/>
    /**Set the Changeability of a StructuralFeature or AssociationEnd<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */<br/>
    public static void setChangeability(Object handle, Object ck) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ck);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */<br/>
    public static void setChangeable(Object handle, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            }<br/>
            else {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
            }<br/>
        } else if (handle instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) handle;<br/>
            if (flag)<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            else<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**Set the child for a generalization<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */<br/>
    public static void setChild(Object handle, Object child) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, child);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if of some model element is abstract.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */<br/>
    public static void setAbstract(Object handle, boolean flag) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MGeneralizableElement) handle).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MOperation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MOperation) handle).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MReception) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MReception) handle).setAbstarct(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the addition to an include.<br/>
     * There is a bug in NSUML that reverses additions and bases for includes.<br/>
     * @param handle Include <br/>
     * @param useCase UseCase<br/>
     */<br/>
    public static void setAddition(Object handle, Object useCase) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(useCase);<br/>
<br/>
        if (handle instanceof MInclude) {<br/>
            ((MInclude) handle).setBase((MUseCase) useCase);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the action to a message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @param action is the action<br/>
     */<br/>
    public static void setAction(Object handle, Object action) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; (action == null || action instanceof MAction)) {<br/>
            ((MMessage) handle).setAction((MAction) action);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, action);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Activator message of an message<br/>
     * @param handle Message<br/>
     * @param message Message<br/>
     */<br/>
    public static void setActivator(Object handle, Object message) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; (message == null || message instanceof MMessage)) {<br/>
            ((MMessage) handle).setActivator((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, message);<br/>
    }<br/>
<br/>
    /**Makes a Class active<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */<br/>
    public static void setActive(Object handle, boolean active) {<br/>
        if (handle instanceof MClass) {<br/>
            ((MClass) handle).setActive(active);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the asynchronous property of an action.<br/>
     *<br/>
     * @param handle the action<br/>
     * @param value the value to alter the asynchronous property to<br/>
     */<br/>
    public static void setAsynchronous(Object handle, boolean value) {<br/>
        if (handle instanceof MAction) {<br/>
            ((MAction) handle).setAsynchronous(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */<br/>
    public static void setLeaf(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */<br/>
    public static void setRaisedSignals(<br/>
        Object handle,<br/>
        Collection raisedSignals) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the receiver of some model element.<br/>
     * @param handle model element<br/>
     * @param receiver the receiver<br/>
     */<br/>
    public static void setReceiver(Object handle, Object receiver) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; receiver instanceof MClassifierRole) {<br/>
            ((MMessage) handle).setReceiver((MClassifierRole) receiver);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MStimulus &amp;&amp; receiver instanceof MInstance) {<br/>
            ((MStimulus) handle).setReceiver((MInstance) receiver);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, receiver);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the recurrence of an Action<br/>
     * @param handle Action<br/>
     * @param expr IterationExpression<br/>
     */<br/>
    public static void setRecurrence(Object handle, Object expr) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; expr instanceof MIterationExpression) {<br/>
            ((MAction) handle).setRecurrence((MIterationExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the represented classifier of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param classifier is the classifier<br/>
     */<br/>
    public static void setRepresentedClassifier(<br/>
        Object handle,<br/>
        Object classifier) {<br/>
        if (handle instanceof MCollaboration<br/>
            &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MCollaboration) handle).setRepresentedClassifier(<br/>
                (MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the represented operation of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param operation is the operation<br/>
     */<br/>
    public static void setRepresentedOperation(<br/>
        Object handle,<br/>
        Object operation) {<br/>
        if (handle instanceof MCollaboration<br/>
            &amp;&amp; operation instanceof MOperation) {<br/>
            ((MCollaboration) handle).setRepresentedOperation(<br/>
                (MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, operation);<br/>
    }<br/>
<br/>
    /**<br/>
     * <br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */<br/>
    public static void setResident(Object handle, Object resident) {<br/>
        if (handle instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) handle).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, resident);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */<br/>
    public static void setResidents(Object handle, Collection residents) {<br/>
        if (handle instanceof MNodeInstance) {<br/>
            ((MNodeInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MComponentInstance) {<br/>
            ((MComponentInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MNode) {<br/>
            ((MNode) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */<br/>
    public static void setRoot(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Expression (script) for an Action<br/>
     * @param handle Action<br/>
     * @param expr the script (ActionExpression)<br/>
     */<br/>
    public static void setScript(Object handle, Object expr) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; (expr == null || expr instanceof MActionExpression)) {<br/>
            ((MAction) handle).setScript((MActionExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the sender of some model element.&lt;p&gt;<br/>
     *<br/>
     * @param handle model element<br/>
     * @param sender the sender<br/>
     */<br/>
    public static void setSender(Object handle, Object sender) {<br/>
        if (handle instanceof MMessage &amp;&amp; sender instanceof MClassifierRole) {<br/>
            ((MMessage) handle).setSender((MClassifierRole) sender);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MStimulus &amp;&amp; sender instanceof MInstance) {<br/>
            ((MStimulus) handle).setSender((MInstance) sender);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, sender);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Signal<br/>
     * @param handle SendAction or Reception or SignalEvent<br/>
     * @param signal Signal or null<br/>
     */<br/>
    public static void setSignal(Object handle, Object signal) {<br/>
        if (signal == null || signal instanceof MSignal) {<br/>
            if (handle instanceof MSendAction) {<br/>
                ((MSendAction) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MReception) {<br/>
                ((MReception) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MSignalEvent) {<br/>
                ((MSignalEvent) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, signal);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the source state of some message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param state the source state<br/>
     */<br/>
    public static void setSource(Object handle, Object state) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MTransition &amp;&amp; state instanceof MStateVertex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MTransition) handle).setSource((MStateVertex) state);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, state);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */<br/>
    public static void setSources(Object handle, Collection specifications) {<br/>
        if (handle instanceof MFlow) {<br/>
            ((MFlow) handle).setSources(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * <br/>
     * @param handle a reception<br/>
     * @param specification the specification<br/>
     */<br/>
    public static void setSpecification(Object handle, String specification) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Specification flag for a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */<br/>
    public static void setSpecification(Object handle, boolean specification) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */<br/>
    public static void setSpecifications(<br/>
        Object handle,<br/>
        Collection specifications) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */<br/>
    public static void setKind(Object handle, Object kind) {<br/>
        if (handle instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) handle).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) handle).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, kind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToIn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.IN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToInOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.INOUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.OUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.RETURN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */<br/>
    public static void setParent(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) handle).setParent(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Generalization <br/>
     * @param pt Classifier<br/>
     */<br/>
    public static void setPowertype(Object handle, Object pt) {<br/>
        if (handle instanceof MGeneralization &amp;&amp; pt instanceof MClassifier) {<br/>
            ((MGeneralization) handle).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, pt);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of predecessing messages<br/>
     * @param handle Message<br/>
     * @param predecessors Collection of Messages<br/>
     */<br/>
    public static void setPredecessors(<br/>
        Object handle,<br/>
        Collection predecessors) {<br/>
        if (handle instanceof MMessage) {<br/>
            ((MMessage) handle).setPredecessors(predecessors);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, predecessors);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */<br/>
    public static void setQuery(Object handle, boolean flag) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setQuery(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */<br/>
    public static void setType(Object handle, Object type) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MObjectFlowState) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MClassifierInState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierInState) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MParameter) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, type);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the UUID of this element<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */<br/>
    public static void setUUID(Object handle, String uuid) {<br/>
        if (isABase(handle)) {<br/>
            ((MBase) handle).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Tag of a TaggedValue <br/>
     * @param handle TaggedValue<br/>
     * @param tag String<br/>
     */<br/>
    public static void setTag(Object handle, Object tag) {<br/>
        if (handle instanceof MTaggedValue &amp;&amp; tag instanceof String) {<br/>
            ((MTaggedValue) handle).setTag((String) tag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, tag);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */<br/>
    public static void setTaggedValue(<br/>
        Object handle,<br/>
        String tag,<br/>
        String value) {<br/>
        if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MModelElement) handle).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the TaggedValues of a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */<br/>
    public static void setTaggedValues(<br/>
        Object handle,<br/>
        Collection taggedValues) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a value of some taggedValue.<br/>
     *<br/>
     * @param handle is the tagged value<br/>
     * @param value is the value<br/>
     */<br/>
    public static void setValueOfTag(Object handle, String value) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            ((MTaggedValue) handle).setValue(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a state machine of some state or transition.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @param stm is the state machine<br/>
     */<br/>
    public static void setStateMachine(Object handle, Object stm) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stm);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * &lt;p&gt;TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */<br/>
    public static void setStereotype(Object handle, Object stereo) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            if (stereo instanceof MStereotype<br/>
                &amp;&amp; me.getModel() != ((MStereotype) stereo).getModel()) {<br/>
                ((MStereotype) stereo).setNamespace(me.getModel());<br/>
            }<br/>
            if (stereo == null || stereo instanceof MStereotype) {<br/>
                me.setStereotype((MStereotype) stereo);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stereo);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of substates for a CompositeState<br/>
     * @param handle CompositeState<br/>
     * @param subvertices collection of sub-StateVertexes<br/>
     */<br/>
    public static void setSubvertices(Object handle, Collection subvertices) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            ((MCompositeState) handle).setSubvertices(subvertices);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertices);<br/>
    }<br/>
<br/>
    /** Add an End to a connection<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */<br/>
    public static void addConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) handle).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) handle).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, connection);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */<br/>
    public static void addConstraint(Object handle, Object mc) {<br/>
        if (handle instanceof MModelElement &amp;&amp; mc instanceof MConstraint) {<br/>
            ((MModelElement) handle).addConstraint((MConstraint) mc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mc);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public static void addDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, node);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add an extended element to a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param extendedElement ExtensionPoint<br/>
     */<br/>
    public static void addExtendedElement(<br/>
        Object handle,<br/>
        Object extendedElement) {<br/>
        if (handle instanceof MStereotype<br/>
            &amp;&amp; extendedElement instanceof MExtensionPoint) {<br/>
            ((MStereotype) handle).addExtendedElement(<br/>
                (MModelElement) extendedElement);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extendedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an extension point to some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param extensionPoint is the extension point<br/>
     */<br/>
    public static void addExtensionPoint(<br/>
        Object handle,<br/>
        Object extensionPoint) {<br/>
        if (extensionPoint instanceof MExtensionPoint) {<br/>
            if (handle instanceof MUseCase) {<br/>
                ((MUseCase) handle).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MExtend) {<br/>
                ((MExtend) handle).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extensionPoint);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the name of the UML Model class, e.g. it it will return<br/>
     * Class for an object of type MClass.<br/>
     *<br/>
     * @param handle MBase<br/>
     * @return classname of modelelement<br/>
     */<br/>
    public static String getUMLClassName(Object handle) {<br/>
        if (handle instanceof MBase) {<br/>
            return ((MBase) handle).getUMLClassName();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Convenience methods<br/>
<br/>
    /**<br/>
     * Tests if an element is marked removed.<br/>
     *<br/>
     * &lt;p&gt;Model specific: NSUML is littered with calls to a function also<br/>
     * named checkExists. That function is however a NOP (it is empty in<br/>
     * MBaseImpl, and it is final so it cannot be overridden anywhere).<br/>
     *<br/>
     * @param obj the element to test.<br/>
     * @throws IllegalStateException iff obj is marked removed.<br/>
     */<br/>
    private static void checkExists(Object obj) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((obj instanceof MBase) &amp;&amp; ((MBase) obj).isRemoved()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalStateException("Operation on a removed object ["<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    + obj + "]");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * The empty set.<br/>
     *<br/>
     * @return an empty collection.<br/>
     */<br/>
    private static Collection emptyCollection() {<br/>
        return Collections.EMPTY_LIST;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get a string representation of the class type. <br/>
     * Purpose: documenting an exception<br/>
     * @param handle the Class or null<br/>
     * @return String <br/>
     */<br/>
    protected static String getClassNull(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[null]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[" + handle + "/" + handle.getClass() + "]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     */<br/>
    private static void illegalArgument(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg));<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return a boolean for use in the return statement.<br/>
     */<br/>
    private static boolean illegalArgumentBoolean(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Object for use in the return statement.<br/>
     */<br/>
    private static Object illegalArgumentObject(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Collection for use in the return statement.<br/>
     */<br/>
    private static Collection illegalArgumentCollection(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return String for use in the return statement.<br/>
     */<br/>
    private static String illegalArgumentString(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     */<br/>
    private static Object illegalArgument(Object arg1, Object arg2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg1) + " or "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg2));<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     * @return Object for use in the return statement.<br/>
     */<br/>
    private static Object illegalArgumentObject(Object arg1, Object arg2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg1, arg2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_ModelFacade_1.210.java</h1>
<div class="code">
<div class="id">
// $Id: ModelFacade.java,v 1.210 2004-08-27 09:48:12 bobtarling Exp $<br/>
// Copyright (c) 2003-2004 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.Collections;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.argouml.model.uml.UmlFactory;<br/>
import org.argouml.model.uml.foundation.core.CoreHelper;<br/>
import org.argouml.model.uml.foundation.extensionmechanisms.ExtensionMechanismsHelper;<br/>
import org.argouml.uml.diagram.static_structure.ui.CommentEdge;<br/>
import org.tigris.gef.base.Diagram;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.MElementListener;<br/>
import ru.novosoft.uml.MExtension;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActionState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MCallState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MSubactivityState;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MActionSequence;<br/>
import ru.novosoft.uml.behavior.common_behavior.MArgument;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCallAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCreateAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDataValue;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDestroyAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MException;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MObject;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReturnAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSendAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.common_behavior.MStimulus;<br/>
import ru.novosoft.uml.behavior.common_behavior.MTerminateAction;<br/>
import ru.novosoft.uml.behavior.state_machines.MCallEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MChangeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MFinalState;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MSignalEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateImpl;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MSubmachineState;<br/>
import ru.novosoft.uml.behavior.state_machines.MTimeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtensionPoint;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationClass;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElement;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MPermission;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.core.MUsage;<br/>
import ru.novosoft.uml.foundation.data_types.MActionExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MExpressionEditor;<br/>
import ru.novosoft.uml.foundation.data_types.MIterationExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMessageDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicityRange;<br/>
import ru.novosoft.uml.foundation.data_types.MObjectSetExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MOperationDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MTimeExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MModel;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
import ru.novosoft.uml.model_management.MSubsystem;<br/>
<br/>
/**<br/>
 * Facade object for the Model component in ArgoUML.&lt;p&gt;<br/>
 *<br/>
 * The purpose of this Facade object is to allow for decoupling other modules<br/>
 * from the insides of the model. For this purpose all of the methods in this<br/>
 * class give away and accept handles (of type java.lang.Object) to the<br/>
 * objects within the model.&lt;p&gt;<br/>
 *<br/>
 * This is just getters and recognizers. This is because the Model<br/>
 * component has an extremely complicated internal data structure<br/>
 * with lots of internal dependencies. To manipulate these there is<br/>
 * a whole set of factories and helpers within the Model that is to<br/>
 * be used but to use them you need knowledge of the internals of<br/>
 * the Model, specifically the NS-UML objects.&lt;p&gt;<br/>
 *<br/>
 * All methods in this facade are static.&lt;p&gt;<br/>
 *<br/>
 * Signature for all recognizers in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static boolean isA&lt;TYPE&gt;(Object handle)<br/>
 * &lt;li&gt;public static boolean is&lt;PROPERTY&gt;(Object handle)<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * Signature for all getters in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static Object get&lt;TYPE&gt;(Object handle) - 1..1<br/>
 * &lt;li&gt;public static Iterator get&lt;TYPES&gt;(Object handle) - 0..*<br/>
 * &lt;li&gt;public static String getName(Object handle) - Name<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * @stereotype utility<br/>
 * @author Linus Tolke<br/>
 */<br/>
public class ModelFacade {<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // constants<br/>
<br/>
    // TODO: deprecate all of these constants in favor of a separate declaration<br/>
<br/>
    public static final short ACC_PUBLIC = 1;<br/>
    public static final short ACC_PRIVATE = 2;<br/>
    public static final short ACC_PROTECTED = 3;<br/>
<br/>
    public static final short CLASSIFIER_SCOPE = 1;<br/>
    public static final short INSTANCE_SCOPE = 2;<br/>
<br/>
    public static final short GUARDED = 1;<br/>
    public static final short SEQUENTIAL = 2;<br/>
<br/>
    // Types of line<br/>
    public static final Object ABSTRACTION = MAbstraction.class;<br/>
    public static final Object ASSOCIATION = MAssociation.class;<br/>
    public static final Object ASSOCIATION_CLASS = MAssociationClass.class;<br/>
    public static final Object ASSOCIATION_ROLE = MAssociationRole.class;<br/>
    public static final Object COLLABORATION = MCollaboration.class;<br/>
    public static final Object DEPENDENCY = MDependency.class;<br/>
    public static final Object EXTEND = MExtend.class;<br/>
    public static final Object GENERALIZATION = MGeneralization.class;<br/>
    public static final Object INCLUDE = MInclude.class;<br/>
    public static final Object LINK = MLink.class;<br/>
    public static final Object MESSAGE = MMessage.class;<br/>
    public static final Object PERMISSION = MPermission.class;<br/>
    public static final Object SIGNAL = MSignal.class;<br/>
    public static final Object USAGE = MUsage.class;<br/>
    public static final Object TRANSITION = MTransition.class;<br/>
<br/>
    // Types of node<br/>
    public static final Object ACTOR = MActor.class;<br/>
    public static final Object CLASS = MClass.class;<br/>
    public static final Object CLASSIFIER = MClassifier.class;<br/>
    public static final Object CLASSIFIER_ROLE = MClassifierRole.class;<br/>
    public static final Object COMMENT = MComment.class;<br/>
    public static final Object COMPONENT = MComponent.class;<br/>
    public static final Object COMPONENT_INSTANCE = MComponentInstance.class;<br/>
    public static final Object EXCEPTION = MException.class;<br/>
    public static final Object INSTANCE = MInstance.class;<br/>
    public static final Object INTERFACE = MInterface.class;<br/>
    public static final Object NODE = MNode.class;<br/>
    public static final Object NODE_INSTANCE = MNodeInstance.class;<br/>
    public static final Object OBJECT = MObject.class;<br/>
    public static final Object PACKAGE = MPackage.class;<br/>
    public static final Object MODEL = MModel.class;<br/>
    public static final Object SUBSYSTEM = MSubsystem.class;<br/>
    public static final Object STATE = MState.class;<br/>
    public static final Object STATEIMPL = MStateImpl.class;<br/>
    public static final Object COMPOSITESTATE = MCompositeState.class;<br/>
    public static final Object STATEVERTEX = MStateVertex.class;<br/>
    public static final Object PSEUDOSTATE = MPseudostate.class;<br/>
    public static final Object FINALSTATE = MFinalState.class;<br/>
    public static final Object USE_CASE = MUseCase.class;<br/>
    public static final Object CALLSTATE = MCallState.class;<br/>
    public static final Object OBJECTFLOWSTATE = MObjectFlowState.class;<br/>
    public static final Object SUBACTIVITYSTATE = MSubactivityState.class;<br/>
<br/>
    // Invisible model elements<br/>
    public static final Object ACTION = MAction.class;<br/>
    public static final Object ACTION_EXPRESSION = MActionExpression.class;<br/>
    public static final Object ACTION_STATE = MActionState.class;<br/>
    public static final Object ASSOCIATION_END = MAssociationEnd.class;<br/>
    public static final Object ASSOCIATION_END_ROLE = MAssociationEndRole.class;<br/>
    public static final Object CALL_ACTION = MCallAction.class;<br/>
    public static final Object CALLCONCURRENCYKIND = MCallConcurrencyKind.class;<br/>
    public static final Object CREATE_ACTION = MCreateAction.class;<br/>
    public static final Object DESTROY_ACTION = MDestroyAction.class;<br/>
    public static final Object TERMINATE_ACTION = MTerminateAction.class;<br/>
    public static final Object NAMESPACE = MNamespace.class;<br/>
    public static final Object RECEPTION = MReception.class;<br/>
    public static final Object RETURN_ACTION = MReturnAction.class;<br/>
    public static final Object SCOPEKIND = MScopeKind.class;<br/>
    public static final Object SEND_ACTION = MSendAction.class;<br/>
    public static final Object STEREOTYPE = MStereotype.class;<br/>
    public static final Object PARTITION = MPartition.class;<br/>
    public static final Object PARAMETER = MParameter.class;<br/>
    public static final Object PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.class;<br/>
    public static final Object GENERALAIZABLE_ELEMENT =<br/>
        MGeneralizableElement.class;<br/>
    public static final Object DATATYPE = MDataType.class;<br/>
    public static final Object STATEMACHINE = MStateMachine.class;<br/>
<br/>
    public static final Object ATTRIBUTE = MAttribute.class;<br/>
    public static final Object OPERATION = MOperation.class;<br/>
<br/>
    public static final Object MULTIPLICITY = MMultiplicity.class;<br/>
<br/>
    public static final Object VISIBILITYKIND = MVisibilityKind.class;<br/>
<br/>
    public static final Object MODELELEMENT = MModelElement.class;<br/>
    public static final Object STIMULUS = MStimulus.class;<br/>
<br/>
    public static final Object AGGREGATIONKIND = MAggregationKind.class;<br/>
    public static final Object BOOLEAN_EXPRESSION = MBooleanExpression.class;<br/>
    public static final Object GUARD = MGuard.class;<br/>
    public static final Object EVENT = MEvent.class;<br/>
<br/>
    public static final Object ADD_ONLY_CHANGEABLEKIND =<br/>
        MChangeableKind.ADD_ONLY;<br/>
    public static final Object CHANGEABLE_CHANGEABLEKIND =<br/>
        MChangeableKind.CHANGEABLE;<br/>
    public static final Object FROZEN_CHANGEABLEKIND = MChangeableKind.FROZEN;<br/>
<br/>
    public static final Object CONCURRENT_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.CONCURRENT;<br/>
<br/>
    public static final Object GUARDED_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.GUARDED;<br/>
<br/>
    public static final Object SEQUENTIAL_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.SEQUENTIAL;<br/>
<br/>
    public static final Object PSEUDOSTATEKIND = MPseudostateKind.class;<br/>
    public static final Object INITIAL_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.INITIAL;<br/>
    public static final Object DEEPHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.DEEP_HISTORY;<br/>
    public static final Object SHALLOWHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.SHALLOW_HISTORY;<br/>
    public static final Object FORK_PSEUDOSTATEKIND = MPseudostateKind.FORK;<br/>
    public static final Object JOIN_PSEUDOSTATEKIND = MPseudostateKind.JOIN;<br/>
    public static final Object JUNCTION_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.JUNCTION;<br/>
    public static final Object BRANCH_PSEUDOSTATEKIND = MPseudostateKind.BRANCH;<br/>
<br/>
    public static final Object PUBLIC_VISIBILITYKIND = MVisibilityKind.PUBLIC;<br/>
    public static final Object PRIVATE_VISIBILITYKIND = MVisibilityKind.PRIVATE;<br/>
    public static final Object PROTECTED_VISIBILITYKIND =<br/>
        MVisibilityKind.PROTECTED;<br/>
<br/>
    public static final Object AGGREGATE_AGGREGATIONKIND =<br/>
        MAggregationKind.AGGREGATE;<br/>
    public static final Object COMPOSITE_AGGREGATIONKIND =<br/>
        MAggregationKind.COMPOSITE;<br/>
    public static final Object NONE_AGGREGATIONKIND = MAggregationKind.NONE;<br/>
<br/>
    public static final Object ORDERED_ORDERINGKIND = MOrderingKind.ORDERED;<br/>
    public static final Object UNORDERED_ORDERINGKIND = MOrderingKind.UNORDERED;<br/>
    public static final Object SORTED_ORDERINGKIND = MOrderingKind.SORTED;<br/>
<br/>
    public static final Object M1_1_MULTIPLICITY = MMultiplicity.M1_1;<br/>
    public static final Object M0_1_MULTIPLICITY = MMultiplicity.M0_1;<br/>
    public static final Object M0_N_MULTIPLICITY = MMultiplicity.M0_N;<br/>
    public static final Object M1_N_MULTIPLICITY = MMultiplicity.M1_N;<br/>
<br/>
    public static final Object CLASSIFIER_SCOPEKIND = MScopeKind.CLASSIFIER;<br/>
    public static final Object INSTANCE_SCOPEKIND = MScopeKind.INSTANCE;<br/>
<br/>
    public static final Object INOUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.INOUT;<br/>
<br/>
    public static final Object IN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.IN;<br/>
<br/>
    public static final Object OUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.OUT;<br/>
<br/>
    public static final Object RETURN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.RETURN;<br/>
<br/>
<br/>
    /**<br/>
     * This tag is set on elements that are generated by reference when<br/>
     * importing.<br/>
     * If it is set, then the critics could ignore those objects if they want.<br/>
     */<br/>
    public static final String GENERATED_TAG = "GeneratedFromImport";<br/>
<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Object Creation methods<br/>
<br/>
    /**<br/>
     * Create a model object from the implementation.&lt;P&gt;<br/>
     *<br/>
     * This will allow abstraction of the create mechanism at a single point.<br/>
     *<br/>
     * TODO: Document the intention of this function.<br/>
     * It is not used anywhere in ArgoUML. <br/>
     * BTW: Does it work? I (MVW) once did a test, and it didn't.<br/>
     *<br/>
     * @param entity Class to create -<br/>
     * must implement {@link org.argouml.model.UmlModelEntity}<br/>
     * @return the created object or null if it cannot create the class.<br/>
     */<br/>
    public static Object create(ModelEntity entity) {<br/>
        if (entity instanceof UmlModelEntity) {<br/>
            return UmlFactory.getFactory().create((UmlModelEntity) entity);<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Abstraction.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Abstraction<br/>
     */<br/>
    public static boolean isAAbstraction(Object handle) {<br/>
        return handle instanceof MAbstraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action<br/>
     */<br/>
    public static boolean isAAction(Object handle) {<br/>
        return handle instanceof MAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionExpression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ActionExpression<br/>
     */<br/>
    public static boolean isAActionExpression(Object handle) {<br/>
        return handle instanceof MActionExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionSequence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an action sequence<br/>
     */<br/>
    public static boolean isAActionSequence(Object handle) {<br/>
        return handle instanceof MActionSequence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action state<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action state<br/>
     */<br/>
    public static boolean isAActionState(Object handle) {<br/>
        return handle instanceof MActionState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an call state<br/>
     */<br/>
    public static boolean isACallState(Object handle) {<br/>
        return handle instanceof MCallState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ObjectFlowState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an objectflow state<br/>
     */<br/>
    public static boolean isAObjectFlowState(Object handle) {<br/>
        return handle instanceof MObjectFlowState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SubactivityState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an subactivity state<br/>
     */<br/>
    public static boolean isASubactivityState(Object handle) {<br/>
        return handle instanceof MSubactivityState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Actor<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Actor<br/>
     */<br/>
    public static boolean isAActor(Object handle) {<br/>
        return handle instanceof MActor;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AggregationKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AggregationKind<br/>
     */<br/>
    public static boolean isAAggregationKind(Object handle) {<br/>
        return handle instanceof MAggregationKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Association.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Association<br/>
     */<br/>
    public static boolean isAAssociation(Object handle) {<br/>
        return handle instanceof MAssociation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEnd.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEnd<br/>
     */<br/>
    public static boolean isAAssociationEnd(Object handle) {<br/>
        return handle instanceof MAssociationEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationRole<br/>
     */<br/>
    public static boolean isAAssociationRole(Object handle) {<br/>
        return handle instanceof MAssociationRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEndRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEndRole<br/>
     */<br/>
    public static boolean isAAssociationEndRole(Object handle) {<br/>
        return handle instanceof MAssociationEndRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Attribute<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Attribute<br/>
     */<br/>
    public static boolean isAAttribute(Object handle) {<br/>
        return handle instanceof MAttribute;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for asynchronisity of an action<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the argument is asynchronous<br/>
     */<br/>
    public static boolean isAsynchronous(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).isAsynchronous();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for abstract classes and operations.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is abstract.<br/>
     */<br/>
    public static boolean isAbstract(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).isAbstract();<br/>
        if (handle instanceof MGeneralizableElement)<br/>
            return ((MGeneralizableElement) handle).isAbstract();<br/>
        if (handle instanceof MAssociation)<br/>
            return ((MAssociation) handle).isAbstract();<br/>
        // isAbstarct() is not a typo! mistake in nsuml!<br/>
        if (handle instanceof MReception)<br/>
            return ((MReception) handle).isAbstarct();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for ActivityGraph<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is ActivityGraph.<br/>
     */<br/>
    public static boolean isAActivityGraph(Object handle) {<br/>
        return handle instanceof MActivityGraph;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for bases. A base is an object that is some form of<br/>
     * an element in the model. MBase in Novosoft terms.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a base.<br/>
     */<br/>
    public static boolean isABase(Object handle) {<br/>
        return handle instanceof MBase;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for behavioral features.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a behavioral feature<br/>
     */<br/>
    public static boolean isABehavioralFeature(Object handle) {<br/>
        return handle instanceof MBehavioralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallAction<br/>
     */<br/>
    public static boolean isACallAction(Object handle) {<br/>
        return handle instanceof MCallAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallEvent<br/>
     */<br/>
    public static boolean isACallEvent(Object handle) {<br/>
        return handle instanceof MCallEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ChangeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ChangeEvent<br/>
     */<br/>
    public static boolean isAChangeEvent(Object handle) {<br/>
        return handle instanceof MChangeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Class<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Class<br/>
     */<br/>
    public static boolean isAClass(Object handle) {<br/>
        return handle instanceof MClass;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Classifier<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Classifier<br/>
     */<br/>
    public static boolean isAClassifier(Object handle) {<br/>
        return handle instanceof MClassifier;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierInState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierInState<br/>
     */<br/>
    public static boolean isAClassifierInState(Object handle) {<br/>
        return handle instanceof MClassifierInState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierRole<br/>
     */<br/>
    public static boolean isAClassifierRole(Object handle) {<br/>
        return handle instanceof MClassifierRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Comment<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Comment<br/>
     */<br/>
    public static boolean isAComment(Object handle) {<br/>
        return handle instanceof MComment;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Collaboration<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Collaboration<br/>
     */<br/>
    public static boolean isACollaboration(Object handle) {<br/>
        return handle instanceof MCollaboration;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Component<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Component<br/>
     */<br/>
    public static boolean isAComponent(Object handle) {<br/>
        return handle instanceof MComponent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ComponentInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ComponentInstance<br/>
     */<br/>
    public static boolean isAComponentInstance(Object handle) {<br/>
        return handle instanceof MComponentInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Constraint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Constraint<br/>
     */<br/>
    public static boolean isAConstraint(Object handle) {<br/>
        return handle instanceof MConstraint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CreateAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CreateAction<br/>
     */<br/>
    public static boolean isACreateAction(Object handle) {<br/>
        return handle instanceof MCreateAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataType<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataType<br/>
     */<br/>
    public static boolean isADataType(Object handle) {<br/>
        return handle instanceof MDataType;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataValue<br/>
     */<br/>
    public static boolean isADataValue(Object handle) {<br/>
        return handle instanceof MDataValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Dependency<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Dependency<br/>
     */<br/>
    public static boolean isADependency(Object handle) {<br/>
        return handle instanceof MDependency;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DestroyAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DestroyAction<br/>
     */<br/>
    public static boolean isADestroyAction(Object handle) {<br/>
        return handle instanceof MDestroyAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CompositeState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CompositeState<br/>
     */<br/>
    public static boolean isACompositeState(Object handle) {<br/>
        return handle instanceof MCompositeState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Element<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Element<br/>
     */<br/>
    public static boolean isAElement(Object handle) {<br/>
        return handle instanceof MElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementImport<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementImport<br/>
     */<br/>
    public static boolean isAElementImport(Object handle) {<br/>
        return handle instanceof MElementImport;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementListener<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementListener<br/>
     */<br/>
    public static boolean isAElementListener(Object handle) {<br/>
        return handle instanceof MElementListener;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementResidence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementResidence<br/>
     */<br/>
    public static boolean isAElementResidence(Object handle) {<br/>
        return handle instanceof MElementResidence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Event<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Event<br/>
     */<br/>
    public static boolean isAEvent(Object handle) {<br/>
        return handle instanceof MEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Exception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Exception<br/>
     */<br/>
    public static boolean isAException(Object handle) {<br/>
        return handle instanceof MException;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Expression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Expression<br/>
     */<br/>
    public static boolean isAExpression(Object handle) {<br/>
        return handle instanceof MExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Extend<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Extend<br/>
     */<br/>
    public static boolean isAExtend(Object handle) {<br/>
        return handle instanceof MExtend;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ExtensionPoint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ExtensionPoint<br/>
     */<br/>
    public static boolean isAExtensionPoint(Object handle) {<br/>
        return handle instanceof MExtensionPoint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Feature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Feature<br/>
     */<br/>
    public static boolean isAFeature(Object handle) {<br/>
        return handle instanceof MFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for FinalState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a FinalState<br/>
     */<br/>
    public static boolean isAFinalState(Object handle) {<br/>
        return handle instanceof MFinalState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Flow<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Flow<br/>
     */<br/>
    public static boolean isAFlow(Object handle) {<br/>
        return handle instanceof MFlow;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Guard<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Guard<br/>
     */<br/>
    public static boolean isAGuard(Object handle) {<br/>
        return handle instanceof MGuard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralizableElement(Object handle) {<br/>
        return handle instanceof MGeneralizableElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralization(Object handle) {<br/>
        return handle instanceof MGeneralization;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Include<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Include<br/>
     */<br/>
    public static boolean isAInclude(Object handle) {<br/>
        return handle instanceof MInclude;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Instance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Instance<br/>
     */<br/>
    public static boolean isAInstance(Object handle) {<br/>
        return handle instanceof MInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interaction<br/>
     */<br/>
    public static boolean isAInteraction(Object handle) {<br/>
        return handle instanceof MInteraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interface<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interface<br/>
     */<br/>
    public static boolean isAInterface(Object handle) {<br/>
        return handle instanceof MInterface;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Link<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Link<br/>
     */<br/>
    public static boolean isALink(Object handle) {<br/>
        return handle instanceof MLink;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for LinkEnd<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a LinkEnd<br/>
     */<br/>
    public static boolean isALinkEnd(Object handle) {<br/>
        return handle instanceof MLinkEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Message<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMessage(Object handle) {<br/>
        return handle instanceof MMessage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Method<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMethod(Object handle) {<br/>
        return handle instanceof MMethod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Model<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Model<br/>
     */<br/>
    public static boolean isAModel(Object handle) {<br/>
        return handle instanceof MModel;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ModelElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ModelElement<br/>
     */<br/>
    public static boolean isAModelElement(Object handle) {<br/>
        return handle instanceof MModelElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Multiplicity<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Multiplicity<br/>
     */<br/>
    public static boolean isAMultiplicity(Object handle) {<br/>
        return handle instanceof MMultiplicity;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MultiplicityRange<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a MultiplicityRange<br/>
     */<br/>
    public static boolean isAMultiplicityRange(Object handle) {<br/>
        return handle instanceof MMultiplicityRange;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Namespace<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Namespace<br/>
     */<br/>
    public static boolean isANamespace(Object handle) {<br/>
        return handle instanceof MNamespace;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Node<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Node<br/>
     */<br/>
    public static boolean isANode(Object handle) {<br/>
        return handle instanceof MNode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a NodeInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a NodeInstance<br/>
     */<br/>
    public static boolean isANodeInstance(Object handle) {<br/>
        return handle instanceof MNodeInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Operation<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Operation<br/>
     */<br/>
    public static boolean isAOperation(Object handle) {<br/>
        return handle instanceof MOperation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Object<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Object<br/>
     */<br/>
    public static boolean isAObject(Object handle) {<br/>
        return handle instanceof MObject;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Parameter<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Parameter<br/>
     */<br/>
    public static boolean isAParameter(Object handle) {<br/>
        return handle instanceof MParameter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Partition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Partition<br/>
     */<br/>
    public static boolean isAPartition(Object handle) {<br/>
        return handle instanceof MPartition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Permission<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Permission<br/>
     */<br/>
    public static boolean isAPermission(Object handle) {<br/>
        return handle instanceof MPermission;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Package<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Package<br/>
     */<br/>
    public static boolean isAPackage(Object handle) {<br/>
        return handle instanceof MPackage;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Pseudostate<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Pseudostate<br/>
     */<br/>
    public static boolean isAPseudostate(Object handle) {<br/>
        return handle instanceof MPseudostate;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for PseudostateKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a PseudostateKind<br/>
     */<br/>
    public static boolean isAPseudostateKind(Object handle) {<br/>
        return handle instanceof MPseudostateKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate<br/>
     * <br/>
     * TODO: - Do we need this as well as getKind - I think not<br/>
     * <br/>
     * @param handle the Pseudostate<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getPseudostateKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate or Parameter<br/>
     * @param handle the Pseudostate or Parameter<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receiver object of a message or stimulus<br/>
     * @param handle candidate<br/>
     * @return receiver<br/>
     */<br/>
    public static Object getReceiver(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getReceiver();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getReceiver();<br/>
        }<br/>
    return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the Link belonging to the given LinkEnd<br/>
     * @param handle the LinkEnd<br/>
     * @return the Link<br/>
     */<br/>
    public static Object getLink(Object handle) {<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getLink();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Check whether two pseudostatekinds are equal/of the same type.<br/>
     *<br/>
     * @return true if the are the same type<br/>
     * @param ps1 one kind<br/>
     * @param ps2 one kind<br/>
     */<br/>
    public static boolean equalsPseudostateKind(Object ps1, Object ps2) {<br/>
        if (isAPseudostateKind(ps1)) {<br/>
            return ((MPseudostateKind) ps1).equals(ps2);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(ps1);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Reception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Reception<br/>
     */<br/>
    public static boolean isAReception(Object handle) {<br/>
        return handle instanceof MReception;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Returnaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a returnaction<br/>
     */<br/>
    public static boolean isAReturnAction(Object handle) {<br/>
        return handle instanceof MReturnAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Relationship<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Relationship<br/>
     */<br/>
    public static boolean isARelationship(Object handle) {<br/>
        return handle instanceof MRelationship;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SendAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SendAction<br/>
     */<br/>
    public static boolean isASendAction(Object handle) {<br/>
        return handle instanceof MSendAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Signal<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Signal<br/>
     */<br/>
    public static boolean isASignal(Object handle) {<br/>
        return handle instanceof MSignal;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SignalEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SignalEvent<br/>
     */<br/>
    public static boolean isASignalEvent(Object handle) {<br/>
        return handle instanceof MSignalEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateMachine<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateMachine<br/>
     */<br/>
    public static boolean isAStateMachine(Object handle) {<br/>
        return handle instanceof MStateMachine;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for stimulus<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a stimulus<br/>
     */<br/>
    public static boolean isAStimulus(Object handle) {<br/>
        return handle instanceof MStimulus;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateVertex<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateVertex<br/>
     */<br/>
    public static boolean isAStateVertex(Object handle) {<br/>
        return handle instanceof MStateVertex;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Stereotype<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Stereotype<br/>
     */<br/>
    public static boolean isAStereotype(Object handle) {<br/>
        return handle instanceof MStereotype;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StructuralFeature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StructuralFeature<br/>
     */<br/>
    public static boolean isAStructuralFeature(Object handle) {<br/>
        return handle instanceof MStructuralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for State<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a State<br/>
     */<br/>
    public static boolean isAState(Object handle) {<br/>
        return handle instanceof MState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Subsystem<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Subsystem<br/>
     */<br/>
    public static boolean isASubsystem(Object handle) {<br/>
        return handle instanceof MSubsystem;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TaggedValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TaggedValue<br/>
     */<br/>
    public static boolean isATaggedValue(Object handle) {<br/>
        return handle instanceof MTaggedValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Transition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isATransition(Object handle) {<br/>
        return handle instanceof MTransition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TimeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TimeEvent<br/>
     */<br/>
    public static boolean isATimeEvent(Object handle) {<br/>
        return handle instanceof MTimeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Usage<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Usage<br/>
     */<br/>
    public static boolean isAUsage(Object handle) {<br/>
        return handle instanceof MUsage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Use Case<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isAUseCase(Object handle) {<br/>
        return handle instanceof MUseCase;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for VisibilityKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a VisibilityKind<br/>
     */<br/>
    public static boolean isAVisibilityKind(Object handle) {<br/>
        return handle instanceof MVisibilityKind;<br/>
    }<br/>
<br/>
    /** <br/>
     * Recognizer for Classes that are Active<br/>
     *  <br/>
     * @param handle candidate<br/>
     * @return true if Class is Active<br/>
     */<br/>
    public static boolean isActive(Object handle) {<br/>
        if (handle instanceof MClass) {<br/>
            return ((MClass) handle).isActive();<br/>
        }<br/>
    return illegalArgumentBoolean(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for attributes that are changeable<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is changeable<br/>
     */<br/>
    public static boolean isChangeable(Object handle) {<br/>
        if (handle != null &amp;&amp; handle instanceof MStructuralFeature) {<br/>
            MChangeableKind changeability =<br/>
                ((MStructuralFeature) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
<br/>
        } else if (handle != null &amp;&amp; handle instanceof MAssociationEnd) {<br/>
            MChangeableKind changeability =<br/>
                ((MAssociationEnd) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with classifier scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has classifier scope.<br/>
     */<br/>
    public static boolean isClassifierScope(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MAttribute a = (MAttribute) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(a.getOwnerScope());<br/>
        }<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature f = (MFeature) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(f.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for concurent composite state.<br/>
     *<br/>
     * @param handle composite state<br/>
     * @return true if concurent.<br/>
     */<br/>
    public static boolean isConcurent(Object handle) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            return ((MCompositeState) handle).isConcurent();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for constructor.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a constructor.<br/>
     */<br/>
    public static boolean isConstructor(Object handle) {<br/>
        Object stereo = null;<br/>
        if (isAOperation(handle)) {<br/>
            if (ModelFacade.getStereotypes(handle).size() &gt; 0) {<br/>
                stereo = ModelFacade.getStereotypes(handle).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
        if (isAMethod(handle)) {<br/>
            Object specification =<br/>
                CoreHelper.getHelper().getSpecification(handle);<br/>
            if (ModelFacade.getStereotypes(specification).size() &gt; 0) {<br/>
                stereo =<br/>
                    ModelFacade.getStereotypes(specification).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the given element is Frozen<br/>
     * @param handle candidate<br/>
     * @return boolean true if Frozen<br/>
     */<br/>
    public static boolean isFrozen(Object handle) {<br/>
        if (handle instanceof MChangeableKind) {<br/>
            MChangeableKind ck = (MChangeableKind) handle;<br/>
            return MChangeableKind.FROZEN.equals(ck);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isComposite(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.COMPOSITE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isAggregate(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.AGGREGATE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes that are initialized.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the attribute is initialized.<br/>
     */<br/>
    public static boolean isInitialized(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MExpression init = ((MAttribute) handle).getInitialValue();<br/>
<br/>
            if (init != null<br/>
                &amp;&amp; init.getBody() != null<br/>
                &amp;&amp; init.getBody().trim().length() &gt; 0)<br/>
                return true;<br/>
            return false;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with instance scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has instance scope.<br/>
     */<br/>
    public static boolean isInstanceScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature a = (MFeature) handle;<br/>
            return MScopeKind.INSTANCE.equals(a.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for internal transitions.<br/>
     *<br/>
     * @author mvw<br/>
     * @param handle candidate<br/>
     * @return true if handle is an internal transition.<br/>
     */<br/>
    public static boolean isInternal(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            Object state = getState(handle);<br/>
            Object end0 = getSource(handle);<br/>
            Object end1 = getTarget(handle);<br/>
            if (end0 != null) {<br/>
                return ((state == end0) &amp;&amp; (state == end1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
        }<br/>
        return illegalArgumentBoolean(handle);<br/>
    }<br/>
    /**<br/>
     * Recognizer for leafs<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isLeaf(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isLeaf();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for roots<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isRoot(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isRoot();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for specifications<br/>
     *<br/>
     * @param handle candidate ModelElement<br/>
     * @return true if handle is a specification<br/>
     */<br/>
    public static boolean isSpecification(Object handle) {<br/>
<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).isSpecification();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Navigable elements<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is navigable<br/>
     */<br/>
    public static boolean isNavigable(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).isNavigable();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for primary objects.&lt;p&gt;<br/>
     *<br/>
     * A primary object is an object that is created by the parser or<br/>
     * by a user.<br/>
     * Object that are created when importing some other object are not.&lt;p&gt;<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if primary object.<br/>
     */<br/>
    public static boolean isPrimaryObject(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            for (Iterator i = element.getTaggedValues().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.hasNext(); ) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if ((GENERATED_TAG).equals(tv.getTag())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
            return true;<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with private<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has private<br/>
     */<br/>
    public static boolean isPrivate(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PRIVATE.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with public<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has public<br/>
     */<br/>
    public static boolean isPublic(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PUBLIC.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MBehaviouralFeature's that are queries.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if it is a query<br/>
     */<br/>
    public static boolean isQuery(Object handle) {<br/>
<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MBehavioralFeature) handle).isQuery();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with protected<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has protected<br/>
     */<br/>
    public static boolean isProtected(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PROTECTED.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for realize<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has a realize stereotype<br/>
     */<br/>
    public static boolean isRealize(Object handle) {<br/>
        return isStereotype(handle, "realize");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for return<br/>
     *<br/>
     * @param handle candidate parameter<br/>
     * @return true if handle is a return parameter.<br/>
     */<br/>
    public static boolean isReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            MParameter p = (MParameter) handle;<br/>
            return MParameterDirectionKind.RETURN.equals(p.getKind());<br/>
<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for singleton.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a singleton.<br/>
     */<br/>
    public static boolean isSingleton(Object handle) {<br/>
        return isStereotype(handle, "singleton");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for model elements with a given stereotype.<br/>
     *<br/>
     * @param handle candidate model element<br/>
     * @param stereotypename a string that is the stereotype name.<br/>
     * @return true if handle is an object that has the given stereotype.<br/>
     */<br/>
    public static boolean isStereotype(Object handle, String stereotypename) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            MStereotype meSt = element.getStereotype();<br/>
<br/>
            if (meSt == null)<br/>
                return false;<br/>
<br/>
            String name = meSt.getName();<br/>
            if (name == null)<br/>
                return false;<br/>
<br/>
            return name.equalsIgnoreCase(stereotypename);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /** Returns true if the given CompositeState is the top state<br/>
     * @param handle CompositeState<br/>
     * @return boolean true if top state<br/>
     */<br/>
    public static boolean isTop(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getStateMachine() != null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for type.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a type.<br/>
     */<br/>
    public static boolean isType(Object handle) {<br/>
        return isStereotype(handle, "type");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for utility.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a utility.<br/>
     */<br/>
    public static boolean isUtility(Object handle) {<br/>
        return isStereotype(handle, "utility");<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the diagrams (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Diagram.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a diagram.<br/>
     */<br/>
    public static boolean isADiagram(Object handle) {<br/>
        return handle instanceof Diagram;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Getters for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Returns the association connected to an association end or<br/>
     * the association belonging to the given link.<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociation(Object handle) {<br/>
<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAssociation();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((MLink) handle).getAssociation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the association end between some classifier and some associaton.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param assoc is the association<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociationEnd(Object handle, Object assoc) {<br/>
        if (handle instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; assoc instanceof MAssociation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifier classifier = (MClassifier) handle;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = classifier.getAssociationEnds().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAssociationEnd end = (MAssociationEnd) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((MAssociation) assoc).getConnections().contains(end))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return end;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, assoc);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Association Ends<br/>
     *<br/>
     * @param handle the object that we get the association ends from.<br/>
     * @return Collection with association ends.<br/>
     */<br/>
    public static Collection getAssociationEnds(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection endc = ((MClassifier) handle).getAssociationEnds();<br/>
            return endc;<br/>
        }<br/>
<br/>
        //...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of association roles<br/>
     *<br/>
     * @param handle the object that we get the association roles from.<br/>
     * @return Collection of association roles.<br/>
     */<br/>
    public static Collection getAssociationRoles(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getAssociationRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Attributes.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return iterator with attributes.<br/>
     */<br/>
    public static Collection getAttributes(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            //return getStructuralFeatures(c).iterator();<br/>
            //...But I (thn) got CVS conflicts, so:<br/>
            return getStructuralFeatures(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The baseclass of some stereotype<br/>
     * @param handle the stereotype<br/>
     * @return the baseclass<br/>
     */<br/>
    public static Object getBaseClass(Object handle) {<br/>
        if (isAStereotype(handle)) {<br/>
            return ((MStereotype) handle).getBaseClass();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The base of some model element<br/>
     * There is a bug in NSUML which gets the addition and base <br/>
     * relationships back to front for include relationships. Solve<br/>
     * by reversing their accessors in the code<br/>
     * @param handle the model element<br/>
     * @return the base<br/>
     */<br/>
    public static Object getBase(Object handle) {<br/>
        if (handle instanceof MAssociationEndRole) {<br/>
            return ((MAssociationEndRole) handle).getBase();<br/>
        } else if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getBase();<br/>
        } else if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getBase();<br/>
        } else if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getAddition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the bases of a classifier role.<br/>
     *<br/>
     *<br/>
     * @param handle classifier role.<br/>
     * @return the bases.<br/>
     */<br/>
    public static Collection getBases(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getBases();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behaviors of a Modelelement.<br/>
     *<br/>
     *<br/>
     * @param handle modelelement to examine.<br/>
     * @return the behaviors.<br/>
     */<br/>
    public static Collection getBehaviors(Object handle) {<br/>
        if (isAModelElement(handle))<br/>
            return ((MModelElement) handle).getBehaviors();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behavioral feature of an parameter.<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the behavioral feature.<br/>
     */<br/>
    public static Object getBehavioralFeature(Object handle) {<br/>
        if (handle instanceof MParameter)<br/>
            return ((MParameter) handle).getBehavioralFeature();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the body of an method/constraint/expression.<br/>
     *<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the body.<br/>
     */<br/>
    public static Object getBody(Object handle) {<br/>
        if (handle instanceof MMethod)<br/>
            return ((MMethod) handle).getBody();<br/>
        if (handle instanceof MConstraint)<br/>
            return ((MConstraint) handle).getBody();<br/>
        if (handle instanceof MExpression)<br/>
            return ((MExpression) handle).getBody();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return Changeability of a StructuralFeature or a AssociationEnd<br/>
     * @param handle the StructuralFeature or AssociationEnd<br/>
     * @return the Changeability<br/>
     */<br/>
    public static Object getChangeability(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getChangeability();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getChangeability();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Get the child of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the child.<br/>
     */<br/>
    public static Object getChild(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getChild();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the children of some generalizable element<br/>
     *<br/>
     * @param handle to the generalizable element.<br/>
     * @return a collection with all children.<br/>
     */<br/>
    public static Collection getChildren(Object handle) {<br/>
        if (isAGeneralizableElement(handle)) {<br/>
            return ((MGeneralizableElement) handle).getChildren();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers roles of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifiers roles of the instance<br/>
     */<br/>
    public static Collection getClassifierRoles(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getClassifierRoles();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifierRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifierss of some instance<br/>
     * @param handle the instance<br/>
     * @return the classifierss of the instance<br/>
     */<br/>
    public static Collection getClassifiers(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getClassifiers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers in state of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifierss in state<br/>
     */<br/>
    public static Collection getClassifiersInState(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifiersInState();<br/>
        }<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getClassifiersInState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the clients of some dependency<br/>
     * @param handle the dependency<br/>
     * @return the clients of the dependency<br/>
     */<br/>
    public static Collection getClients(Object handle) {<br/>
        if (isADependency(handle)) {<br/>
            return ((MDependency) handle).getClients();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the client dependencies of some classifier<br/>
     *<br/>
     * @param handle to the classifier.<br/>
     * @return an iterator with all client dependencies.<br/>
     */<br/>
    public static Collection getClientDependencies(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            Collection c = ((MModelElement) handle).getClientDependencies();<br/>
            return c;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the condition of an extend.<br/>
     *<br/>
     * @param handle The extend.<br/>
     * @return the condition<br/>
     */<br/>
    public static Object getCondition(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getCondition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the concurrency of an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @return the concurrency.<br/>
     */<br/>
    public static Object getConcurrency(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getConcurrency();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    //    public static short getConcurrency(Object handle) {<br/>
    //        if (handle != null &amp;&amp; handle instanceof MOperation) {<br/>
    //            return ((MOperation) handle).getConcurrency()<br/>
    //                == MCallConcurrencyKind.GUARDED<br/>
    //                ? GUARDED<br/>
    //                : SEQUENTIAL;<br/>
    //        }<br/>
    //        illegalArgument(handle);<br/>
    //        return (short) 0;<br/>
    //    }<br/>
<br/>
    /**<br/>
     * The list of connections to an association or link.<br/>
     *<br/>
     * @param handle to the association or link<br/>
     * @return a Collection with all connections.<br/>
     */<br/>
    public static Collection getConnections(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
            return ((MLink) handle).getConnections();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a model element contains a connection.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param connection is the connection that is searched for.<br/>
     * @return true if the model element contains a connection<br/>
     */<br/>
    public boolean containsConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections().contains(<br/>
                connection);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return the effect<br/>
     */<br/>
    public static Object getEffect(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getEffect();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the residences of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the residences of<br/>
     * @return the residence collection<br/>
     */<br/>
    public static Collection getElementResidences(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getElementResidences();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the ElementImports of this ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of ElementImports<br/>
     */<br/>
    public static Collection getElementImports2(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getElementImports2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the entry action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the entry<br/>
     */<br/>
    public static Object getEntry(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getEntry();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the exit action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the exit action<br/>
     */<br/>
    public static Object getExit(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getExit();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Expression belonging to a Guard, ChangeEvent or timeEvent<br/>
     * @param handle the Object to get the Expression from<br/>
     * @return Object the Expression<br/>
     */<br/>
    public static Object getExpression(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getExpression();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MChangeEvent) {<br/>
            return ((MChangeEvent) handle).getChangeExpression();<br/>
        }<br/>
        if (handle instanceof MTimeEvent) {<br/>
            return ((MTimeEvent) handle).getWhen();<br/>
        }       <br/>
        return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case or extension point<br/>
     *<br/>
     * @param handle is the use case or the extension point<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends();<br/>
        }<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getExtends();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the use case extension of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @return The extension<br/>
     */<br/>
    public static Object getExtension(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtension();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Extensionpoint at given index-number<br/>
     * @param handle Extend<br/>
     * @param index int<br/>
     * @return ExtensionPoint<br/>
     */<br/>
    public static Object getExtensionPoint(Object handle, int index) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoint(index);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case or the extend<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtensionPoints(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtensionPoints();<br/>
        }<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Features from a Classifier.<br/>
     *<br/>
     * @param handle Classifier to retrieve from.<br/>
     * @return Collection with Features<br/>
     */<br/>
    public static Collection getFeatures(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getFeatures();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.<br/>
     *<br/>
     * @param handle is the child<br/>
     * @param parent is the parent<br/>
     * @return The generalization<br/>
     */<br/>
    public static Object getGeneralization(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralizableElement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = getGeneralizations(handle).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MGeneralization gen = (MGeneralization) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gen.getParent() == parent) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return gen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Generalizations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Generalizations<br/>
     */<br/>
    public static Collection getGeneralizations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getGeneralizations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the guard for some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getGuard(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getGuard();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Icon of a Stereotype<br/>
     * @param handle the Stereotype to get the Icon from<br/>
     * @return the Icon<br/>
     */<br/>
    public static Object getIcon(Object handle) {<br/>
        if (handle instanceof MStereotype) {<br/>
            return ((MStereotype) handle).getIcon();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the component of some element residence<br/>
     *<br/>
     * @param handle is an element residence<br/>
     * @return component<br/>
     */<br/>
    public static Object getImplementationLocation(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getImplementationLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the incoming transitions for some statevertex<br/>
     *<br/>
     * @param handle is the state vertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getIncomings(Object handle) {<br/>
        if (isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getIncomings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the initial value for some attribute.<br/>
     *<br/>
     * @param handle is the attribute<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInitialValue(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            return ((MAttribute) handle).getInitialValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the instance of an AttributeLink or LinkEnd<br/>
     *<br/>
     * @param handle is the attribute link or link end<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInstance(Object handle) {<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getInstance();<br/>
        }<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getInstance();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Instances for some Clasifier<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInstances(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getInstances();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of States for some ClasifierInState<br/>
     *<br/>
     * @param handle is the classifierInState<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInStates(Object handle) {<br/>
        if (handle instanceof MClassifierInState) {<br/>
            return ((MClassifierInState) handle).getInStates();<br/>
        }<br/>
    return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interaction for some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the interaction<br/>
     */<br/>
    public static Object getInteraction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getInteraction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interactions belonging to a collaboration<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInteractions(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getInteractions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the internal transitions belonging to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInternalTransitions(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getInternalTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages(Object handle) {<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getMessages();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some other message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages3(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the messages that are activated by the given message<br/>
     * @param handle Message<br/>
     * @return the Collection of Messages<br/>
     */<br/>
    public static Collection getMessages4(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages4();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages received by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages1(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages1();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages send by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages2(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the model of some model element<br/>
     *<br/>
     * @param handle to the model element.<br/>
     * @return model for the model element.<br/>
     */<br/>
    public static Object getModel(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            MModel m = ((MModelElement) handle).getModel();<br/>
            return m;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle an Element Import.<br/>
     * @return the model element<br/>
     */<br/>
    public static Object getModelElement(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MElementImport) handle).getModelElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Multiplicity from a model element.<br/>
     *<br/>
     * @param handle model element to retrieve from.<br/>
     * @return multiplicity<br/>
     */<br/>
    public static Object getMultiplicity(Object handle) {<br/>
        if ((handle instanceof MAssociationEnd)) {<br/>
            return ((MAssociationEnd) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MAssociationRole)) {<br/>
            return ((MAssociationRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MClassifierRole)) {<br/>
            return ((MClassifierRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MStructuralFeature)) {<br/>
            return ((MStructuralFeature) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Ranges from a Multiplicity.<br/>
     *<br/>
     * @param handle multiplicity to retrieve from.<br/>
     * @return iterator containing ranges<br/>
     */<br/>
    public static Iterator getRanges(Object handle) {<br/>
        if ((handle instanceof MMultiplicity)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection c = ((MMultiplicity) handle).getRanges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (c == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return c.iterator();<br/>
        }<br/>
        illegalArgument(handle);<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the comments of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the comments of<br/>
     * @return the comment (or null)<br/>
     */<br/>
    public static Collection getComments(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getComments();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication connection of an message.<br/>
     *<br/>
     * @param handle the message that we are getting the communication<br/>
     * connection<br/>
     * @return the communication connection<br/>
     */<br/>
    public static Object getCommunicationConnection(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getCommunicationConnection();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication link of a stimulus.<br/>
     *<br/>
     * @param handle the message that we are getting the communication link<br/>
     * @return the communication link<br/>
     */<br/>
    public static Object getCommunicationLink(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getCommunicationLink();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the collaborations of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the<br/>
     * collaborations of.<br/>
     * @return the collaborations<br/>
     */<br/>
    public static Collection getCollaborations(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public static void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the component instance of an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @return the component instance<br/>
     */<br/>
    public static Object getComponentInstance(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getComponentInstance();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the collection of ConstrainingElements of a Collaboration<br/>
     * @param handle the Collaboration<br/>
     * @return the collection of ConstrainingElements<br/>
     */<br/>
    public static Collection getConstrainingElements(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getConstrainingElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    <span class="add"><span class="add">/** <br/>
     * Returns the collection of ConstrainedElements of a constraint<br/>
     * @param handle the Constraint<br/>
     * @return the collection of ConstrainedElements<br/>
     */</span><br/>
    <span class="add">public</span> <span class="add">static</span> <span class="add"><span class="add">Collection</span></span> <span class="add">getConstrainedElements</span>(<span class="add"><span class="add"><span class="add">Object</span></span> <span class="add">handle</span></span>) <span class="add">{<br/>
        <span class="add">if (<span class="add"><span class="add">handle</span> instanceof <span class="add"><span class="add">MConstraint</span></span></span>) <span class="add">{<br/>
            <span class="add">return <span class="add"><span class="add">(<span class="add">(<span class="add"><span class="add">MConstraint</span></span>) <span class="add">handle</span></span>)</span>.<span class="add">getConstrainedElements</span>()</span>;</span><br/>
        }</span></span><br/>
        <span class="add">return <span class="add"><span class="add">illegalArgumentCollection</span>(<span class="add">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    /**<br/>
     * Get the collection of all constraints of the given ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of all constraints<br/>
     */<br/>
    public static Collection getConstraints(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getConstraints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the container for the given modelelement. The container is the<br/>
     * owner of the modelelement. It will be null for elements that don't have<br/>
     * an owner. All elements except for the root element in a project should<br/>
     * have an owner. The root element is allways a model.&lt;p&gt;<br/>
     *<br/>
     * In  the future, this function could return the container of Figs too.<br/>
     *<br/>
     * @param handle is the base<br/>
     * @return Object<br/>
     */<br/>
    public static Object getModelElementContainer(Object handle) {<br/>
        if (handle instanceof MBase) {<br/>
            return ((MBase) handle).getModelElementContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the CompositeState that is the container of the given StateVertex<br/>
     * @param handle the StateVertex<br/>
     * @return the CompositeState that is the container <br/>
     */<br/>
    public static Object getContainer(Object handle) {<br/>
        if (handle instanceof MStateVertex) {<br/>
            return ((MStateVertex) handle).getContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the collection of ModelElements contained in a Partition<br/>
     * @param handle the Partition<br/>
     * @return the contents of the Partition<br/>
     */<br/>
    public static Collection getContents(Object handle) {<br/>
        if (handle instanceof MPartition) {<br/>
            return ((MPartition) handle).getContents();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction.<br/>
     *<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */<br/>
    public static Object getContext(Object handle) {<br/>
        if (isAStateMachine(handle)) {<br/>
            return ((MStateMachine) handle).getContext();<br/>
        }<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getContext();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the collection of the Contexts of a given Signal<br/>
     * @param handle the Signal<br/>
     * @return a collection of the Contexts<br/>
     */<br/>
    public static Collection getContexts(Object handle) {<br/>
        if (handle instanceof MSignal) {<br/>
            return ((MSignal) handle).getContexts();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the collection of Actions that create/instantiate<br/>
     *  the given Classifier <br/>
     * <br/>
     * @param handle the Classifier<br/>
     * @return a collection containing all the creating actions<br/>
     */<br/>
    public static Collection getCreateActions(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCreateActions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the default value of a parameter<br/>
     *<br/>
     * @param handle the parameter that we are getting the defaultvalue from<br/>
     * @return the default value<br/>
     */<br/>
    public static Object getDefaultValue(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getDefaultValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get deferrable events of a state<br/>
     *<br/>
     * @param handle the state that we are getting the deferrable event from<br/>
     * @return the deferrable events collection<br/>
     */<br/>
    public static Collection getDeferrableEvents(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getDeferrableEvents();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */<br/>
    public static Collection getDeploymentLocations(Object handle) {<br/>
        if (isAComponent(handle)) {<br/>
            return ((MComponent) handle).getDeploymentLocations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the discriminator.<br/>
     *<br/>
     * @param handle the Generalization<br/>
     * @return the discriminator a String<br/>
     */<br/>
    public static Object getDiscriminator(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getDiscriminator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * <br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */<br/>
    public static void setDiscriminator(Object handle, String discriminator) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the dispatchaction of a stimulus.<br/>
     *<br/>
     * @param handle the stimulus that we are getting the dispatchaction of<br/>
     * @return the dispatchaction (or null)<br/>
     */<br/>
    public static Object getDispatchAction(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getDispatchAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the do activity action of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the do activity<br/>
     */<br/>
    public static Object getDoActivity(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getDoActivity();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the Links of a given Association<br/>
     * @param handle the Association<br/>
     * @return the collection of Links<br/>
     */<br/>
    public static Collection getLinks(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getLinks();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the LinkEnds of a given Instance or AssociationEnd<br/>
     * @param handle the candidate<br/>
     * @return the collection of LinkEnds<br/>
     */<br/>
    public static Collection getLinkEnds(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getLinkEnds();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getLinkEnds();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets a location of some extension point.<br/>
     *<br/>
     * @param handle extension point<br/>
     * @return the location<br/>
     */<br/>
    public static String getLocation(Object handle) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the methods of an operation.<br/>
     *<br/>
     * @param handle the operation that we are getting the methods of<br/>
     * @return methods collection (or null)<br/>
     */<br/>
    public static Collection getMethods(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).getMethods();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the namespace of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the namespace of<br/>
     * @return the namespace (or null)<br/>
     */<br/>
    public static Object getNamespace(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getNamespace();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the node instance of a component instance.<br/>
     *<br/>
     * @param handle the model element that we are getting the node instance of<br/>
     * @return the node instance<br/>
     */<br/>
    public static Object getNodeInstance(Object handle) {<br/>
        if (handle instanceof MComponentInstance)<br/>
            return ((MComponentInstance) handle).getNodeInstance();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The collection of object flow states<br/>
     *<br/>
     * @param handle the classifier<br/>
     * @return collection of object flow states<br/>
     */<br/>
    public static Collection getObjectFlowStates(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getObjectFlowStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the operation of a Call Action or Call Event.<br/>
     *<br/>
     * @param handle the model element that we are getting the operation of<br/>
     * @return the Operation<br/>
     */<br/>
    public static Object getOperation(Object handle) {<br/>
        if (handle instanceof MCallAction) {<br/>
            return ((MCallAction) handle).getOperation();<br/>
        }<br/>
        if (handle instanceof MCallEvent) {<br/>
            return ((MCallEvent) handle).getOperation();<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of operations.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Collection with operations.<br/>
     */<br/>
    public static Collection getOperations(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            return getOperations(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of Operations of this classifier and all inherited.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Iterator with operations.<br/>
     */<br/>
    public static Iterator getOperationsInh(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            return CoreHelper.getHelper().getOperationsInh(c).iterator();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the opposite end of an association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @return Object the opposite end.<br/>
     */<br/>
    public static Object getOppositeEnd(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getOppositeEnd();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get ordering of an association end<br/>
     *<br/>
     * @param handle association end to retrieve from<br/>
     * @return ordering<br/>
     */<br/>
    public static Object getOrdering(Object handle) {<br/>
        if (handle instanceof MAssociationEnd)<br/>
            return ((MAssociationEnd) handle).getOrdering();<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the list of Transitions outgoing from the given stateVertex.<br/>
     *<br/>
     * @param handle statevertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getOutgoings(Object handle) {<br/>
        if (ModelFacade.isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getOutgoings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the list of Associations Ends connected to this association end.<br/>
     *<br/>
     * @param handle association end to start from<br/>
     * @return Iterator with all connected association ends.<br/>
     */<br/>
    public static Collection getOtherAssociationEnds(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            MAssociation a = ((MAssociationEnd) handle).getAssociation();<br/>
<br/>
            if (a == null)<br/>
                return emptyCollection();<br/>
<br/>
            Collection allEnds = a.getConnections();<br/>
            if (allEnds == null)<br/>
                return emptyCollection();<br/>
<br/>
            // TODO: An Iterator filter would be nice here instead of the<br/>
            // mucking around with the Collection.<br/>
            allEnds = new ArrayList(allEnds);<br/>
            allEnds.remove(handle);<br/>
            return allEnds;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of owned elements of the the package.<br/>
     *<br/>
     * @param handle package to retrieve from.<br/>
     * @return Iterator with operations<br/>
     */<br/>
    public static Collection getOwnedElements(Object handle) {<br/>
        if (handle instanceof MNamespace) {<br/>
            return ((MNamespace) handle).getOwnedElements();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the owner scope of a feature<br/>
     *<br/>
     * @param handle feature<br/>
     * @return owner scope<br/>
     */<br/>
    public static Object getOwnerScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getOwnerScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the powertype of a generalization<br/>
     *<br/>
     * @param handle generalization<br/>
     * @return powertype<br/>
     */<br/>
    public static Object getPowertype(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getPowertype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the powertype ranges of a classifier.<br/>
     *<br/>
     * @param handle classifier to retrieve from<br/>
     * @return collection of poertype ranges<br/>
     */<br/>
    public static Collection getPowertypeRanges(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getPowertypeRanges();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the predecessors of a message.<br/>
     *<br/>
     * @param handle message to retrieve from<br/>
     * @return collection of predecessors<br/>
     */<br/>
    public static Collection getPredecessors(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getPredecessors();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if the passed parameter has a RETURN direction kind<br/>
     *<br/>
     * @return true if it is a return direction kind<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static boolean hasReturnParameterDirectionKind(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MParameter parameter = (MParameter) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameterDirectionKind.RETURN.equals(parameter.getKind()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Package that is connected by the given ElementImport <br/>
     * @param handle the ElementImport <br/>
     * @return the Package<br/>
     */<br/>
    public static Object getPackage(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
            return ((MElementImport) handle).getPackage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get a parameter of a behavioral feature.<br/>
     *<br/>
     * @param handle behavioral feature to retrieve from<br/>
     * @param n parameter number<br/>
     * @return parameter.<br/>
     */<br/>
    public static Object getParameter(Object handle, int n) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) handle).getParameter(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the parameters of a Object Flow State, Behavioral Feature, <br/>
     * Classifier or Event.<br/>
     *<br/>
     * @param handle operation to retrieve from<br/>
     * @return Iterator with operations.<br/>
     */<br/>
    public static Collection getParameters(Object handle) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MEvent) {<br/>
            return ((MEvent) handle).getParameters();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getParameters();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the parent.<br/>
     */<br/>
    public static Object getParent(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getParent();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the raised signals of an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @return raised signals<br/>
     */<br/>
    public static Collection getRaisedSignals(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getRaisedSignals();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receptions of a signal.<br/>
     *<br/>
     * @param handle is the signal<br/>
     * @return receptions<br/>
     */<br/>
    public static Collection getReceptions(Object handle) {<br/>
        if (handle instanceof MSignal) {<br/>
            return ((MSignal) handle).getReceptions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the recurrence iteration expression of an action.<br/>
     *<br/>
     * @param handle is the action.<br/>
     * @return the recurrence<br/>
     */<br/>
    public static Object getRecurrence(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getRecurrence();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the represented classifier of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented classifier<br/>
     */<br/>
    public static Object getRepresentedClassifier(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getRepresentedClassifier();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the represented operation of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented operation<br/>
     */<br/>
    public static Object getRepresentedOperation(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getRepresentedOperation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the script belonging to a given action<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the script<br/>
     */<br/>
    public static Object getScript(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getScript();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     *<br/>
     * @param handle is the stimulus or message<br/>
     * @return the sender<br/>
     */<br/>
    public static Object getSender(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getSender();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getSender();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     * TODO: Check if this javadoc comment is really correct?<br/>
     *<br/>
     * @param handle is the object<br/>
     * @return the signal<br/>
     */<br/>
    public static Object getSignal(Object handle) {<br/>
        if (handle instanceof MSendAction) {<br/>
            return ((MSendAction) handle).getSignal();<br/>
        }<br/>
        if (handle instanceof MSignalEvent) {<br/>
            return ((MSignalEvent) handle).getSignal();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).getSignal();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the resident element<br/>
     *<br/>
     * @param handle is the element residence<br/>
     * @return resident element<br/>
     */<br/>
    public static Object getResident(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getResident();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of elements in a given component<br/>
     * @param handle the component<br/>
     * @return the Collection of ResidentElements<br/>
     */<br/>
    public static Collection getResidentElements(Object handle) {<br/>
        if (handle instanceof MComponent) {<br/>
            return ((MComponent) handle).getResidentElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a collection with all residents belonging to the given<br/>
     * node.<br/>
     *<br/>
     * @param handle is the node, nodeinstance, componentinstance<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getResidents(Object handle) {<br/>
        if (isANode(handle)) {<br/>
            return ((MNode) handle).getResidents();<br/>
        }<br/>
        if (isANodeInstance(handle)) {<br/>
            return ((MNodeInstance) handle).getResidents();<br/>
        }<br/>
        if (isAComponentInstance(handle)) {<br/>
            return ((MComponentInstance) handle).getResidents();<br/>
        }<br/>
            <br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the source for a given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object (MStateVertex)<br/>
     */<br/>
    public static Object getSource(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getSource();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the source for some given flow.<br/>
     *<br/>
     * @param handle is the flow<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getSources(Object handle) {<br/>
        if (handle instanceof MFlow) {<br/>
            return ((MFlow) handle).getSources();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the sourceflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of sourceflows<br/>
     */<br/>
    public static Collection getSourceFlows(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getSourceFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Specializations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Collection of Specializations.<br/>
     */<br/>
    public static Collection getSpecializations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getSpecializations();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the state machine belonging to some given state or transition<br/>
     * If you need to find the StateMachine for an internal transition,<br/>
     * or for ANY state, <br/>
     * use StateMachinesHelper.getStateMachine() instead.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getStateMachine(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getStateMachine();<br/>
        }<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the state belonging to some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getState(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the states from a deferable event<br/>
     *<br/>
     * @param handle is the event<br/>
     * @return Object<br/>
     */<br/>
    public static Collection getStates(Object handle) {<br/>
        if (handle instanceof MEvent) {<br/>
            return ((MEvent) handle).getStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stereotype belonging to some given model element<br/>
     *<br/>
     * @param handle is a model element<br/>
     * @return Object<br/>
     * @deprecated 0.15 in favor of getStereotypes since UML 1.5 supports <br/>
     * multiple stereotypes<br/>
     */<br/>
    public static Object getStereoType(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            return ((MModelElement) handle).getStereotype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stereotypes belonging to some given model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return stereotype collection<br/>
     */<br/>
    public static Collection getStereotypes(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            // This returns a collection as we have an eye on the future<br/>
            // and multiple stereotypes in UML1.5<br/>
            ArrayList list = new ArrayList(1);<br/>
            list.add(((MModelElement) handle).getStereotype());<br/>
            return list;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the stimuli belonging to some given link<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return Object<br/>
     */<br/>
    public static Collection getStimuli(Object handle) {<br/>
        if (isALink(handle)) {<br/>
            return ((MLink) handle).getStimuli();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Stimuli that are received by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */<br/>
    public static Collection getStimuli2(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getStimuli2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Stimuli that are send by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */<br/>
    public static Collection getStimuli3(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getStimuli3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a collection with all subvertices belonging to the given<br/>
     * composite state.<br/>
     *<br/>
     * @param handle is the composite state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getSubvertices(Object handle) {<br/>
        if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getSubvertices();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the submachie of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */<br/>
    public static Object getSubmachine(Object handle) {<br/>
        if (handle instanceof MSubmachineState) {<br/>
            return ((MSubmachineState) handle).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the submachine of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */<br/>
    public static Collection getSubmachineStates(Object handle) {<br/>
        if (handle instanceof MStateMachine) {<br/>
            return ((MStateMachine) handle).getSubmachineStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of SupplierDependencies from a ModelElement.<br/>
     *<br/>
     * @param handle model element.<br/>
     * @return Iterator with the supplier dependencies.<br/>
     */<br/>
    public static Collection getSupplierDependencies(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            return me.getSupplierDependencies();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The top of a state machine<br/>
     *<br/>
     * @param handle the state machine<br/>
     * @return the top<br/>
     */<br/>
    public static Object getTop(Object handle) {<br/>
        if (handle instanceof MStateMachine) {<br/>
            return ((MStateMachine) handle).getTop();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the transition of a guard or action<br/>
     *<br/>
     * @param handle the guard or action<br/>
     * @return the transition<br/>
     */<br/>
    public static Object getTransition(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getTransition();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getTransition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the trigger of a transition<br/>
     *<br/>
     * @param handle the transition<br/>
     * @return the trigger<br/>
     */<br/>
    public static Object getTrigger(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getTrigger();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The type of a StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     *<br/>
     * @param handle the StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     * @return the type<br/>
     */<br/>
    public static Object getType(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MAttribute) handle).getType();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getType();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getType();<br/>
        }<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) handle).getType();<br/>
        }<br/>
        <br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the target of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getTarget(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getTarget();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the target scope of some model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Object<br/>
     */<br/>
    public static Object getTargetScope(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getTargetScope();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getTargetScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the targetflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of targetflows<br/>
     */<br/>
    public static Collection getTargetFlows(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTargetFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */<br/>
    public static int getUpper(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            int upper = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getMultiplicity() != null)<br/>
                upper = end.getMultiplicity().getUpper();<br/>
            return upper;<br/>
        }<br/>
        if (isAMultiplicity(handle)) {<br/>
            MMultiplicity up = (MMultiplicity) handle;<br/>
            return up.getUpper();<br/>
        }<br/>
        if (isAMultiplicityRange(handle)) {<br/>
            MMultiplicityRange up = (MMultiplicityRange) handle;<br/>
            return up.getUpper();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the use case of an extension point<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @return a use case<br/>
     */<br/>
    public static Object getUseCase(Object handle) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getUseCase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */<br/>
    public static int getLower(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            int lower = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getMultiplicity() != null)<br/>
                lower = end.getMultiplicity().getLower();<br/>
            return lower;<br/>
        }<br/>
        if (isAMultiplicity(handle)) {<br/>
            MMultiplicity low = (MMultiplicity) handle;<br/>
            return low.getLower();<br/>
        }<br/>
        if (isAMultiplicityRange(handle)) {<br/>
            MMultiplicityRange low = (MMultiplicityRange) handle;<br/>
            return low.getLower();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the transitions belonging to the given handle. The handle can be<br/>
     * a statemachine or a composite state or an event. <br/>
     * If it's a statemachine the<br/>
     * transitions will be given back belonging to that statemachine. If it's a<br/>
     * compositestate the internal transitions of that compositestate will be<br/>
     * given back. <br/>
     * If it's an event, all transitions triggered by this event <br/>
     * will be given back.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getTransitions(Object handle) {<br/>
        if (isAStateMachine(handle)) {<br/>
            return ((MStateMachine) handle).getTransitions();<br/>
        } else if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getInternalTransitions();<br/>
        } else if (isAEvent(handle)) {<br/>
            return ((MEvent) handle).getTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param handle is the classifier you want to have the attributes for.<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public static Collection getStructuralFeatures(Object handle) {<br/>
        Collection result = new ArrayList();<br/>
        if (ModelFacade.isAClassifier(handle)) {<br/>
            MClassifier mclassifier = (MClassifier) handle;<br/>
<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (ModelFacade.isAStructuralFeature(feature))<br/>
                    result.add(feature);<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier<br/>
     *<br/>
     * @param mclassifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    protected static Collection getOperations(MClassifier mclassifier) {<br/>
        Collection result = new ArrayList();<br/>
        Iterator features = mclassifier.getFeatures().iterator();<br/>
        while (features.hasNext()) {<br/>
            MFeature feature = (MFeature) features.next();<br/>
            if (ModelFacade.isAOperation(feature))<br/>
                result.add(feature);<br/>
        }<br/>
        return result;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Returns the Specification of a given Reception<br/>
     * @param handle the Reception<br/>
     * @return String the Specification<br/>
     */<br/>
    public static String getSpecification(Object handle) {<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).getSpecification();<br/>
        }<br/>
        return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all Interfaces of which this class is a realization.<br/>
     *<br/>
     * @param handle  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */<br/>
    public static Collection getSpecifications(Object handle) {<br/>
        Collection result = new Vector();<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getSpecifications();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection deps = ((MClassifier) handle).getClientDependencies();<br/>
            Iterator depIterator = deps.iterator();<br/>
            while (depIterator.hasNext()) {<br/>
                MDependency dep = (MDependency) depIterator.next();<br/>
                if ((dep instanceof MAbstraction)<br/>
                        &amp;&amp; dep.getStereotype() != null<br/>
                        &amp;&amp; dep.getStereotype().getName() != null<br/>
                        &amp;&amp; dep.getStereotype().getName().equals("realize")) {<br/>
                    MInterface i =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MInterface) dep.getSuppliers().toArray()[0];<br/>
                    result.add(i);<br/>
                }<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the suppliers of a dependency.<br/>
     *<br/>
     * @param handle is the dependency<br/>
     * @return a collection of the suppliers<br/>
     */<br/>
    public static Collection getSuppliers(Object handle) {<br/>
        if (handle instanceof MDependency) {<br/>
            return ((MDependency) handle).getSuppliers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the action belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the action<br/>
     */<br/>
    public static Object getAction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the activator belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the activator<br/>
     */<br/>
    public static Object getActivator(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getActivator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the actual arguments for a given action.<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the actual arguments<br/>
     */<br/>
    public static Collection getActualArguments(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getActualArguments();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns an addition for a given inlcude.<br/>
     * There is a bug in NSUML which gets the addition and base<br/>
     * relationships back to front for include relationships. Solve<br/>
     * reversing their accessors in the code<br/>
     *<br/>
     * @param handle is the include<br/>
     * @return the addition<br/>
     */<br/>
    public static Object getAddition(Object handle) {<br/>
        if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getBase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the AggregationKind of a given AssociationEnd<br/>
     * @param handle the AssociationEnd<br/>
     * @return the AggregationKind<br/>
     */<br/>
    public static Object getAggregation(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAggregation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all associated classes for some given classifier.<br/>
     * Returns an empty collection if the given argument handle is not<br/>
     * a classifier.  The given parameter is included in the returned<br/>
     * collection if it has a self-referencing association.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getAssociatedClasses(Object handle) {<br/>
        Collection col = new ArrayList();<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) handle;<br/>
            Collection ends = classifier.getAssociationEnds();<br/>
            Iterator it = ends.iterator();<br/>
            Set associations = new HashSet();<br/>
            while (it.hasNext()) {<br/>
                MAssociationEnd ae = (MAssociationEnd) it.next();<br/>
                associations.add(ae.getAssociation());<br/>
            }<br/>
            Collection otherEnds = new ArrayList();<br/>
            it = associations.iterator();<br/>
            while (it.hasNext()) {<br/>
                otherEnds.addAll(((MAssociation) it.next()).getConnections());<br/>
            }<br/>
            otherEnds.removeAll(ends);<br/>
            it = otherEnds.iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getType());<br/>
            }<br/>
            return col;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Common getters<br/>
<br/>
    /**<br/>
     * The name of a model element or some diagram part.<br/>
     *<br/>
     * @param handle that points out the object.<br/>
     * @return the name<br/>
     */<br/>
    public static String getName(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getName();<br/>
        }<br/>
        if (handle instanceof Diagram) {<br/>
            return ((Diagram) handle).getName();<br/>
        }<br/>
        if (handle instanceof MOrderingKind) {<br/>
            return ((MOrderingKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MAggregationKind) {<br/>
            return ((MAggregationKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MVisibilityKind) {<br/>
            return ((MVisibilityKind) handle).getName();<br/>
        }<br/>
        if (handle instanceof MCallConcurrencyKind) {<br/>
            return ((MCallConcurrencyKind) handle).getName();<br/>
        }<br/>
        illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the owner of a feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @return classifier<br/>
     */<br/>
    public static Object getOwner(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getOwner();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tag of a tagged value.<br/>
     *<br/>
     * @param handle The tagged value belongs to this.<br/>
     * @return The found tag as a String.<br/>
     */<br/>
    public static String getTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tagged values iterator of a model element.<br/>
     *<br/>
     * @param handle The tagged values belong to this.<br/>
     * @return The tagged values iterator<br/>
     */<br/>
    public static Iterator getTaggedValues(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTaggedValues().iterator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the TaggedValues of a ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the Collection of TaggedValues<br/>
     */<br/>
    public static Collection getTaggedValuesCollection(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getTaggedValues();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The found tag, null if not found<br/>
     */<br/>
    public static Object getTaggedValue(Object handle, String name) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = ((MModelElement) handle);<br/>
            Iterator i = me.getTaggedValues().iterator();<br/>
            while (i.hasNext()) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if (tv.getTag().equals(name)) {<br/>
                    return tv;<br/>
                }<br/>
            }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return the value of a tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element that the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The value of the found tag. "" if not found.<br/>
     */<br/>
    public static String getTaggedValueValue(Object handle, String name) {<br/>
        Object taggedValue = getTaggedValue(handle, name);<br/>
        if (taggedValue == null) {<br/>
            return "";<br/>
        }<br/>
        return getValueOfTag(taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the key (tag) of some tagged value.<br/>
     * <br/>
     * TODO: This does exactly the same as getTag(Object). Remove one of them.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */<br/>
    public static String getTagOfTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Value of some UML Object<br/>
     * @param handle Object<br/>
     * @return Object the exact type depends on the handle type<br/>
     * (String, Expression, Instance, TaggedValue...)<br/>
     */<br/>
    public static Object getValue(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MArgument) {<br/>
            return ((MArgument) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MExtension) {<br/>
            return ((MExtension) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getValue();<br/>
        }<br/>
        if (handle instanceof MAggregationKind) {<br/>
            return new Integer(((MAggregationKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MOrderingKind) {<br/>
            return new Integer(((MOrderingKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MOperationDirectionKind) {<br/>
            return new Integer(((MOperationDirectionKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MVisibilityKind) {<br/>
            return new Integer(((MVisibilityKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MScopeKind) {<br/>
            return new Integer(((MScopeKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MMessageDirectionKind) {<br/>
            return new Integer(((MMessageDirectionKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MChangeableKind) {<br/>
            return new Integer(((MChangeableKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MPseudostateKind) {<br/>
            return new Integer(((MPseudostateKind) handle).getValue());<br/>
        }<br/>
        if (handle instanceof MCallConcurrencyKind) {<br/>
            return new Integer(((MCallConcurrencyKind) handle).getValue());<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the value of some tagged value.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */<br/>
    public static String getValueOfTag(Object handle) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) handle).getValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return the UUID of this element<br/>
     *<br/>
     * @param base base element (MBase type)<br/>
     * @return UUID<br/>
     */<br/>
    public static String getUUID(Object base) {<br/>
        if (isABase(base)) {<br/>
            return ((MBase) base).getUUID();<br/>
        }<br/>
        if (base instanceof CommentEdge) {<br/>
            return (String) ((CommentEdge) base).getUUID();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(base);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    /**<br/>
     *  Return the visibility of this element<br/>
     *  @param handle an nsuml model element<br/>
     *  @return visibility<br/>
     */<br/>
    public static Object getVisibility(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getVisibility();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Other querying methods<br/>
<br/>
    /**<br/>
     * Returns a named object in the given object by calling it's lookup method.<br/>
     *<br/>
     * @param handle the object that we search through<br/>
     * @param name of the model element<br/>
     * @return found object, null otherwise<br/>
     */<br/>
    public static Object lookupIn(Object handle, String name) {<br/>
        if (handle instanceof MModel)<br/>
            return ((MModel) handle).lookup(name);<br/>
        if (handle instanceof MNamespace)<br/>
            return ((MNamespace) handle).lookup(name);<br/>
        if (handle instanceof MClassifier)<br/>
            return ((MClassifier) handle).lookup(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Model modifying methods<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */<br/>
    public static void addFeature(Object handle, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) handle).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an instance to a classifier role.<br/>
     *<br/>
     * @param classifierRole is the classifier role<br/>
     * @param instance is the instance to add<br/>
     */<br/>
    public static void addInstance(Object classifierRole, Object instance) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if (classifierRole instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; instance instanceof MInstance) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifierRole clr = (MClassifierRole) classifierRole;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    clr.addInstance((MInstance) instance);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(classifierRole, instance);<br/>
    }<br/>
<br/>
    /**<br/>
     * @author mvw<br/>
     * @param classifierInState the classifierInState<br/>
     * @param state the state that will be linked<br/>
     */<br/>
    public static void addInState(Object classifierInState, Object state) {<br/>
        if (classifierInState instanceof MClassifierInState <br/>
                &amp;&amp; state instanceof MState) {<br/>
            ((MClassifierInState) classifierInState).addInState((MState) state);<br/>
        } else<br/>
            illegalArgument(classifierInState, state);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */<br/>
    public static void addFeature(Object handle, int index, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) handle).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, f);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add the given Link to the given Link or Association<br/>
     * @param handle the Link or Association <br/>
     * @param link Link<br/>
     */<br/>
    public static void addLink(Object handle, Object link) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAssociation) handle).addLink((MLink) link);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, link);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add Message to a predecessor Message<br/>
     * @param handle predecessor Message<br/>
     * @param mess Message to be added<br/>
     */<br/>
    public static void addMessage3(Object handle, Object mess) {<br/>
        if (handle instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) handle).addMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */<br/>
    public static void addMethod(Object handle, Object m) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) handle).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) handle).getOwnerScope());<br/>
            ((MOperation) handle).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, m);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a model element to some namespace.<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */<br/>
    public static void addOwnedElement(Object handle, Object me) {<br/>
        if (handle instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) handle).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, me);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MObjectFlowState, MEvent, MBehavioralFeature, MClassifier<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public static void addParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).addParameter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object at given location<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MEvent, MBehavioralFeature<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public static void addParameter(<br/>
        Object handle,<br/>
        int index,<br/>
        Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a predecessor to a message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param predecessor is the predecessor<br/>
     */<br/>
    public static void addPredecessor(Object handle, Object predecessor) {<br/>
        if (handle != null<br/>
            &amp;&amp; handle instanceof MMessage<br/>
            &amp;&amp; predecessor != null<br/>
            &amp;&amp; predecessor instanceof MMessage) {<br/>
            ((MMessage) handle).addPredecessor((MMessage) predecessor);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, predecessor);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a raised Signal to a Message or Operation<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */<br/>
    public static void addRaisedSignal(Object handle, Object sig) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (handle instanceof MMessage) {<br/>
                ((MBehavioralFeature) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MOperation) {<br/>
                ((MOperation) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, sig);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a stimulus to a action or link<br/>
     *<br/>
     * @param handle the action or link<br/>
     * @param stimulus is the stimulus<br/>
     */<br/>
    public static void addStimulus(Object handle, Object stimulus) {<br/>
        if (handle != null<br/>
            &amp;&amp; stimulus != null<br/>
            &amp;&amp; stimulus instanceof MStimulus) {<br/>
            if (handle instanceof MAction) {<br/>
                ((MAction) handle).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stimulus);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a subvertex to a composite state<br/>
     * @param handle the CompositeState<br/>
     * @param subvertex the StateVertex<br/>
     */<br/>
    public static void addSubvertex(Object handle, Object subvertex) {<br/>
        if (handle instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) handle).addSubvertex((MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertex);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */<br/>
    public static void addSupplier(Object handle, Object element) {<br/>
        if (isADependency(handle) &amp;&amp; isAModelElement(element)) {<br/>
            ((MDependency) handle).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public static void addSupplierDependency(<br/>
            Object supplier, <br/>
            Object dependency) {<br/>
        if (isAModelElement(supplier) &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        illegalArgument(supplier, dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an actual argument to an action<br/>
     * @param handle the action<br/>
     * @param argument the argument<br/>
     */<br/>
    public static void addActualArgument(Object handle, Object argument) {<br/>
        if (handle instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) handle).addActualArgument((MArgument) argument);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, argument);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Adds an annotated element to a comment.<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */<br/>
    public static void addAnnotatedElement(Object comment, <br/>
            Object annotatedElement) {<br/>
        if (comment instanceof MComment <br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        illegalArgument(comment, annotatedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method adds a classifier to a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */<br/>
    public static void addBase(Object handle, Object c) {<br/>
        if (handle instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) handle).addBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Classifier to an Instance<br/>
     * @param handle Instance<br/>
     * @param classifier Classifier<br/>
     */<br/>
    public static void addClassifier(Object handle, Object classifier) {<br/>
        if (handle instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) handle).addClassifier((MClassifier) classifier);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */<br/>
    public static void addClient(Object handle, Object element) {<br/>
        if (handle instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client dependency to some modelelement<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public static void addClientDependency(Object handle, Object dependency) {<br/>
        if (isAModelElement(handle)<br/>
                &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a TaggedValue to a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */<br/>
    public static void addTaggedValue(Object handle, Object taggedValue) {<br/>
        if (isAModelElement(handle) &amp;&amp; isATaggedValue(taggedValue)) {<br/>
            ((MModelElement) handle).addTaggedValue((MTaggedValue) taggedValue);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the actual Argument from an Action<br/>
     * @param handle Action<br/>
     * @param argument Argument<br/>
     */<br/>
    public static void removeActualArgument(Object handle, Object argument) {<br/>
        if (handle instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) handle).removeActualArgument((MArgument) argument);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, argument);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a classifier from a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */<br/>
    public static void removeBase(Object handle, Object c) {<br/>
        if (handle instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) handle).removeBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */<br/>
    public static void removeClientDependency(Object handle, Object dep) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) handle).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, dep);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given constraint from a given ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */<br/>
    public static void removeConstraint(Object handle, Object cons) {<br/>
        if (handle instanceof MModelElement &amp;&amp; cons instanceof MConstraint) {<br/>
            ((MModelElement) handle).removeConstraint((MConstraint) cons);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, cons);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given context (BehavioralFeature) from a Signal<br/>
     * @param handle Signal<br/>
     * @param context BehavioralFeature<br/>
     */<br/>
    public static void removeContext(Object handle, Object context) {<br/>
        if (handle instanceof MSignal<br/>
            &amp;&amp; context instanceof MBehavioralFeature) {<br/>
            ((MSignal) handle).removeContext((MBehavioralFeature) context);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, context);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method classifier from an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param classifier is the classifier<br/>
     */<br/>
    public static void removeClassifier(Object handle, Object classifier) {<br/>
        if (handle instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) handle).removeClassifier((MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param feature to remove<br/>
     */<br/>
    public static void removeFeature(Object handle, Object feature) {<br/>
        if (handle instanceof MClassifier<br/>
                &amp;&amp; feature instanceof MFeature) {<br/>
            ((MClassifier) handle).removeFeature((MFeature) feature);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, feature);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes an extension point from a use case.<br/>
     *<br/>
     * @param uc is the use case<br/>
     * @param ep is the extension point<br/>
     */<br/>
    public static void removeExtensionPoint(Object uc, Object ep) {<br/>
        if (uc instanceof MUseCase<br/>
                &amp;&amp; ep instanceof MExtensionPoint) {<br/>
            ((MUseCase) uc).removeExtensionPoint((MExtensionPoint) ep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(uc, ep);<br/>
    }<br/>
<br/>
    /**Removes a successor message<br/>
     * @param handle the Message that needs to loose a successor<br/>
     * @param mess the Message that is removed<br/>
     */<br/>
    public static void removeMessage3(Object handle, Object mess) {<br/>
        if (handle instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) handle).removeMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */<br/>
    public static void removeOwnedElement(Object handle, Object value) {<br/>
        if (handle instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) handle).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param p is the parameter<br/>
     */<br/>
    public static void removeParameter(Object handle, Object p) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; p instanceof MParameter) {<br/>
            ((MOperation) handle).removeParameter((MParameter) p);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, p);<br/>
    }<br/>
<br/>
    /** <br/>
     * Removes a predecessor message<br/>
     * @param handle the Message that needs to loose a predecessor<br/>
     * @param message the Message that is removed<br/>
     */<br/>
    public static void removePredecessor(Object handle, Object message) {<br/>
        if (handle instanceof MMessage &amp;&amp; message instanceof MMessage) {<br/>
            ((MMessage) handle).removePredecessor((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, message);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a given Reception from a given Signal<br/>
     * @param handle the Signal<br/>
     * @param reception the Reception<br/>
     */<br/>
    public static void removeReception(Object handle, Object reception) {<br/>
        if (handle instanceof MSignal &amp;&amp; reception instanceof MReception) {<br/>
            ((MSignal) handle).removeReception((MReception) reception);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, reception);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a given subvertex from a given composite state<br/>
     * @param handle the composite state<br/>
     * @param subvertex the StateVertex<br/>
     */<br/>
    public static void removeSubvertex(Object handle, Object subvertex) {<br/>
        if (handle instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) handle).removeSubvertex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertex);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */<br/>
    public static void removeTaggedValue(Object handle, String name) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    me.removeTaggedValue(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the base of some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param base is the base<br/>
     */<br/>
    public static void setBase(Object handle, Object base) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(base);<br/>
<br/>
        if (handle instanceof MAssociationRole<br/>
            &amp;&amp; base instanceof MAssociation) {<br/>
            ((MAssociationRole) handle).setBase((MAssociation) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MAssociationEndRole<br/>
            &amp;&amp; base instanceof MAssociationEnd) {<br/>
            ((MAssociationEndRole) handle).setBase((MAssociationEnd) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MExtend &amp;&amp; base instanceof MUseCase) {<br/>
            ((MExtend) handle).setBase((MUseCase) base);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MInclude &amp;&amp; base instanceof MUseCase) {<br/>
            ((MInclude) handle).setAddition((MUseCase) base);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, base);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the baseclass of some stereotype.<br/>
     *<br/>
     * @param handle the stereotype<br/>
     * @param baseClass the baseclass<br/>
     */<br/>
    public static void setBaseClass(Object handle, Object baseClass) {<br/>
        if (isAStereotype(handle) &amp;&amp; baseClass instanceof String) {<br/>
            ((MStereotype) handle).setBaseClass((String) baseClass);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, baseClass);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a body of a given Method, Constraint or Expression.<br/>
     *<br/>
     * @param handle is the method, expression<br/>
     * @param expr is the body string for the expression<br/>
     */<br/>
    public static void setBody(Object handle, Object expr) {<br/>
        if (handle instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) handle).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        if (handle instanceof MConstraint<br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)) {<br/>
            ((MConstraint) handle).setBody((MBooleanExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        /* TODO: MVW: The next part is fooling the user of setBody()<br/>
         * in thinking that the body of the object is changed.<br/>
         * Instead, a new object is created and as a side-effect <br/>
         * the language is lost.<br/>
         * Maybe we should just copy the language?<br/>
         */<br/>
        if (handle instanceof MExpression) {<br/>
            MExpressionEditor expressionEditor =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MExpressionEditor) UmlFactory.getFactory().getDataTypes()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .createExpressionEditor(handle);<br/>
            expressionEditor.setBody((String) expr);<br/>
            handle = (Object) expressionEditor.toExpression();<br/>
            // this last step creates a new MExpression<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the language of an expression.<br/>
     *<br/>
     * TODO: This operation is fooling the user<br/>
     * in thinking that the body of the object is changed.<br/>
     * Instead, a new object is created and as a side-effect the body is lost.<br/>
     * There is no other way: a MExpression can not be altered,<br/>
     * once created!<br/>
     * So, this operation should return the created object instead! <br/>
     * Or should it simply copy the body?<br/>
     *<br/>
     * @param handle is the expression<br/>
     * @param language is the lang<br/>
     */<br/>
    public static void setLanguage(Object handle, String language) {<br/>
        if (handle instanceof MExpression) {<br/>
            MExpression expression = (MExpression) handle;<br/>
            MExpressionEditor expressionEditor = (MExpressionEditor)<br/>
                UmlFactory.getFactory().getDataTypes().<br/>
                    createExpressionEditor(handle);<br/>
            expressionEditor.setLanguage(language);<br/>
            handle = expressionEditor.toExpression();<br/>
<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, language);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the language attribute of an Expression.<br/>
     *<br/>
     * @param handle is the Expression of which the language is retrieved<br/>
     * @return String the language<br/>
     */<br/>
    public static String getLanguage(Object handle) {<br/>
        if (handle instanceof MExpression) {<br/>
            return ((MExpression) handle).getLanguage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */<br/>
    public static void setDefaultValue(Object handle, Object expr) {<br/>
        if (handle instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) handle).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the guard of a transition.<br/>
     *<br/>
     * @param handle to the transition<br/>
     * @param guard to be set. Can be null.<br/>
     */<br/>
    public static void setGuard(Object handle, Object guard) {<br/>
        if (handle instanceof MTransition<br/>
                &amp;&amp; (guard == null || guard instanceof MGuard)) {<br/>
            ((MTransition) handle).setGuard((MGuard) guard);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, guard);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Transition of a guard or effect (Action).<br/>
     * @param handle the Guard or Action<br/>
     * @param trans the Transition<br/>
     */<br/>
    public static void setTransition(Object handle, Object trans) {<br/>
        if (trans instanceof MTransition) {<br/>
            if (handle instanceof MGuard) {<br/>
                ((MGuard) handle).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAction) {<br/>
                ((MAction) handle).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, trans);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the trigger event of a transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param event is the trigger event<br/>
     */<br/>
    public static void setTrigger(Object handle, Object event) {<br/>
        if (handle instanceof MTransition<br/>
                &amp;&amp; (event == null || event instanceof MEvent)) {<br/>
            ((MTransition) handle).setTrigger((MEvent) event);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, event);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the icon for a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param icon String<br/>
     */<br/>
    public static void setIcon(Object handle, Object icon) {<br/>
        if (handle instanceof MStereotype<br/>
                &amp;&amp; (icon == null || icon instanceof String)) {<br/>
            ((MStereotype) handle).setIcon((String) icon);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, icon);<br/>
    }<br/>
<br/>
    /** Set the ImplementationLocation of the given ElementResidence <br/>
     * to the given Component.<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     */<br/>
    public static void setImplementationLocation(<br/>
        Object handle,<br/>
        Object component) {<br/>
        if (handle instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) handle).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of Include relationships for a usecase<br/>
     * @param handle UseCase<br/>
     * @param includes the collection of Include relationships <br/>
     */<br/>
    public static void setIncludes(Object handle, Collection includes) {<br/>
        if (handle instanceof MUseCase) {<br/>
            ((MUseCase) handle).setIncludes(includes);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, includes);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setInitialValue(Object at, Object expr) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(at, expr);<br/>
    }<br/>
<br/>
    /** Sets the given Instance to the given LinkEnd or AttributeLink<br/>
     * @param handle LinkEnd or AttributeLink<br/>
     * @param inst null or Instance<br/>
     */<br/>
    public static void setInstance(Object handle, Object inst) {<br/>
        if (inst == null || inst instanceof MInstance) {<br/>
            if (handle instanceof MLinkEnd) {<br/>
                ((MLinkEnd) handle).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAttributeLink) {<br/>
                ((MAttributeLink) handle).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, inst);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle is the target.<br/>
     * @param intTrans is a collection of transitions.<br/>
     */<br/>
    public static void setInternalTransitions(<br/>
        Object handle,<br/>
        Collection intTrans) {<br/>
        if (handle instanceof MState) {<br/>
            ((MState) handle).setInternalTransitions(intTrans);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Message<br/>
     * @param messages Collection of predecessor messages<br/>
     */<br/>
    public static void setMessages3(Object handle, Collection messages) {<br/>
        if (handle instanceof MMessage) {<br/>
            ((MMessage) handle).setMessages3(messages);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a location of some extension point.<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @param loc is the location<br/>
     */<br/>
    public static void setLocation(Object handle, String loc) {<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            ((MExtensionPoint) handle).setLocation(loc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * &lt;p&gt;Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/b&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/b&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;/p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */<br/>
    public static void setModelElementContainer(<br/>
        Object handle,<br/>
        Object container) {<br/>
        if (handle instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) handle).setActivityGraph((MActivityGraph) container);<br/>
        } else if (handle instanceof MModelElement <br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) handle);<br/>
        } else if (<br/>
            handle instanceof MConstraint<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            MConstraint c = (MConstraint) handle;<br/>
            c.setConstrainedElement2((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) handle).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            handle instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) handle;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) handle).setInstance((MInstance) container);<br/>
        } else if (<br/>
            handle instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) handle).setInteraction((MInteraction) container);<br/>
        } else if (handle instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) handle).setLink((MLink) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) handle).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) handle).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) handle).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            handle instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) handle).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            handle instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) handle).setPackage((MPackage) container);<br/>
        } else if (<br/>
            handle instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) container);<br/>
        } else if (<br/>
            handle instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) container);<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    illegalArgument(handle, container);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */<br/>
    public static void setMultiplicity(Object handle, Object arg) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg instanceof MMultiplicity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MAssociationRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationRole) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MClassifierRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierRole) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) handle).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, arg);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the classifiers of some instance.<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param v is the classifier vector<br/>
     */<br/>
    public static void setClassifiers(Object handle, Vector v) {<br/>
        if (handle instanceof MInstance) {<br/>
            ((MInstance) handle).setClassifiers(v);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */<br/>
    public static void setName(Object handle, String name) {<br/>
        if ((handle instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            ((MModelElement) handle).setName(name);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, name);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setNamespace(Object handle, Object ns) {<br/>
        if (handle instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ns);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */<br/>
    public static void setNavigable(Object handle, boolean flag) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /** Set the value of a given object<br/>
     * <br/>
     * @param handle the Object of which the value will be set<br/>
     * @param value Object <br/>
     */<br/>
    public static void setValue(Object handle, Object value) {<br/>
        if (handle instanceof MArgument) {<br/>
            ((MArgument) handle).setValue((MExpression) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MAttributeLink) {<br/>
            ((MAttributeLink) handle).setValue((MInstance) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MExtension) {<br/>
            ((MExtension) handle).setValue(value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTaggedValue) {<br/>
            ((MTaggedValue) handle).setValue((String) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */<br/>
    public static void setVisibility(Object handle, Object visibility) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (handle instanceof MModelElement) {<br/>
                ((MModelElement) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MElementResidence) {<br/>
                ((MElementResidence) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (handle instanceof MElementImport) {<br/>
                ((MElementImport) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, visibility);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param v is the visibility<br/>
     */<br/>
    public static void setVisibility(Object handle, short v) {<br/>
        if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) handle;<br/>
<br/>
            if (v == ACC_PRIVATE) {<br/>
                me.setVisibility(MVisibilityKind.PRIVATE);<br/>
            } else if (v == ACC_PROTECTED) {<br/>
                me.setVisibility(MVisibilityKind.PROTECTED);<br/>
            } else if (v == ACC_PUBLIC) {<br/>
                me.setVisibility(MVisibilityKind.PUBLIC);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the NodeInstance of a ComponentInstance<br/>
     * @param handle ComponentInstance<br/>
     * @param nodeInstance NodeInstance<br/>
     */<br/>
    public static void setNodeInstance(Object handle, Object nodeInstance) {<br/>
        if (handle instanceof MComponentInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; nodeInstance instanceof MNodeInstance) {<br/>
            ((MComponentInstance) handle).setNodeInstance(<br/>
                (MNodeInstance) nodeInstance);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, nodeInstance);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner of a Feature<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */<br/>
    public static void setOwner(Object handle, Object owner) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) handle).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, owner);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Operation of a CallAction or CallEvent<br/>
     * @param handle CallAction or CallEvent<br/>
     * @param operation Operation<br/>
     */<br/>
    public static void setOperation(Object handle, Object operation) {<br/>
        if (handle instanceof MCallAction) {<br/>
            ((MCallAction) handle).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MCallEvent) {<br/>
            ((MCallEvent) handle).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, operation);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the OrderingKind of a given AssociationEnd <br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */<br/>
    public static void setOrdering(Object handle, Object ok) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) handle).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ok);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner scope of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param os is the owner scope<br/>
     */<br/>
    public static void setOwnerScope(Object handle, short os) {<br/>
        if (handle instanceof MFeature) {<br/>
            if (os == CLASSIFIER_SCOPE) {<br/>
                ((MFeature) handle).setOwnerScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (os == INSTANCE_SCOPE) {<br/>
                ((MFeature) handle).setOwnerScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */<br/>
    public static void setOwnerScope(Object handle, Object os) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) handle).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, os);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param parameters is a Collection of extensionPoints<br/>
     */<br/>
    public static void setParameters(Object handle, Collection parameters) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            ((MClassifier) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parameters);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the target of some action or transition.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param element the target of the model elemnet<br/>
     */<br/>
    public static void setTarget(Object handle, Object element) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; element instanceof MObjectSetExpression) {<br/>
            ((MAction) handle).setTarget((MObjectSetExpression) element);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; element instanceof MStateVertex) {<br/>
            ((MTransition) handle).setTarget((MStateVertex) element);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, element);<br/>
    }<br/>
    /**<br/>
     * Sets the state of an internal transition.<br/>
     *<br/>
     * @param handle the internal transition<br/>
     * @param element the state that contains this transition<br/>
     */<br/>
    public static void setState(Object handle, Object element) {<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; element instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */<br/>
    public static void setTargetScope(Object handle, Object scopeKind) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, scopeKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param ts is the target scope<br/>
     */<br/>
    public static void setTargetScope(Object handle, short ts) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd ae = (MAssociationEnd) handle;<br/>
<br/>
            if (ts == CLASSIFIER_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (ts == INSTANCE_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Instance<br/>
     * @param c ComponentInstance or null<br/>
     */<br/>
    public static void setComponentInstance(Object handle, Object c) {<br/>
        if (handle instanceof MInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; (c == null || c instanceof MComponentInstance)) {<br/>
            ((MInstance) handle).setComponentInstance((MComponentInstance) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the communicationLink between a link c and a stimulus handle.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param c the link<br/>
     */<br/>
    public static void setCommunicationLink(Object handle, Object c) {<br/>
        if (handle instanceof MStimulus &amp;&amp; c instanceof MLink) {<br/>
            ((MStimulus) handle).setCommunicationLink((MLink) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, c);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param c is the concurrency<br/>
     */<br/>
    public static void setConcurrency(Object handle, short c) {<br/>
        if (handle instanceof MOperation) {<br/>
            MOperation oper = (MOperation) handle;<br/>
<br/>
            if (c == GUARDED) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.GUARDED);<br/>
                return;<br/>
            } else if (c == SEQUENTIAL) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.SEQUENTIAL);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */<br/>
    public static void setConcurrency(<br/>
        Object handle,<br/>
        Object concurrencyKind) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) handle).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, concurrencyKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a Composite State concurrent<br/>
     * @param handle the CompositState<br/>
     * @param concurrent boolean<br/>
     */<br/>
    public static void setConcurent(Object handle, boolean concurrent) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            ((MCompositeState) handle).setConcurent(concurrent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the condition of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @param booleanExpression is the condition<br/>
     */<br/>
    public static void setCondition(Object handle, Object booleanExpression) {<br/>
        if (handle instanceof MExtend<br/>
            &amp;&amp; booleanExpression instanceof MBooleanExpression) {<br/>
            ((MExtend) handle).setCondition(<br/>
                (MBooleanExpression) booleanExpression);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, booleanExpression);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the container of a statevertex.<br/>
     *<br/>
     * @param handle is the stateVertex<br/>
     * @param compositeState is the container. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setContainer(Object handle, Object compositeState) {<br/>
        if (handle instanceof MStateVertex<br/>
            &amp;&amp; (compositeState == null<br/>
                || compositeState instanceof MCompositeState)) {<br/>
            ((MStateVertex) handle).setContainer(<br/>
                (MCompositeState) compositeState);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, compositeState);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the contexts for a Signal<br/>
     * @param handle the Signal<br/>
     * @param c the collection of contexts<br/>
     */<br/>
    public static void setContexts(Object handle, Collection c) {<br/>
        if (handle instanceof MSignal) {<br/>
            ((MSignal) handle).setContexts(c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the dispatch action for some stimulus.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param value the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setDispatchAction(Object handle, Object value) {<br/>
        if (handle instanceof MStimulus<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MStimulus) handle).setDispatchAction((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the do activity of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value the activity. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setDoActivity(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setDoActivity((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param value is the effect. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setEffect(Object handle, Object value) {<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MTransition) handle).setEffect((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the entry action of some state.<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setEntry(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setEntry((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the exit action of some state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */<br/>
    public static void setExit(Object handle, Object value) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) handle).setExit((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**Set the Expression of a Guard or ChangeEvent<br/>
     * @param handle Guard or ChangeEvent<br/>
     * @param value BooleanExpression or null<br/>
     */<br/>
    public static void setExpression(Object handle, Object value) {<br/>
        if (handle instanceof MGuard<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
            ((MGuard) handle).setExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MChangeEvent<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeEvent ce = (MChangeEvent) handle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ce.setChangeExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the time-expression for a TimeEvent. <br/>
     * @param handle Object (MTimeEvent)<br/>
     * @param value Object (MTimeExpression)<br/>
     */<br/>
    public static void setWhen(Object handle, Object value) {<br/>
        if (handle instanceof MTimeEvent<br/>
            &amp;&amp; (value == null || value instanceof MTimeExpression)) {<br/>
            ((MTimeEvent) handle).setWhen((MTimeExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle, value);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the extension of a usecase<br/>
     * @param handle Extend<br/>
     * @param ext UseCase or null<br/>
     */<br/>
    public static void setExtension(Object handle, Object ext) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(ext);<br/>
<br/>
        if (handle instanceof MExtend<br/>
            &amp;&amp; (ext == null || ext instanceof MUseCase)) {<br/>
            ((MExtend) handle).setExtension((MUseCase) ext);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ext);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param extensionPoints is the extension points<br/>
     */<br/>
    public static void setExtensionPoints(<br/>
        Object handle,<br/>
        Collection extensionPoints) {<br/>
        if (handle instanceof MUseCase &amp;&amp; extensionPoints instanceof List) {<br/>
            ((MUseCase) handle).setExtensionPoints(extensionPoints);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extensionPoints);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the list of features<br/>
     */<br/>
    public static void setFeatures(Object handle, Collection features) {<br/>
        if (handle instanceof MClassifier<br/>
            &amp;&amp; features instanceof List) {<br/>
            ((MClassifier) handle).setFeatures((List) features);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */<br/>
    public static void setAggregation(Object handle, Object aggregationKind) {<br/>
        if (handle instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) handle).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, aggregationKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */<br/>
    public static void setAssociation(Object handle, Object association) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, association);<br/>
    }<br/>
<br/>
    /**Set the Changeability of a StructuralFeature or AssociationEnd<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */<br/>
    public static void setChangeability(Object handle, Object ck) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, ck);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */<br/>
    public static void setChangeable(Object handle, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            }<br/>
            else {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
            }<br/>
        } else if (handle instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) handle;<br/>
            if (flag)<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            else<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**Set the child for a generalization<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */<br/>
    public static void setChild(Object handle, Object child) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, child);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if of some model element is abstract.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */<br/>
    public static void setAbstract(Object handle, boolean flag) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MGeneralizableElement) handle).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MOperation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MOperation) handle).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MReception) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MReception) handle).setAbstarct(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the addition to an include.<br/>
     * There is a bug in NSUML that reverses additions and bases for includes.<br/>
     * @param handle Include <br/>
     * @param useCase UseCase<br/>
     */<br/>
    public static void setAddition(Object handle, Object useCase) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(handle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(useCase);<br/>
<br/>
        if (handle instanceof MInclude) {<br/>
            ((MInclude) handle).setBase((MUseCase) useCase);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the action to a message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @param action is the action<br/>
     */<br/>
    public static void setAction(Object handle, Object action) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; (action == null || action instanceof MAction)) {<br/>
            ((MMessage) handle).setAction((MAction) action);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, action);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Activator message of an message<br/>
     * @param handle Message<br/>
     * @param message Message<br/>
     */<br/>
    public static void setActivator(Object handle, Object message) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; (message == null || message instanceof MMessage)) {<br/>
            ((MMessage) handle).setActivator((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, message);<br/>
    }<br/>
<br/>
    /**Makes a Class active<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */<br/>
    public static void setActive(Object handle, boolean active) {<br/>
        if (handle instanceof MClass) {<br/>
            ((MClass) handle).setActive(active);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the asynchronous property of an action.<br/>
     *<br/>
     * @param handle the action<br/>
     * @param value the value to alter the asynchronous property to<br/>
     */<br/>
    public static void setAsynchronous(Object handle, boolean value) {<br/>
        if (handle instanceof MAction) {<br/>
            ((MAction) handle).setAsynchronous(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */<br/>
    public static void setLeaf(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */<br/>
    public static void setRaisedSignals(<br/>
        Object handle,<br/>
        Collection raisedSignals) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the receiver of some model element.<br/>
     * @param handle model element<br/>
     * @param receiver the receiver<br/>
     */<br/>
    public static void setReceiver(Object handle, Object receiver) {<br/>
        if (handle instanceof MMessage<br/>
            &amp;&amp; receiver instanceof MClassifierRole) {<br/>
            ((MMessage) handle).setReceiver((MClassifierRole) receiver);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MStimulus &amp;&amp; receiver instanceof MInstance) {<br/>
            ((MStimulus) handle).setReceiver((MInstance) receiver);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, receiver);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the recurrence of an Action<br/>
     * @param handle Action<br/>
     * @param expr IterationExpression<br/>
     */<br/>
    public static void setRecurrence(Object handle, Object expr) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; expr instanceof MIterationExpression) {<br/>
            ((MAction) handle).setRecurrence((MIterationExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the represented classifier of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param classifier is the classifier<br/>
     */<br/>
    public static void setRepresentedClassifier(<br/>
        Object handle,<br/>
        Object classifier) {<br/>
        if (handle instanceof MCollaboration<br/>
            &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MCollaboration) handle).setRepresentedClassifier(<br/>
                (MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, classifier);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the represented operation of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param operation is the operation<br/>
     */<br/>
    public static void setRepresentedOperation(<br/>
        Object handle,<br/>
        Object operation) {<br/>
        if (handle instanceof MCollaboration<br/>
            &amp;&amp; operation instanceof MOperation) {<br/>
            ((MCollaboration) handle).setRepresentedOperation(<br/>
                (MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, operation);<br/>
    }<br/>
<br/>
    /**<br/>
     * <br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */<br/>
    public static void setResident(Object handle, Object resident) {<br/>
        if (handle instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) handle).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, resident);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */<br/>
    public static void setResidents(Object handle, Collection residents) {<br/>
        if (handle instanceof MNodeInstance) {<br/>
            ((MNodeInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MComponentInstance) {<br/>
            ((MComponentInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MNode) {<br/>
            ((MNode) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */<br/>
    public static void setRoot(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Expression (script) for an Action<br/>
     * @param handle Action<br/>
     * @param expr the script (ActionExpression)<br/>
     */<br/>
    public static void setScript(Object handle, Object expr) {<br/>
        if (handle instanceof MAction<br/>
            &amp;&amp; (expr == null || expr instanceof MActionExpression)) {<br/>
            ((MAction) handle).setScript((MActionExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the sender of some model element.&lt;p&gt;<br/>
     *<br/>
     * @param handle model element<br/>
     * @param sender the sender<br/>
     */<br/>
    public static void setSender(Object handle, Object sender) {<br/>
        if (handle instanceof MMessage &amp;&amp; sender instanceof MClassifierRole) {<br/>
            ((MMessage) handle).setSender((MClassifierRole) sender);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MStimulus &amp;&amp; sender instanceof MInstance) {<br/>
            ((MStimulus) handle).setSender((MInstance) sender);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, sender);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Signal<br/>
     * @param handle SendAction or Reception or SignalEvent<br/>
     * @param signal Signal or null<br/>
     */<br/>
    public static void setSignal(Object handle, Object signal) {<br/>
        if (signal == null || signal instanceof MSignal) {<br/>
            if (handle instanceof MSendAction) {<br/>
                ((MSendAction) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MReception) {<br/>
                ((MReception) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MSignalEvent) {<br/>
                ((MSignalEvent) handle).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, signal);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the source state of some message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param state the source state<br/>
     */<br/>
    public static void setSource(Object handle, Object state) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle instanceof MTransition &amp;&amp; state instanceof MStateVertex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MTransition) handle).setSource((MStateVertex) state);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, state);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */<br/>
    public static void setSources(Object handle, Collection specifications) {<br/>
        if (handle instanceof MFlow) {<br/>
            ((MFlow) handle).setSources(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * <br/>
     * @param handle a reception<br/>
     * @param specification the specification<br/>
     */<br/>
    public static void setSpecification(Object handle, String specification) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
        illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Specification flag for a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */<br/>
    public static void setSpecification(Object handle, boolean specification) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */<br/>
    public static void setSpecifications(<br/>
        Object handle,<br/>
        Collection specifications) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */<br/>
    public static void setKind(Object handle, Object kind) {<br/>
        if (handle instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) handle).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) handle).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, kind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToIn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.IN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToInOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.INOUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.OUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public static void setKindToReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) handle).setKind(MParameterDirectionKind.RETURN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */<br/>
    public static void setParent(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) handle).setParent(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Generalization <br/>
     * @param pt Classifier<br/>
     */<br/>
    public static void setPowertype(Object handle, Object pt) {<br/>
        if (handle instanceof MGeneralization &amp;&amp; pt instanceof MClassifier) {<br/>
            ((MGeneralization) handle).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, pt);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of predecessing messages<br/>
     * @param handle Message<br/>
     * @param predecessors Collection of Messages<br/>
     */<br/>
    public static void setPredecessors(<br/>
        Object handle,<br/>
        Collection predecessors) {<br/>
        if (handle instanceof MMessage) {<br/>
            ((MMessage) handle).setPredecessors(predecessors);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, predecessors);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */<br/>
    public static void setQuery(Object handle, boolean flag) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setQuery(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */<br/>
    public static void setType(Object handle, Object type) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MObjectFlowState) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MClassifierInState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierInState) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MParameter) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) handle).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, type);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the UUID of this element<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */<br/>
    public static void setUUID(Object handle, String uuid) {<br/>
        if (isABase(handle)) {<br/>
            ((MBase) handle).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Tag of a TaggedValue <br/>
     * @param handle TaggedValue<br/>
     * @param tag String<br/>
     */<br/>
    public static void setTag(Object handle, Object tag) {<br/>
        if (handle instanceof MTaggedValue &amp;&amp; tag instanceof String) {<br/>
            ((MTaggedValue) handle).setTag((String) tag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, tag);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */<br/>
    public static void setTaggedValue(<br/>
        Object handle,<br/>
        String tag,<br/>
        String value) {<br/>
        if (handle instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MModelElement) handle).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the TaggedValues of a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */<br/>
    public static void setTaggedValues(<br/>
        Object handle,<br/>
        Collection taggedValues) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a value of some taggedValue.<br/>
     *<br/>
     * @param handle is the tagged value<br/>
     * @param value is the value<br/>
     */<br/>
    public static void setValueOfTag(Object handle, String value) {<br/>
        if (handle instanceof MTaggedValue) {<br/>
            ((MTaggedValue) handle).setValue(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a state machine of some state or transition.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @param stm is the state machine<br/>
     */<br/>
    public static void setStateMachine(Object handle, Object stm) {<br/>
        if (handle instanceof MState<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MTransition<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stm);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * &lt;p&gt;TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */<br/>
    public static void setStereotype(Object handle, Object stereo) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            if (stereo instanceof MStereotype<br/>
                &amp;&amp; me.getModel() != ((MStereotype) stereo).getModel()) {<br/>
                ((MStereotype) stereo).setNamespace(me.getModel());<br/>
            }<br/>
            if (stereo == null || stereo instanceof MStereotype) {<br/>
                me.setStereotype((MStereotype) stereo);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, stereo);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the collection of substates for a CompositeState<br/>
     * @param handle CompositeState<br/>
     * @param subvertices collection of sub-StateVertexes<br/>
     */<br/>
    public static void setSubvertices(Object handle, Collection subvertices) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            ((MCompositeState) handle).setSubvertices(subvertices);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, subvertices);<br/>
    }<br/>
<br/>
    /** Add an End to a connection<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */<br/>
    public static void addConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) handle).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) handle).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, connection);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */<br/>
    public static void addConstraint(Object handle, Object mc) {<br/>
        if (handle instanceof MModelElement &amp;&amp; mc instanceof MConstraint) {<br/>
            ((MModelElement) handle).addConstraint((MConstraint) mc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, mc);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public static void addDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, node);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add an extended element to a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param extendedElement ExtensionPoint<br/>
     */<br/>
    public static void addExtendedElement(<br/>
        Object handle,<br/>
        Object extendedElement) {<br/>
        if (handle instanceof MStereotype<br/>
            &amp;&amp; extendedElement instanceof MExtensionPoint) {<br/>
            ((MStereotype) handle).addExtendedElement(<br/>
                (MModelElement) extendedElement);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extendedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an extension point to some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param extensionPoint is the extension point<br/>
     */<br/>
    public static void addExtensionPoint(<br/>
        Object handle,<br/>
        Object extensionPoint) {<br/>
        if (extensionPoint instanceof MExtensionPoint) {<br/>
            if (handle instanceof MUseCase) {<br/>
                ((MUseCase) handle).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MExtend) {<br/>
                ((MExtend) handle).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(handle, extensionPoint);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the name of the UML Model class, e.g. it it will return<br/>
     * Class for an object of type MClass.<br/>
     *<br/>
     * @param handle MBase<br/>
     * @return classname of modelelement<br/>
     */<br/>
    public static String getUMLClassName(Object handle) {<br/>
        if (handle instanceof MBase) {<br/>
            return ((MBase) handle).getUMLClassName();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(handle);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Convenience methods<br/>
<br/>
    /**<br/>
     * Tests if an element is marked removed.<br/>
     *<br/>
     * &lt;p&gt;Model specific: NSUML is littered with calls to a function also<br/>
     * named checkExists. That function is however a NOP (it is empty in<br/>
     * MBaseImpl, and it is final so it cannot be overridden anywhere).<br/>
     *<br/>
     * @param obj the element to test.<br/>
     * @throws IllegalStateException iff obj is marked removed.<br/>
     */<br/>
    private static void checkExists(Object obj) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((obj instanceof MBase) &amp;&amp; ((MBase) obj).isRemoved()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalStateException("Operation on a removed object ["<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    + obj + "]");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * The empty set.<br/>
     *<br/>
     * @return an empty collection.<br/>
     */<br/>
    private static Collection emptyCollection() {<br/>
        return Collections.EMPTY_LIST;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get a string representation of the class type. <br/>
     * Purpose: documenting an exception<br/>
     * @param handle the Class or null<br/>
     * @return String <br/>
     */<br/>
    protected static String getClassNull(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (handle == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[null]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[" + handle + "/" + handle.getClass() + "]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     */<br/>
    private static void illegalArgument(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg));<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return a boolean for use in the return statement.<br/>
     */<br/>
    private static boolean illegalArgumentBoolean(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Object for use in the return statement.<br/>
     */<br/>
    private static Object illegalArgumentObject(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Collection for use in the return statement.<br/>
     */<br/>
    private static Collection illegalArgumentCollection(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return String for use in the return statement.<br/>
     */<br/>
    private static String illegalArgumentString(Object arg) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     */<br/>
    private static Object illegalArgument(Object arg1, Object arg2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg1) + " or "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg2));<br/>
    }<br/>
<br/>
    /**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     * @return Object for use in the return statement.<br/>
     */<br/>
    private static Object illegalArgumentObject(Object arg1, Object arg2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg1, arg2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>