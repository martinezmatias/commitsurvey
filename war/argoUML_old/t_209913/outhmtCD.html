<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_ModelFacade_1.209.java</h1>
<div class="code">
<div class="id">
// $Id: ModelFacade.java,v 1.209 2004-08-26 23:03:17 bobtarling Exp $<br/>
// Copyright (c) 2003-2004 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.Collections;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.argouml.model.uml.UmlFactory;<br/>
import org.argouml.model.uml.foundation.core.CoreHelper;<br/>
import org.argouml.model.uml.foundation.extensionmechanisms.ExtensionMechanismsHelper;<br/>
import org.argouml.uml.diagram.static_structure.ui.CommentEdge;<br/>
import org.tigris.gef.base.Diagram;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.MElementListener;<br/>
import ru.novosoft.uml.MExtension;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActionState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MCallState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MSubactivityState;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MActionSequence;<br/>
import ru.novosoft.uml.behavior.common_behavior.MArgument;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCallAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCreateAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDataValue;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDestroyAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MException;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MObject;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReturnAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSendAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.common_behavior.MStimulus;<br/>
import ru.novosoft.uml.behavior.common_behavior.MTerminateAction;<br/>
import ru.novosoft.uml.behavior.state_machines.MCallEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MChangeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MFinalState;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MSignalEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateImpl;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MSubmachineState;<br/>
import ru.novosoft.uml.behavior.state_machines.MTimeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtensionPoint;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationClass;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElement;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MPermission;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.core.MUsage;<br/>
import ru.novosoft.uml.foundation.data_types.MActionExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MExpressionEditor;<br/>
import ru.novosoft.uml.foundation.data_types.MIterationExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMessageDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicityRange;<br/>
import ru.novosoft.uml.foundation.data_types.MObjectSetExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MOperationDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MTimeExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MModel;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
import ru.novosoft.uml.model_management.MSubsystem;<br/>
<br/>
/**<br/>
 * Facade object for the Model component in ArgoUML.&lt;p&gt;<br/>
 *<br/>
 * The purpose of this Facade object is to allow for decoupling other modules<br/>
 * from the insides of the model. For this purpose all of the methods in this<br/>
 * class give away and accept handles (of type java.lang.Object) to the<br/>
 * objects within the model.&lt;p&gt;<br/>
 *<br/>
 * This is just getters and recognizers. This is because the Model<br/>
 * component has an extremely complicated internal data structure<br/>
 * with lots of internal dependencies. To manipulate these there is<br/>
 * a whole set of factories and helpers within the Model that is to<br/>
 * be used but to use them you need knowledge of the internals of<br/>
 * the Model, specifically the NS-UML objects.&lt;p&gt;<br/>
 *<br/>
 * All methods in this facade are static.&lt;p&gt;<br/>
 *<br/>
 * Signature for all recognizers in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static boolean isA&lt;TYPE&gt;(Object handle)<br/>
 * &lt;li&gt;public static boolean is&lt;PROPERTY&gt;(Object handle)<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * Signature for all getters in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static Object get&lt;TYPE&gt;(Object handle) - 1..1<br/>
 * &lt;li&gt;public static Iterator get&lt;TYPES&gt;(Object handle) - 0..*<br/>
 * &lt;li&gt;public static String getName(Object handle) - Name<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * @stereotype utility<br/>
 * @author Linus Tolke<br/>
 */<br/>
public class ModelFacade {<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // constants<br/>
<br/>
    // TODO: deprecate all of these constants in favor of a separate declaration<br/>
<br/>
    public static final short ACC_PUBLIC = 1;<br/>
    public static final short ACC_PRIVATE = 2;<br/>
    public static final short ACC_PROTECTED = 3;<br/>
<br/>
    public static final short CLASSIFIER_SCOPE = 1;<br/>
    public static final short INSTANCE_SCOPE = 2;<br/>
<br/>
    public static final short GUARDED = 1;<br/>
    public static final short SEQUENTIAL = 2;<br/>
<br/>
    // Types of line<br/>
    public static final Object ABSTRACTION = MAbstraction.class;<br/>
    public static final Object ASSOCIATION = MAssociation.class;<br/>
    public static final Object ASSOCIATION_CLASS = MAssociationClass.class;<br/>
    public static final Object ASSOCIATION_ROLE = MAssociationRole.class;<br/>
    public static final Object COLLABORATION = MCollaboration.class;<br/>
    public static final Object DEPENDENCY = MDependency.class;<br/>
    public static final Object EXTEND = MExtend.class;<br/>
    public static final Object GENERALIZATION = MGeneralization.class;<br/>
    public static final Object INCLUDE = MInclude.class;<br/>
    public static final Object LINK = MLink.class;<br/>
    public static final Object MESSAGE = MMessage.class;<br/>
    public static final Object PERMISSION = MPermission.class;<br/>
    public static final Object SIGNAL = MSignal.class;<br/>
    public static final Object USAGE = MUsage.class;<br/>
    public static final Object TRANSITION = MTransition.class;<br/>
<br/>
    // Types of node<br/>
    public static final Object ACTOR = MActor.class;<br/>
    public static final Object CLASS = MClass.class;<br/>
    public static final Object CLASSIFIER = MClassifier.class;<br/>
    public static final Object CLASSIFIER_ROLE = MClassifierRole.class;<br/>
    public static final Object COMMENT = MComment.class;<br/>
    public static final Object COMPONENT = MComponent.class;<br/>
    public static final Object COMPONENT_INSTANCE = MComponentInstance.class;<br/>
    public static final Object EXCEPTION = MException.class;<br/>
    public static final Object INSTANCE = MInstance.class;<br/>
    public static final Object INTERFACE = MInterface.class;<br/>
    public static final Object NODE = MNode.class;<br/>
    public static final Object NODE_INSTANCE = MNodeInstance.class;<br/>
    public static final Object OBJECT = MObject.class;<br/>
    public static final Object PACKAGE = MPackage.class;<br/>
    public static final Object MODEL = MModel.class;<br/>
    public static final Object SUBSYSTEM = MSubsystem.class;<br/>
    public static final Object STATE = MState.class;<br/>
    public static final Object STATEIMPL = MStateImpl.class;<br/>
    public static final Object COMPOSITESTATE = MCompositeState.class;<br/>
    public static final Object STATEVERTEX = MStateVertex.class;<br/>
    public static final Object PSEUDOSTATE = MPseudostate.class;<br/>
    public static final Object FINALSTATE = MFinalState.class;<br/>
    public static final Object USE_CASE = MUseCase.class;<br/>
    public static final Object CALLSTATE = MCallState.class;<br/>
    public static final Object OBJECTFLOWSTATE = MObjectFlowState.class;<br/>
    public static final Object SUBACTIVITYSTATE = MSubactivityState.class;<br/>
<br/>
    // Invisible model elements<br/>
    public static final Object ACTION = MAction.class;<br/>
    public static final Object ACTION_EXPRESSION = MActionExpression.class;<br/>
    public static final Object ACTION_STATE = MActionState.class;<br/>
    public static final Object ASSOCIATION_END = MAssociationEnd.class;<br/>
    public static final Object ASSOCIATION_END_ROLE = MAssociationEndRole.class;<br/>
    public static final Object CALL_ACTION = MCallAction.class;<br/>
    public static final Object CALLCONCURRENCYKIND = MCallConcurrencyKind.class;<br/>
    public static final Object CREATE_ACTION = MCreateAction.class;<br/>
    public static final Object DESTROY_ACTION = MDestroyAction.class;<br/>
    public static final Object TERMINATE_ACTION = MTerminateAction.class;<br/>
    public static final Object NAMESPACE = MNamespace.class;<br/>
    public static final Object RECEPTION = MReception.class;<br/>
    public static final Object RETURN_ACTION = MReturnAction.class;<br/>
    public static final Object SCOPEKIND = MScopeKind.class;<br/>
    public static final Object SEND_ACTION = MSendAction.class;<br/>
    public static final Object STEREOTYPE = MStereotype.class;<br/>
    public static final Object PARTITION = MPartition.class;<br/>
    public static final Object PARAMETER = MParameter.class;<br/>
    public static final Object PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.class;<br/>
    public static final Object GENERALAIZABLE_ELEMENT =<br/>
        MGeneralizableElement.class;<br/>
    public static final Object DATATYPE = MDataType.class;<br/>
    public static final Object STATEMACHINE = MStateMachine.class;<br/>
<br/>
    public static final Object ATTRIBUTE = MAttribute.class;<br/>
    public static final Object OPERATION = MOperation.class;<br/>
<br/>
    public static final Object MULTIPLICITY = MMultiplicity.class;<br/>
<br/>
    public static final Object VISIBILITYKIND = MVisibilityKind.class;<br/>
<br/>
    public static final Object MODELELEMENT = MModelElement.class;<br/>
    public static final Object STIMULUS = MStimulus.class;<br/>
<br/>
    public static final Object AGGREGATIONKIND = MAggregationKind.class;<br/>
    public static final Object BOOLEAN_EXPRESSION = MBooleanExpression.class;<br/>
    public static final Object GUARD = MGuard.class;<br/>
    public static final Object EVENT = MEvent.class;<br/>
<br/>
    public static final Object ADD_ONLY_CHANGEABLEKIND =<br/>
        MChangeableKind.ADD_ONLY;<br/>
    public static final Object CHANGEABLE_CHANGEABLEKIND =<br/>
        MChangeableKind.CHANGEABLE;<br/>
    public static final Object FROZEN_CHANGEABLEKIND = MChangeableKind.FROZEN;<br/>
<br/>
    public static final Object CONCURRENT_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.CONCURRENT;<br/>
<br/>
    public static final Object GUARDED_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.GUARDED;<br/>
<br/>
    public static final Object SEQUENTIAL_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.SEQUENTIAL;<br/>
<br/>
    public static final Object PSEUDOSTATEKIND = MPseudostateKind.class;<br/>
    public static final Object INITIAL_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.INITIAL;<br/>
    public static final Object DEEPHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.DEEP_HISTORY;<br/>
    public static final Object SHALLOWHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.SHALLOW_HISTORY;<br/>
    public static final Object FORK_PSEUDOSTATEKIND = MPseudostateKind.FORK;<br/>
    public static final Object JOIN_PSEUDOSTATEKIND = MPseudostateKind.JOIN;<br/>
    public static final Object JUNCTION_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.JUNCTION;<br/>
    public static final Object BRANCH_PSEUDOSTATEKIND = MPseudostateKind.BRANCH;<br/>
<br/>
    public static final Object PUBLIC_VISIBILITYKIND = MVisibilityKind.PUBLIC;<br/>
    public static final Object PRIVATE_VISIBILITYKIND = MVisibilityKind.PRIVATE;<br/>
    public static final Object PROTECTED_VISIBILITYKIND =<br/>
        MVisibilityKind.PROTECTED;<br/>
<br/>
    public static final Object AGGREGATE_AGGREGATIONKIND =<br/>
        MAggregationKind.AGGREGATE;<br/>
    public static final Object COMPOSITE_AGGREGATIONKIND =<br/>
        MAggregationKind.COMPOSITE;<br/>
    public static final Object NONE_AGGREGATIONKIND = MAggregationKind.NONE;<br/>
<br/>
    public static final Object ORDERED_ORDERINGKIND = MOrderingKind.ORDERED;<br/>
    public static final Object UNORDERED_ORDERINGKIND = MOrderingKind.UNORDERED;<br/>
    public static final Object SORTED_ORDERINGKIND = MOrderingKind.SORTED;<br/>
<br/>
    public static final Object M1_1_MULTIPLICITY = MMultiplicity.M1_1;<br/>
    public static final Object M0_1_MULTIPLICITY = MMultiplicity.M0_1;<br/>
    public static final Object M0_N_MULTIPLICITY = MMultiplicity.M0_N;<br/>
    public static final Object M1_N_MULTIPLICITY = MMultiplicity.M1_N;<br/>
<br/>
    public static final Object CLASSIFIER_SCOPEKIND = MScopeKind.CLASSIFIER;<br/>
    public static final Object INSTANCE_SCOPEKIND = MScopeKind.INSTANCE;<br/>
<br/>
    public static final Object INOUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.INOUT;<br/>
<br/>
    public static final Object IN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.IN;<br/>
<br/>
    public static final Object OUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.OUT;<br/>
<br/>
    public static final Object RETURN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.RETURN;<br/>
<br/>
<br/>
    /**<br/>
     * This tag is set on elements that are generated by reference when<br/>
     * importing.<br/>
     * If it is set, then the critics could ignore those objects if they want.<br/>
     */<br/>
    public static final String GENERATED_TAG = "GeneratedFromImport";<br/>
<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Object Creation methods<br/>
<br/>
    /**<br/>
     * Create a model object from the implementation.&lt;P&gt;<br/>
     *<br/>
     * This will allow abstraction of the create mechanism at a single point.<br/>
     *<br/>
     * TODO: Document the intention of this function.<br/>
     * It is not used anywhere in ArgoUML. <br/>
     * BTW: Does it work? I (MVW) once did a test, and it didn't.<br/>
     *<br/>
     * @param entity Class to create -<br/>
     * must implement {@link org.argouml.model.UmlModelEntity}<br/>
     * @return the created object or null if it cannot create the class.<br/>
     */<br/>
    public static Object create(ModelEntity entity) {<br/>
        if (entity instanceof UmlModelEntity) {<br/>
            return UmlFactory.getFactory().create((UmlModelEntity) entity);<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Abstraction.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Abstraction<br/>
     */<br/>
    public static boolean isAAbstraction(Object handle) {<br/>
        return handle instanceof MAbstraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action<br/>
     */<br/>
    public static boolean isAAction(Object handle) {<br/>
        return handle instanceof MAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionExpression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ActionExpression<br/>
     */<br/>
    public static boolean isAActionExpression(Object handle) {<br/>
        return handle instanceof MActionExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionSequence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an action sequence<br/>
     */<br/>
    public static boolean isAActionSequence(Object handle) {<br/>
        return handle instanceof MActionSequence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action state<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action state<br/>
     */<br/>
    public static boolean isAActionState(Object handle) {<br/>
        return handle instanceof MActionState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an call state<br/>
     */<br/>
    public static boolean isACallState(Object handle) {<br/>
        return handle instanceof MCallState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ObjectFlowState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an objectflow state<br/>
     */<br/>
    public static boolean isAObjectFlowState(Object handle) {<br/>
        return handle instanceof MObjectFlowState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SubactivityState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an subactivity state<br/>
     */<br/>
    public static boolean isASubactivityState(Object handle) {<br/>
        return handle instanceof MSubactivityState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Actor<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Actor<br/>
     */<br/>
    public static boolean isAActor(Object handle) {<br/>
        return handle instanceof MActor;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AggregationKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AggregationKind<br/>
     */<br/>
    public static boolean isAAggregationKind(Object handle) {<br/>
        return handle instanceof MAggregationKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Association.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Association<br/>
     */<br/>
    public static boolean isAAssociation(Object handle) {<br/>
        return handle instanceof MAssociation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEnd.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEnd<br/>
     */<br/>
    public static boolean isAAssociationEnd(Object handle) {<br/>
        return handle instanceof MAssociationEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationRole<br/>
     */<br/>
    public static boolean isAAssociationRole(Object handle) {<br/>
        return handle instanceof MAssociationRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEndRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEndRole<br/>
     */<br/>
    public static boolean isAAssociationEndRole(Object handle) {<br/>
        return handle instanceof MAssociationEndRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Attribute<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Attribute<br/>
     */<br/>
    public static boolean isAAttribute(Object handle) {<br/>
        return handle instanceof MAttribute;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for asynchronisity of an action<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the argument is asynchronous<br/>
     */<br/>
    public static boolean isAsynchronous(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).isAsynchronous();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for abstract classes and operations.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is abstract.<br/>
     */<br/>
    public static boolean isAbstract(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).isAbstract();<br/>
        if (handle instanceof MGeneralizableElement)<br/>
            return ((MGeneralizableElement) handle).isAbstract();<br/>
        if (handle instanceof MAssociation)<br/>
            return ((MAssociation) handle).isAbstract();<br/>
        // isAbstarct() is not a typo! mistake in nsuml!<br/>
        if (handle instanceof MReception)<br/>
            return ((MReception) handle).isAbstarct();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for ActivityGraph<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is ActivityGraph.<br/>
     */<br/>
    public static boolean isAActivityGraph(Object handle) {<br/>
        return handle instanceof MActivityGraph;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for bases. A base is an object that is some form of<br/>
     * an element in the model. MBase in Novosoft terms.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a base.<br/>
     */<br/>
    public static boolean isABase(Object handle) {<br/>
        return handle instanceof MBase;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for behavioral features.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a behavioral feature<br/>
     */<br/>
    public static boolean isABehavioralFeature(Object handle) {<br/>
        return handle instanceof MBehavioralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallAction<br/>
     */<br/>
    public static boolean isACallAction(Object handle) {<br/>
        return handle instanceof MCallAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallEvent<br/>
     */<br/>
    public static boolean isACallEvent(Object handle) {<br/>
        return handle instanceof MCallEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ChangeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ChangeEvent<br/>
     */<br/>
    public static boolean isAChangeEvent(Object handle) {<br/>
        return handle instanceof MChangeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Class<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Class<br/>
     */<br/>
    public static boolean isAClass(Object handle) {<br/>
        return handle instanceof MClass;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Classifier<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Classifier<br/>
     */<br/>
    public static boolean isAClassifier(Object handle) {<br/>
        return handle instanceof MClassifier;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierInState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierInState<br/>
     */<br/>
    public static boolean isAClassifierInState(Object handle) {<br/>
        return handle instanceof MClassifierInState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierRole<br/>
     */<br/>
    public static boolean isAClassifierRole(Object handle) {<br/>
        return handle instanceof MClassifierRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Comment<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Comment<br/>
     */<br/>
    public static boolean isAComment(Object handle) {<br/>
        return handle instanceof MComment;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Collaboration<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Collaboration<br/>
     */<br/>
    public static boolean isACollaboration(Object handle) {<br/>
        return handle instanceof MCollaboration;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Component<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Component<br/>
     */<br/>
    public static boolean isAComponent(Object handle) {<br/>
        return handle instanceof MComponent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ComponentInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ComponentInstance<br/>
     */<br/>
    public static boolean isAComponentInstance(Object handle) {<br/>
        return handle instanceof MComponentInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Constraint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Constraint<br/>
     */<br/>
    public static boolean isAConstraint(Object handle) {<br/>
        return handle instanceof MConstraint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CreateAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CreateAction<br/>
     */<br/>
    public static boolean isACreateAction(Object handle) {<br/>
        return handle instanceof MCreateAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataType<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataType<br/>
     */<br/>
    public static boolean isADataType(Object handle) {<br/>
        return handle instanceof MDataType;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataValue<br/>
     */<br/>
    public static boolean isADataValue(Object handle) {<br/>
        return handle instanceof MDataValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Dependency<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Dependency<br/>
     */<br/>
    public static boolean isADependency(Object handle) {<br/>
        return handle instanceof MDependency;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DestroyAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DestroyAction<br/>
     */<br/>
    public static boolean isADestroyAction(Object handle) {<br/>
        return handle instanceof MDestroyAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CompositeState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CompositeState<br/>
     */<br/>
    public static boolean isACompositeState(Object handle) {<br/>
        return handle instanceof MCompositeState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Element<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Element<br/>
     */<br/>
    public static boolean isAElement(Object handle) {<br/>
        return handle instanceof MElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementImport<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementImport<br/>
     */<br/>
    public static boolean isAElementImport(Object handle) {<br/>
        return handle instanceof MElementImport;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementListener<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementListener<br/>
     */<br/>
    public static boolean isAElementListener(Object handle) {<br/>
        return handle instanceof MElementListener;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementResidence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementResidence<br/>
     */<br/>
    public static boolean isAElementResidence(Object handle) {<br/>
        return handle instanceof MElementResidence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Event<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Event<br/>
     */<br/>
    public static boolean isAEvent(Object handle) {<br/>
        return handle instanceof MEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Exception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Exception<br/>
     */<br/>
    public static boolean isAException(Object handle) {<br/>
        return handle instanceof MException;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Expression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Expression<br/>
     */<br/>
    public static boolean isAExpression(Object handle) {<br/>
        return handle instanceof MExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Extend<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Extend<br/>
     */<br/>
    public static boolean isAExtend(Object handle) {<br/>
        return handle instanceof MExtend;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ExtensionPoint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ExtensionPoint<br/>
     */<br/>
    public static boolean isAExtensionPoint(Object handle) {<br/>
        return handle instanceof MExtensionPoint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Feature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Feature<br/>
     */<br/>
    public static boolean isAFeature(Object handle) {<br/>
        return handle instanceof MFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for FinalState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a FinalState<br/>
     */<br/>
    public static boolean isAFinalState(Object handle) {<br/>
        return handle instanceof MFinalState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Flow<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Flow<br/>
     */<br/>
    public static boolean isAFlow(Object handle) {<br/>
        return handle instanceof MFlow;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Guard<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Guard<br/>
     */<br/>
    public static boolean isAGuard(Object handle) {<br/>
        return handle instanceof MGuard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralizableElement(Object handle) {<br/>
        return handle instanceof MGeneralizableElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralization(Object handle) {<br/>
        return handle instanceof MGeneralization;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Include<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Include<br/>
     */<br/>
    public static boolean isAInclude(Object handle) {<br/>
        return handle instanceof MInclude;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Instance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Instance<br/>
     */<br/>
    public static boolean isAInstance(Object handle) {<br/>
        return handle instanceof MInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interaction<br/>
     */<br/>
    public static boolean isAInteraction(Object handle) {<br/>
        return handle instanceof MInteraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interface<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interface<br/>
     */<br/>
    public static boolean isAInterface(Object handle) {<br/>
        return handle instanceof MInterface;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Link<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Link<br/>
     */<br/>
    public static boolean isALink(Object handle) {<br/>
        return handle instanceof MLink;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for LinkEnd<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a LinkEnd<br/>
     */<br/>
    public static boolean isALinkEnd(Object handle) {<br/>
        return handle instanceof MLinkEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Message<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMessage(Object handle) {<br/>
        return handle instanceof MMessage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Method<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMethod(Object handle) {<br/>
        return handle instanceof MMethod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Model<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Model<br/>
     */<br/>
    public static boolean isAModel(Object handle) {<br/>
        return handle instanceof MModel;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ModelElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ModelElement<br/>
     */<br/>
    public static boolean isAModelElement(Object handle) {<br/>
        return handle instanceof MModelElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Multiplicity<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Multiplicity<br/>
     */<br/>
    public static boolean isAMultiplicity(Object handle) {<br/>
        return handle instanceof MMultiplicity;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MultiplicityRange<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a MultiplicityRange<br/>
     */<br/>
    public static boolean isAMultiplicityRange(Object handle) {<br/>
        return handle instanceof MMultiplicityRange;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Namespace<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Namespace<br/>
     */<br/>
    public static boolean isANamespace(Object handle) {<br/>
        return handle instanceof MNamespace;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Node<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Node<br/>
     */<br/>
    public static boolean isANode(Object handle) {<br/>
        return handle instanceof MNode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a NodeInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a NodeInstance<br/>
     */<br/>
    public static boolean isANodeInstance(Object handle) {<br/>
        return handle instanceof MNodeInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Operation<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Operation<br/>
     */<br/>
    public static boolean isAOperation(Object handle) {<br/>
        return handle instanceof MOperation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Object<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Object<br/>
     */<br/>
    public static boolean isAObject(Object handle) {<br/>
        return handle instanceof MObject;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Parameter<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Parameter<br/>
     */<br/>
    public static boolean isAParameter(Object handle) {<br/>
        return handle instanceof MParameter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Partition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Partition<br/>
     */<br/>
    public static boolean isAPartition(Object handle) {<br/>
        return handle instanceof MPartition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Permission<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Permission<br/>
     */<br/>
    public static boolean isAPermission(Object handle) {<br/>
        return handle instanceof MPermission;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Package<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Package<br/>
     */<br/>
    public static boolean isAPackage(Object handle) {<br/>
        return handle instanceof MPackage;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Pseudostate<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Pseudostate<br/>
     */<br/>
    public static boolean isAPseudostate(Object handle) {<br/>
        return handle instanceof MPseudostate;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for PseudostateKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a PseudostateKind<br/>
     */<br/>
    public static boolean isAPseudostateKind(Object handle) {<br/>
        return handle instanceof MPseudostateKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate<br/>
     * <br/>
     * TODO: - Do we need this as well as getKind - I think not<br/>
     * <br/>
     * @param handle the Pseudostate<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getPseudostateKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate or Parameter<br/>
     * @param handle the Pseudostate or Parameter<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receiver object of a message or stimulus<br/>
     * @param handle candidate<br/>
     * @return receiver<br/>
     */<br/>
    public static Object getReceiver(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getReceiver();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getReceiver();<br/>
        }<br/>
    return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the Link belonging to the given LinkEnd<br/>
     * @param handle the LinkEnd<br/>
     * @return the Link<br/>
     */<br/>
    public static Object getLink(Object handle) {<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getLink();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Check whether two pseudostatekinds are equal/of the same type.<br/>
     *<br/>
     * @return true if the are the same type<br/>
     * @param ps1 one kind<br/>
     * @param ps2 one kind<br/>
     */<br/>
    public static boolean equalsPseudostateKind(Object ps1, Object ps2) {<br/>
        if (isAPseudostateKind(ps1)) {<br/>
            return ((MPseudostateKind) ps1).equals(ps2);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(ps1);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Reception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Reception<br/>
     */<br/>
    public static boolean isAReception(Object handle) {<br/>
        return handle instanceof MReception;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Returnaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a returnaction<br/>
     */<br/>
    public static boolean isAReturnAction(Object handle) {<br/>
        return handle instanceof MReturnAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Relationship<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Relationship<br/>
     */<br/>
    public static boolean isARelationship(Object handle) {<br/>
        return handle instanceof MRelationship;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SendAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SendAction<br/>
     */<br/>
    public static boolean isASendAction(Object handle) {<br/>
        return handle instanceof MSendAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Signal<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Signal<br/>
     */<br/>
    public static boolean isASignal(Object handle) {<br/>
        return handle instanceof MSignal;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SignalEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SignalEvent<br/>
     */<br/>
    public static boolean isASignalEvent(Object handle) {<br/>
        return handle instanceof MSignalEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateMachine<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateMachine<br/>
     */<br/>
    public static boolean isAStateMachine(Object handle) {<br/>
        return handle instanceof MStateMachine;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for stimulus<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a stimulus<br/>
     */<br/>
    public static boolean isAStimulus(Object handle) {<br/>
        return handle instanceof MStimulus;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateVertex<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateVertex<br/>
     */<br/>
    public static boolean isAStateVertex(Object handle) {<br/>
        return handle instanceof MStateVertex;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Stereotype<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Stereotype<br/>
     */<br/>
    public static boolean isAStereotype(Object handle) {<br/>
        return handle instanceof MStereotype;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StructuralFeature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StructuralFeature<br/>
     */<br/>
    public static boolean isAStructuralFeature(Object handle) {<br/>
        return handle instanceof MStructuralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for State<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a State<br/>
     */<br/>
    public static boolean isAState(Object handle) {<br/>
        return handle instanceof MState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Subsystem<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Subsystem<br/>
     */<br/>
    public static boolean isASubsystem(Object handle) {<br/>
        return handle instanceof MSubsystem;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TaggedValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TaggedValue<br/>
     */<br/>
    public static boolean isATaggedValue(Object handle) {<br/>
        return handle instanceof MTaggedValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Transition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isATransition(Object handle) {<br/>
        return handle instanceof MTransition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TimeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TimeEvent<br/>
     */<br/>
    public static boolean isATimeEvent(Object handle) {<br/>
        return handle instanceof MTimeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Usage<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Usage<br/>
     */<br/>
    public static boolean isAUsage(Object handle) {<br/>
        return handle instanceof MUsage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Use Case<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isAUseCase(Object handle) {<br/>
        return handle instanceof MUseCase;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for VisibilityKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a VisibilityKind<br/>
     */<br/>
    public static boolean isAVisibilityKind(Object handle) {<br/>
        return handle instanceof MVisibilityKind;<br/>
    }<br/>
<br/>
    /** <br/>
     * Recognizer for Classes that are Active<br/>
     *  <br/>
     * @param handle candidate<br/>
     * @return true if Class is Active<br/>
     */<br/>
    public static boolean isActive(Object handle) {<br/>
        if (handle instanceof MClass) {<br/>
            return ((MClass) handle).isActive();<br/>
        }<br/>
    return illegalArgumentBoolean(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for attributes that are changeable<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is changeable<br/>
     */<br/>
    public static boolean isChangeable(Object handle) {<br/>
        if (handle != null &amp;&amp; handle instanceof MStructuralFeature) {<br/>
            MChangeableKind changeability =<br/>
                ((MStructuralFeature) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
<br/>
        } else if (handle != null &amp;&amp; handle instanceof MAssociationEnd) {<br/>
            MChangeableKind changeability =<br/>
                ((MAssociationEnd) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with classifier scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has classifier scope.<br/>
     */<br/>
    public static boolean isClassifierScope(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MAttribute a = (MAttribute) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(a.getOwnerScope());<br/>
        }<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature f = (MFeature) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(f.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for concurent composite state.<br/>
     *<br/>
     * @param handle composite state<br/>
     * @return true if concurent.<br/>
     */<br/>
    public static boolean isConcurent(Object handle) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            return ((MCompositeState) handle).isConcurent();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for constructor.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a constructor.<br/>
     */<br/>
    public static boolean isConstructor(Object handle) {<br/>
        Object stereo = null;<br/>
        if (isAOperation(handle)) {<br/>
            if (ModelFacade.getStereotypes(handle).size() &gt; 0) {<br/>
                stereo = ModelFacade.getStereotypes(handle).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
        if (isAMethod(handle)) {<br/>
            Object specification =<br/>
                CoreHelper.getHelper().getSpecification(handle);<br/>
            if (ModelFacade.getStereotypes(specification).size() &gt; 0) {<br/>
                stereo =<br/>
                    ModelFacade.getStereotypes(specification).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the given element is Frozen<br/>
     * @param handle candidate<br/>
     * @return boolean true if Frozen<br/>
     */<br/>
    public static boolean isFrozen(Object handle) {<br/>
        if (handle instanceof MChangeableKind) {<br/>
            MChangeableKind ck = (MChangeableKind) handle;<br/>
            return MChangeableKind.FROZEN.equals(ck);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isComposite(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.COMPOSITE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isAggregate(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.AGGREGATE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes that are initialized.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the attribute is initialized.<br/>
     */<br/>
    public static boolean isInitialized(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MExpression init = ((MAttribute) handle).getInitialValue();<br/>
<br/>
            if (init != null<br/>
                &amp;&amp; init.getBody() != null<br/>
                &amp;&amp; init.getBody().trim().length() &gt; 0)<br/>
                return true;<br/>
            return false;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with instance scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has instance scope.<br/>
     */<br/>
    public static boolean isInstanceScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature a = (MFeature) handle;<br/>
            return MScopeKind.INSTANCE.equals(a.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for internal transitions.<br/>
     *<br/>
     * @author mvw<br/>
     * @param handle candidate<br/>
     * @return true if handle is an internal transition.<br/>
     */<br/>
    public static boolean isInternal(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            Object state = getState(handle);<br/>
            Object end0 = getSource(handle);<br/>
            Object end1 = getTarget(handle);<br/>
            if (end0 != null) {<br/>
                return ((state == end0) &amp;&amp; (state == end1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
        }<br/>
        return illegalArgumentBoolean(handle);<br/>
    }<br/>
    /**<br/>
     * Recognizer for leafs<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isLeaf(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isLeaf();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for roots<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isRoot(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isRoot();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for specifications<br/>
     *<br/>
     * @param handle candidate ModelElement<br/>
     * @return true if handle is a specification<br/>
     */<br/>
    public static boolean isSpecification(Object handle) {<br/>
<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).isSpecification();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Navigable elements<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is navigable<br/>
     */<br/>
    public static boolean isNavigable(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).isNavigable();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for primary objects.&lt;p&gt;<br/>
     *<br/>
     * A primary object is an object that is created by the parser or<br/>
     * by a user.<br/>
     * Object that are created when importing some other object are not.&lt;p&gt;<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if primary object.<br/>
     */<br/>
    public static boolean isPrimaryObject(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            for (Iterator i = element.getTaggedValues().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.hasNext(); ) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if ((GENERATED_TAG).equals(tv.getTag())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
            return true;<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with private<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has private<br/>
     */<br/>
    public static boolean isPrivate(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PRIVATE.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with public<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has public<br/>
     */<br/>
    public static boolean isPublic(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PUBLIC.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MBehaviouralFeature's that are queries.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if it is a query<br/>
     */<br/>
    public static boolean isQuery(Object handle) {<br/>
<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MBehavioralFeature) handle).isQuery();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with protected<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has protected<br/>
     */<br/>
    public static boolean isProtected(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PROTECTED.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for realize<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has a realize stereotype<br/>
     */<br/>
    public static boolean isRealize(Object handle) {<br/>
        return isStereotype(handle, "realize");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for return<br/>
     *<br/>
     * @param handle candidate parameter<br/>
     * @return true if handle is a return parameter.<br/>
     */<br/>
    public static boolean isReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            MParameter p = (MParameter) handle;<br/>
            return MParameterDirectionKind.RETURN.equals(p.getKind());<br/>
<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for singleton.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a singleton.<br/>
     */<br/>
    public static boolean isSingleton(Object handle) {<br/>
        return isStereotype(handle, "singleton");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for model elements with a given stereotype.<br/>
     *<br/>
     * @param handle candidate model element<br/>
     * @param stereotypename a string that is the stereotype name.<br/>
     * @return true if handle is an object that has the given stereotype.<br/>
     */<br/>
    public static boolean isStereotype(Object handle, String stereotypename) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            MStereotype meSt = element.getStereotype();<br/>
<br/>
            if (meSt == null)<br/>
                return false;<br/>
<br/>
            String name = meSt.getName();<br/>
            if (name == null)<br/>
                return false;<br/>
<br/>
            return name.equalsIgnoreCase(stereotypename);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /** Returns true if the given CompositeState is the top state<br/>
     * @param handle CompositeState<br/>
     * @return boolean true if top state<br/>
     */<br/>
    public static boolean isTop(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getStateMachine() != null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for type.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a type.<br/>
     */<br/>
    public static boolean isType(Object handle) {<br/>
        return isStereotype(handle, "type");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for utility.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a utility.<br/>
     */<br/>
    public static boolean isUtility(Object handle) {<br/>
        return isStereotype(handle, "utility");<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the diagrams (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Diagram.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a diagram.<br/>
     */<br/>
    public static boolean isADiagram(Object handle) {<br/>
        return handle instanceof Diagram;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Getters for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Returns the association connected to an association end or<br/>
     * the association belonging to the given link.<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociation(Object handle) {<br/>
<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAssociation();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((MLink) handle).getAssociation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the association end between some classifier and some associaton.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param assoc is the association<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociationEnd(Object handle, Object assoc) {<br/>
        if (handle instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; assoc instanceof MAssociation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifier classifier = (MClassifier) handle;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = classifier.getAssociationEnds().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAssociationEnd end = (MAssociationEnd) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((MAssociation) assoc).getConnections().contains(end))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return end;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, assoc);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Association Ends<br/>
     *<br/>
     * @param handle the object that we get the association ends from.<br/>
     * @return Collection with association ends.<br/>
     */<br/>
    public static Collection getAssociationEnds(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection endc = ((MClassifier) handle).getAssociationEnds();<br/>
            return endc;<br/>
        }<br/>
<br/>
        //...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of association roles<br/>
     *<br/>
     * @param handle the object that we get the association roles from.<br/>
     * @return Collection of association roles.<br/>
     */<br/>
    public static Collection getAssociationRoles(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getAssociationRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Attributes.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return iterator with attributes.<br/>
     */<br/>
    public static Collection getAttributes(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            //return getStructuralFeatures(c).iterator();<br/>
            //...But I (thn) got CVS conflicts, so:<br/>
            return getStructuralFeatures(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The baseclass of some stereotype<br/>
     * @param handle the stereotype<br/>
     * @return the baseclass<br/>
     */<br/>
    public static Object getBaseClass(Object handle) {<br/>
        if (isAStereotype(handle)) {<br/>
            return ((MStereotype) handle).getBaseClass();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The base of some model element<br/>
     * There is a bug in NSUML which gets the addition and base <br/>
     * relationships back to front for include relationships. Solve<br/>
     * by reversing their accessors in the code<br/>
     * @param handle the model element<br/>
     * @return the base<br/>
     */<br/>
    public static Object getBase(Object handle) {<br/>
        if (handle instanceof MAssociationEndRole) {<br/>
            return ((MAssociationEndRole) handle).getBase();<br/>
        } else if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getBase();<br/>
        } else if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getBase();<br/>
        } else if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getAddition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the bases of a classifier role.<br/>
     *<br/>
     *<br/>
     * @param handle classifier role.<br/>
     * @return the bases.<br/>
     */<br/>
    public static Collection getBases(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getBases();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behaviors of a Modelelement.<br/>
     *<br/>
     *<br/>
     * @param handle modelelement to examine.<br/>
     * @return the behaviors.<br/>
     */<br/>
    public static Collection getBehaviors(Object handle) {<br/>
        if (isAModelElement(handle))<br/>
            return ((MModelElement) handle).getBehaviors();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behavioral feature of an parameter.<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the behavioral feature.<br/>
     */<br/>
    public static Object getBehavioralFeature(Object handle) {<br/>
        if (handle instanceof MParameter)<br/>
            return ((MParameter) handle).getBehavioralFeature();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the body of an method/constraint/expression.<br/>
     *<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the body.<br/>
     */<br/>
    public static Object getBody(Object handle) {<br/>
        if (handle instanceof MMethod)<br/>
            return ((MMethod) handle).getBody();<br/>
        if (handle instanceof MConstraint)<br/>
            return ((MConstraint) handle).getBody();<br/>
        if (handle instanceof MExpression)<br/>
            return ((MExpression) handle).getBody();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return Changeability of a StructuralFeature or a AssociationEnd<br/>
     * @param handle the StructuralFeature or AssociationEnd<br/>
     * @return the Changeability<br/>
     */<br/>
    public static Object getChangeability(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getChangeability();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getChangeability();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Get the child of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the child.<br/>
     */<br/>
    public static Object getChild(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getChild();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the children of some generalizable element<br/>
     *<br/>
     * @param handle to the generalizable element.<br/>
     * @return a collection with all children.<br/>
     */<br/>
    public static Collection getChildren(Object handle) {<br/>
        if (isAGeneralizableElement(handle)) {<br/>
            return ((MGeneralizableElement) handle).getChildren();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers roles of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifiers roles of the instance<br/>
     */<br/>
    public static Collection getClassifierRoles(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getClassifierRoles();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifierRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifierss of some instance<br/>
     * @param handle the instance<br/>
     * @return the classifierss of the instance<br/>
     */<br/>
    public static Collection getClassifiers(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getClassifiers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers in state of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifierss in state<br/>
     */<br/>
    public static Collection getClassifiersInState(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifiersInState();<br/>
        }<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getClassifiersInState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the clients of some dependency<br/>
     * @param handle the dependency<br/>
     * @return the clients of the dependency<br/>
     */<br/>
    public static Collection getClients(Object handle) {<br/>
        if (isADependency(handle)) {<br/>
            return ((MDependency) handle).getClients();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the client dependencies of some classifier<br/>
     *<br/>
     * @param handle to the classifier.<br/>
     * @return an iterator with all client dependencies.<br/>
     */<br/>
    public static Collection getClientDependencies(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            Collection c = ((MModelElement) handle).getClientDependencies();<br/>
            return c;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the condition of an extend.<br/>
     *<br/>
     * @param handle The extend.<br/>
     * @return the condition<br/>
     */<br/>
    public static Object getCondition(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getCondition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the concurrency of an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @return the concurrency.<br/>
     */<br/>
    public static Object getConcurrency(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getConcurrency();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    //    public static short getConcurrency(Object handle) {<br/>
    //        if (handle != null &amp;&amp; handle instanceof MOperation) {<br/>
    //            return ((MOperation) handle).getConcurrency()<br/>
    //                == MCallConcurrencyKind.GUARDED<br/>
    //                ? GUARDED<br/>
    //                : SEQUENTIAL;<br/>
    //        }<br/>
    //        illegalArgument(handle);<br/>
    //        return (short) 0;<br/>
    //    }<br/>
<br/>
    /**<br/>
     * The list of connections to an association or link.<br/>
     *<br/>
     * @param handle to the association or link<br/>
     * @return a Collection with all connections.<br/>
     */<br/>
    public static Collection getConnections(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
            return ((MLink) handle).getConnections();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a model element contains a connection.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param connection is the connection that is searched for.<br/>
     * @return true if the model element contains a connection<br/>
     */<br/>
    public boolean containsConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections().contains(<br/>
                connection);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return the effect<br/>
     */<br/>
    public static Object getEffect(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getEffect();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the residences of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the residences of<br/>
     * @return the residence collection<br/>
     */<br/>
    public static Collection getElementResidences(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getElementResidences();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the ElementImports of this ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of ElementImports<br/>
     */<br/>
    public static Collection getElementImports2(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getElementImports2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the entry action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the entry<br/>
     */<br/>
    public static Object getEntry(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getEntry();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the exit action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the exit action<br/>
     */<br/>
    public static Object getExit(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getExit();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Expression belonging to a Guard, ChangeEvent or timeEvent<br/>
     * @param handle the Object to get the Expression from<br/>
     * @return Object the Expression<br/>
     */<br/>
    public static Object getExpression(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getExpression();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MChangeEvent) {<br/>
            return ((MChangeEvent) handle).getChangeExpression();<br/>
        }<br/>
        if (handle instanceof MTimeEvent) {<br/>
            return ((MTimeEvent) handle).getWhen();<br/>
        }       <br/>
        return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case or extension point<br/>
     *<br/>
     * @param handle is the use case or the extension point<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends();<br/>
        }<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getExtends();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the use case extension of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @return The extension<br/>
     */<br/>
    public static Object getExtension(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtension();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Extensionpoint at given index-number<br/>
     * @param handle Extend<br/>
     * @param index int<br/>
     * @return ExtensionPoint<br/>
     */<br/>
    public static Object getExtensionPoint(Object handle, int index) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoint(index);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case or the extend<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtensionPoints(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtensionPoints();<br/>
        }<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Features from a Classifier.<br/>
     *<br/>
     * @param handle Classifier to retrieve from.<br/>
     * @return Collection with Features<br/>
     */<br/>
    public static Collection getFeatures(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getFeatures();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.<br/>
     *<br/>
     * @param handle is the child<br/>
     * @param parent is the parent<br/>
     * @return The generalization<br/>
     */<br/>
    public static Object getGeneralization(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralizableElement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = getGeneralizations(handle).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MGeneralization gen = (MGeneralization) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gen.getParent() == parent) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return gen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Generalizations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Generalizations<br/>
     */<br/>
    public static Collection getGeneralizations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getGeneralizations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the guard for some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getGuard(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getGuard();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Icon of a Stereotype<br/>
     * @param handle the Stereotype to get the Icon from<br/>
     * @return the Icon<br/>
     */<br/>
    public static Object getIcon(Object handle) {<br/>
        if (handle instanceof MStereotype) {<br/>
            return ((MStereotype) handle).getIcon();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the component of some element residence<br/>
     *<br/>
     * @param handle is an element residence<br/>
     * @return component<br/>
     */<br/>
    public static Object getImplementationLocation(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getImplementationLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the incoming transitions for some statevertex<br/>
     *<br/>
     * @param handle is the state vertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getIncomings(Object handle) {<br/>
        if (isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getIncomings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the initial value for some attribute.<br/>
     *<br/>
     * @param handle is the attribute<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInitialValue(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            return ((MAttribute) handle).getInitialValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the instance of an AttributeLink or LinkEnd<br/>
     *<br/>
     * @param handle is the attribute link or link end<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInstance(Object handle) {<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getInstance();<br/>
        }<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getInstance();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Instances for some Clasifier<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInstances(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getInstances();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of States for some ClasifierInState<br/>
     *<br/>
     * @param handle is the classifierInState<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInStates(Object handle) {<br/>
        if (handle instanceof MClassifierInState) {<br/>
            return ((MClassifierInState) handle).getInStates();<br/>
        }<br/>
    return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interaction for some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the interaction<br/>
     */<br/>
    public static Object getInteraction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getInteraction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interactions belonging to a collaboration<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInteractions(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getInteractions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the internal transitions belonging to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInternalTransitions(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getInternalTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages(Object handle) {<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getMessages();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some other message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages3(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the messages that are activated by the given message<br/>
     * @param handle Message<br/>
     * @return the Collection of Messages<br/>
     */<br/>
    public static Collection getMessages4(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages4();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages received by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages1(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages1();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages send by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages2(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the model of some model element<br/>
     *<br/>
     * @param handle to the model element.<br/>
     * @return model for the model element.<br/>
     */<br/>
    public static Object getModel(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            MModel m = ((MModelElement) handle).getModel();<br/>
            return m;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle an Element Import.<br/>
     * @return the model element<br/>
     */<br/>
    public static Object getModelElement(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MElementImport) handle).getModelElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Multiplicity from a model element.<br/>
     *<br/>
     * @param handle model element to retrieve from.<br/>
     * @return multiplicity<br/>
     */<br/>
    public static Object getMultiplicity(Object handle) {<br/>
        if ((handle instanceof MAssociationEnd)) {<br/>
            return ((MAssociationEnd) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MAssociationRole)) {<br/>
            return ((MAssociationRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MClassifierRole)) {<br/>
            return ((MClassifierRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MStructuralFeature)) {<br/>
            return ((MStructuralFeature) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Ranges from a Multiplicity.<br/>
     *<br/>
     * @param handle multiplicity to retrieve from.<br/>
     * @return iterator containing ranges<br/>
     */<br/>
    public static Iterator getRanges(Object handle) {<br/>
        if ((handle instanceof MMultiplicity)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection c = ((MMultiplicity) handle).getRanges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (c == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return c.iterator();<br/>
        }<br/>
        illegalArgument(handle);<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the comments of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the comments of<br/>
     * @return the comment (or null)<br/>
     */<br/>
    public static Collection getComments(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getComments();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication connection of an message.<br/>
     *<br/>
     * @param handle the message that we are getting the communication<br/>
     * connection<br/>
     * @return the communication connection<br/>
     */<br/>
    public static Object getCommunicationConnection(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getCommunicationConnection();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication link of a stimulus.<br/>
     *<br/>
     * @param handle the message that we are getting the communication link<br/>
     * @return the communication link<br/>
     */<br/>
    public static Object getCommunicationLink(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getCommunicationLink();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the collaborations of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the<br/>
     * collaborations of.<br/>
     * @return the collaborations<br/>
     */<br/>
    public static Collection getCollaborations(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public static void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the component instance of an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @return the component instance<br/>
     */<br/>
    public static Object getComponentInstance(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getComponentInstance();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the collection of ConstrainingElements of a Collaboration<br/>
     * @param handle the Collaboration<br/>
     * @return the collection of ConstrainingElements<br/>
     */<br/>
    public static Collection getConstrainingElements(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getConstrainingElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the collection of all constraints of the given ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of all constraints<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getConstraints</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getConstraints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the container for the given modelelement. The container is the<br/>
     * owner of the modelelement. It will be null for elements that don't have<br/>
     * an owner. All elements except for the root element in a project should<br/>
     * have an owner. The root element is allways a model.&lt;p&gt;<br/>
     *<br/>
     * In  the future, this function could return the container of Figs too.<br/>
     *<br/>
     * @param handle is the base<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getModelElementContainer</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MBase) {<br/>
            return ((MBase) <span class="mv">handle</span>).getModelElementContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the CompositeState that is the container of the given StateVertex<br/>
     * @param handle the StateVertex<br/>
     * @return the CompositeState that is the container <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getContainer</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateVertex) {<br/>
            return ((MStateVertex) <span class="mv">handle</span>).getContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
    <br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the collection of ModelElements contained in a Partition<br/>
     * @param handle the Partition<br/>
     * @return the contents of the Partition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getContents</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MPartition) {<br/>
            return ((MPartition) <span class="mv">handle</span>).getContents();<br/>
        }<br/>
        <span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction.<br/>
     *<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getContext(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (isAStateMachine(<span class="mv">handle</span>)) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getContext();<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isAInteraction</span>(handle)</span>) {<br/>
            return ((MInteraction) <span class="mv">handle</span>).getContext();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Return the collection of the Contexts of a given Signal<br/>
     * @param handle the Signal<br/>
     * @return a collection of the Contexts<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getContexts</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            return ((MSignal) <span class="mv">handle</span>).getContexts();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="del"><span class="mv">illegalArgumentCollection</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Return the collection of Actions that create/instantiate<br/>
     *  the given Classifier <br/>
     * <br/>
     * @param handle the Classifier<br/>
     * @return a collection containing all the creating actions<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getCreateActions</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getCreateActions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the default value of a parameter<br/>
     *<br/>
     * @param handle the parameter that we are getting the defaultvalue from<br/>
     * @return the default value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDefaultValue</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
            return ((MParameter) <span class="mv">handle</span>).getDefaultValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get deferrable events of a state<br/>
     *<br/>
     * @param handle the state that we are getting the deferrable event from<br/>
     * @return the deferrable events collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getDeferrableEvents</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getDeferrableEvents();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getDeploymentLocations</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isAComponent(<span class="mv">handle</span>)) {<br/>
            return ((MComponent) <span class="mv">handle</span>).getDeploymentLocations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the discriminator.<br/>
     *<br/>
     * @param handle the Generalization<br/>
     * @return the discriminator a String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDiscriminator</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getDiscriminator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
    <br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDiscriminator(<span class="mv">Object handle</span>, String discriminator) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        <span class="del"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the dispatchaction of a stimulus.<br/>
     *<br/>
     * @param handle the stimulus that we are getting the dispatchaction of<br/>
     * @return the dispatchaction (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDispatchAction</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStimulus) {<br/>
            return ((MStimulus) <span class="mv">handle</span>).getDispatchAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="mv"><span class="mv">illegalArgumentObject</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the do activity action of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the do activity<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDoActivity</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getDoActivity();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Return the Links of a given Association<br/>
     * @param handle the Association<br/>
     * @return the collection of Links<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getLinks</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociation) {<br/>
            return ((MAssociation) <span class="mv">handle</span>).getLinks();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Return the LinkEnds of a given Instance or AssociationEnd<br/>
     * @param handle the candidate<br/>
     * @return the collection of LinkEnds<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getLinkEnds(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getLinkEnds();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getLinkEnds();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Gets a location of some extension point.<br/>
     *<br/>
     * @param handle extension point<br/>
     * @return the location<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">String</span> <span class="mv">getLocation</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) <span class="mv">handle</span>).getLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentString</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the methods of an operation.<br/>
     *<br/>
     * @param handle the operation that we are getting the methods of<br/>
     * @return methods collection (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getMethods</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MOperation)<br/>
            return ((MOperation) <span class="mv">handle</span>).getMethods();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the namespace of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the namespace of<br/>
     * @return the namespace (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getNamespace</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement)<br/>
            return ((MModelElement) <span class="mv">handle</span>).getNamespace();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the node instance of a component instance.<br/>
     *<br/>
     * @param handle the model element that we are getting the node instance of<br/>
     * @return the node instance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getNodeInstance</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance)<br/>
            return ((MComponentInstance) <span class="mv">handle</span>).getNodeInstance();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * The collection of object flow states<br/>
     *<br/>
     * @param handle the classifier<br/>
     * @return collection of object flow states<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getObjectFlowStates</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getObjectFlowStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the operation of a Call Action or Call Event.<br/>
     *<br/>
     * @param handle the model element that we are getting the operation of<br/>
     * @return the Operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getOperation(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCallAction) {<br/>
            return ((MCallAction) <span class="mv">handle</span>).getOperation();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallEvent) {<br/>
            return ((MCallEvent) <span class="mv">handle</span>).getOperation();<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the list of operations.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Collection with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOperations</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) <span class="mv">handle</span>;<br/>
            return getOperations(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the list of Operations of this classifier and all inherited.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Iterator with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> Iterator getOperationsInh(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) <span class="mv">handle</span>;<br/>
<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            return CoreHelper.getHelper().getOperationsInh(c).iterator();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the opposite end of an association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @return Object the opposite end.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOppositeEnd</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getOppositeEnd();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="mv"><span class="mv">illegalArgumentObject</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get ordering of an association end<br/>
     *<br/>
     * @param handle association end to retrieve from<br/>
     * @return ordering<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOrdering</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd)<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getOrdering();<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the list of Transitions outgoing from the given stateVertex.<br/>
     *<br/>
     * @param handle statevertex<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOutgoings</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (ModelFacade.isAStateVertex(<span class="mv">handle</span>)) {<br/>
            return ((MStateVertex) <span class="mv">handle</span>).getOutgoings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the list of Associations Ends connected to this association end.<br/>
     *<br/>
     * @param handle association end to start from<br/>
     * @return Iterator with all connected association ends.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getOtherAssociationEnds(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            MAssociation a = ((MAssociationEnd) <span class="mv">handle</span>).getAssociation();<br/>
<br/>
            if (a == null)<br/>
                return emptyCollection();<br/>
<br/>
            <span class="mv">Collection</span> allEnds = a.getConnections();<br/>
            if (allEnds == null)<br/>
                return emptyCollection();<br/>
<br/>
            // TODO: An Iterator filter would be nice here instead of the<br/>
            // mucking around with the Collection.<br/>
            allEnds = new ArrayList(allEnds);<br/>
            allEnds.remove(<span class="mv">handle</span>);<br/>
            return allEnds;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * The list of owned elements of the the package.<br/>
     *<br/>
     * @param handle package to retrieve from.<br/>
     * @return Iterator with operations<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOwnedElements</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MNamespace) {<br/>
            return ((MNamespace) <span class="mv">handle</span>).getOwnedElements();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the owner scope of a feature<br/>
     *<br/>
     * @param handle feature<br/>
     * @return owner scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOwnerScope</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            return ((MFeature) <span class="mv">handle</span>).getOwnerScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the powertype of a generalization<br/>
     *<br/>
     * @param handle generalization<br/>
     * @return powertype<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getPowertype</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getPowertype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the powertype ranges of a classifier.<br/>
     *<br/>
     * @param handle classifier to retrieve from<br/>
     * @return collection of poertype ranges<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getPowertypeRanges</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getPowertypeRanges();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the predecessors of a message.<br/>
     *<br/>
     * @param handle message to retrieve from<br/>
     * @return collection of predecessors<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getPredecessors</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getPredecessors();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Determine if the passed parameter has a RETURN direction kind<br/>
     *<br/>
     * @return true if it is a return direction kind<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> boolean hasReturnParameterDirectionKind(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MParameter parameter = (MParameter) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameterDirectionKind.RETURN.equals(parameter.getKind()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentBoolean</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the Package that is connected by the given ElementImport <br/>
     * @param handle the ElementImport <br/>
     * @return the Package<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getPackage</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MElementImport) {<br/>
            return ((MElementImport) <span class="mv">handle</span>).getPackage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get a parameter of a behavioral feature.<br/>
     *<br/>
     * @param handle behavioral feature to retrieve from<br/>
     * @param n parameter number<br/>
     * @return parameter.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getParameter(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>, int n) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) <span class="mv">handle</span>).getParameter(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the parameters of a Object Flow State, Behavioral Feature, <br/>
     * Classifier or Event.<br/>
     *<br/>
     * @param handle operation to retrieve from<br/>
     * @return Iterator with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getParameters(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MEvent) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="del"><span class="mv">illegalArgumentCollection</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Get the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the parent.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getParent</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getParent();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the raised signals of an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @return raised signals<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getRaisedSignals</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            return ((MOperation) <span class="mv">handle</span>).getRaisedSignals();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the receptions of a signal.<br/>
     *<br/>
     * @param handle is the signal<br/>
     * @return receptions<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getReceptions</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            return ((MSignal) <span class="mv">handle</span>).getReceptions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the recurrence iteration expression of an action.<br/>
     *<br/>
     * @param handle is the action.<br/>
     * @return the recurrence<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRecurrence</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getRecurrence();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the represented classifier of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRepresentedClassifier</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration) {<br/>
            return ((MCollaboration) <span class="mv">handle</span>).getRepresentedClassifier();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the represented operation of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRepresentedOperation</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration) {<br/>
            return ((MCollaboration) <span class="mv">handle</span>).getRepresentedOperation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the script belonging to a given action<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the script<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getScript</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getScript();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     *<br/>
     * @param handle is the stimulus or message<br/>
     * @return the sender<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getSender(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus) {<br/>
            return ((MStimulus) <span class="mv">handle</span>).getSender();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getSender();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     * TODO: Check if this javadoc comment is really correct?<br/>
     *<br/>
     * @param handle is the object<br/>
     * @return the signal<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getSignal(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSendAction) {<br/>
            return ((MSendAction) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MSignalEvent) {<br/>
            return ((MSignalEvent) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            return ((MReception) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the resident element<br/>
     *<br/>
     * @param handle is the element residence<br/>
     * @return resident element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getResident(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence) {<br/>
            return ((MElementResidence) <span class="mv">handle</span>).getResident();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the collection of elements in a given component<br/>
     * @param handle the component<br/>
     * @return the Collection of ResidentElements<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getResidentElements</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MComponent) {<br/>
            return ((MComponent) <span class="mv">handle</span>).getResidentElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="del"><span class="mv">illegalArgumentCollection</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns a collection with all residents belonging to the given<br/>
     * node.<br/>
     *<br/>
     * @param handle is the node, nodeinstance, componentinstance<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getResidents(<span class="mv">Object handle</span>) {<br/>
        if (isANode(<span class="mv">handle</span>)) {<br/>
            return ((MNode) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isANodeInstance</span>(handle)</span>) {<br/>
            return ((MNodeInstance) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
        if (isAComponentInstance(<span class="mv">handle</span>)) {<br/>
            return ((MComponentInstance) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
            <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Gets the source for a given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object (MStateVertex)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getSource</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (isATransition(<span class="mv">handle</span>)) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getSource();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Gets the source for some given flow.<br/>
     *<br/>
     * @param handle is the flow<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSources</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MFlow) {<br/>
            return ((MFlow) <span class="mv">handle</span>).getSources();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the sourceflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of sourceflows<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSourceFlows</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getSourceFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * The list of Specializations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Collection of Specializations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSpecializations</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) <span class="mv">handle</span>;<br/>
            return ge.getSpecializations();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the state machine belonging to some given state or transition<br/>
     * If you need to find the StateMachine for an internal transition,<br/>
     * or for ANY state, <br/>
     * use StateMachinesHelper.getStateMachine() instead.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getStateMachine(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the state belonging to some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getState(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
    <br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the states from a deferable event<br/>
     *<br/>
     * @param handle is the event<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStates</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MEvent) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the stereotype belonging to some given model element<br/>
     *<br/>
     * @param handle is a model element<br/>
     * @return Object<br/>
     * @deprecated 0.15 in favor of getStereotypes since UML 1.5 supports <br/>
     * multiple stereotypes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getStereoType</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (isAModelElement(<span class="mv">handle</span>)) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getStereotype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the stereotypes belonging to some given model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return stereotype collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getStereotypes(<span class="mv">Object handle</span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>)) {<br/>
            // This returns a collection as we have an eye on the future<br/>
            // and multiple stereotypes in UML1.5<br/>
            ArrayList list = new ArrayList(1);<br/>
            list.add(((MModelElement) <span class="mv">handle</span>).getStereotype());<br/>
            return list;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the stimuli belonging to some given link<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isALink(<span class="mv">handle</span>)) {<br/>
            return ((MLink) <span class="mv">handle</span>).getStimuli();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the Stimuli that are received by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli2</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getStimuli2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the Stimuli that are send by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli3</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getStimuli3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns a collection with all subvertices belonging to the given<br/>
     * composite state.<br/>
     *<br/>
     * @param handle is the composite state<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSubvertices</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isACompositeState(<span class="mv">handle</span>)) {<br/>
            return ((MCompositeState) <span class="mv">handle</span>).getSubvertices();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the submachie of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getSubmachine</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSubmachineState) {<br/>
            return ((MSubmachineState) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the submachine of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSubmachineStates</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateMachine) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getSubmachineStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * The list of SupplierDependencies from a ModelElement.<br/>
     *<br/>
     * @param handle model element.<br/>
     * @return Iterator with the supplier dependencies.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSupplierDependencies</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            return me.getSupplierDependencies();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * The top of a state machine<br/>
     *<br/>
     * @param handle the state machine<br/>
     * @return the top<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getTop</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateMachine) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getTop();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the transition of a guard or action<br/>
     *<br/>
     * @param handle the guard or action<br/>
     * @return the transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTransition(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGuard) {<br/>
            return ((MGuard) <span class="mv">handle</span>).getTransition();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getTransition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the trigger of a transition<br/>
     *<br/>
     * @param handle the transition<br/>
     * @return the trigger<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTrigger(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getTrigger();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * The type of a StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     *<br/>
     * @param handle the StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     * @return the type<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getType(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            return ((MAttribute) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
            return ((MParameter) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        <br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the target of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTarget(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (isATransition(<span class="mv">handle</span>)) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getTarget();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the target scope of some model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTargetScope(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) <span class="mv">handle</span>).getTargetScope();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getTargetScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the targetflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of targetflows<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getTargetFlows</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTargetFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="del"><span class="mv">illegalArgumentCollection</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> int getUpper(<span class="mv">Object handle</span>) {<br/>
        if (isAAssociationEnd(<span class="mv">handle</span>)) {<br/>
            int upper = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (end.getMultiplicity() != null)<br/>
                upper = end.getMultiplicity().getUpper();<br/>
            return upper;<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isAMultiplicity</span>(handle)</span>) {<br/>
            MMultiplicity up = (MMultiplicity) <span class="mv">handle</span>;<br/>
            return up.getUpper();<br/>
        }<br/>
        if (isAMultiplicityRange(<span class="mv">handle</span>)) {<br/>
            MMultiplicityRange up = (MMultiplicityRange) <span class="mv">handle</span>;<br/>
            return up.getUpper();<br/>
        }<br/>
        <span class="del"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the use case of an extension point<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @return a use case<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getUseCase</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) <span class="mv">handle</span>).getUseCase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="mv"><span class="mv">illegalArgumentObject</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> int getLower(<span class="mv">Object handle</span>) {<br/>
        if (isAAssociationEnd(<span class="mv">handle</span>)) {<br/>
            int lower = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (end.getMultiplicity() != null)<br/>
                lower = end.getMultiplicity().getLower();<br/>
            return lower;<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isAMultiplicity</span>(handle)</span>) {<br/>
            MMultiplicity low = (MMultiplicity) <span class="mv">handle</span>;<br/>
            return low.getLower();<br/>
        }<br/>
        if (isAMultiplicityRange(<span class="mv">handle</span>)) {<br/>
            MMultiplicityRange low = (MMultiplicityRange) <span class="mv">handle</span>;<br/>
            return low.getLower();<br/>
        }<br/>
        <span class="del"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the transitions belonging to the given handle. The handle can be<br/>
     * a statemachine or a composite state or an event. <br/>
     * If it's a statemachine the<br/>
     * transitions will be given back belonging to that statemachine. If it's a<br/>
     * compositestate the internal transitions of that compositestate will be<br/>
     * given back. <br/>
     * If it's an event, all transitions triggered by this event <br/>
     * will be given back.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getTransitions(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (isAStateMachine(<span class="mv">handle</span>)) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getTransitions();<br/>
        } else if (<span class="mv"><span class="mv">isACompositeState</span>(handle)</span>) {<br/>
            return ((MCompositeState) <span class="mv">handle</span>).getInternalTransitions();<br/>
        } else if (isAEvent(<span class="mv">handle</span>)) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param handle is the classifier you want to have the attributes for.<br/>
     * @return a collection of the attributes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getStructuralFeatures(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        <span class="mv">Collection</span> result = new ArrayList();<br/>
        if (ModelFacade.isAClassifier(<span class="mv">handle</span>)) {<br/>
            MClassifier mclassifier = (MClassifier) <span class="mv">handle</span>;<br/>
<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (ModelFacade.isAStructuralFeature(feature))<br/>
                    result.add(feature);<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method returns all operations of a given Classifier<br/>
     *<br/>
     * @param mclassifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */</span><br/>
    protected <span class="mv">static</span> <span class="mv">Collection</span> getOperations(MClassifier mclassifier) {<br/>
        <span class="mv">Collection</span> result = new ArrayList();<br/>
        Iterator features = mclassifier.getFeatures().iterator();<br/>
        while (features.hasNext()) {<br/>
            MFeature feature = (MFeature) features.next();<br/>
            if (ModelFacade.isAOperation(feature))<br/>
                result.add(feature);<br/>
        }<br/>
        return result;<br/>
    }<br/>
    <br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the Specification of a given Reception<br/>
     * @param handle the Reception<br/>
     * @return String the Specification<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">String</span> <span class="mv">getSpecification</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            return ((MReception) <span class="mv">handle</span>).getSpecification();<br/>
        }<br/>
        <span class="mv">return <span class="mv">illegalArgumentString</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns all Interfaces of which this class is a realization.<br/>
     *<br/>
     * @param handle  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getSpecifications(<span class="mv">Object handle</span>) {<br/>
        <span class="mv">Collection</span> result = new Vector();<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getSpecifications();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            <span class="mv">Collection</span> deps = ((MClassifier) <span class="mv">handle</span>).getClientDependencies();<br/>
            Iterator depIterator = deps.iterator();<br/>
            while (depIterator.hasNext()) {<br/>
                MDependency dep = (MDependency) depIterator.next();<br/>
                if ((dep instanceof MAbstraction)<br/>
                        &amp;&amp; dep.getStereotype() != null<br/>
                        &amp;&amp; dep.getStereotype().getName() != null<br/>
                        &amp;&amp; dep.getStereotype().getName().equals("realize")) {<br/>
                    MInterface i =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MInterface) dep.getSuppliers().toArray()[0];<br/>
                    result.add(i);<br/>
                }<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="del">return <span class="del"><span class="mv">illegalArgumentCollection</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the suppliers of a dependency.<br/>
     *<br/>
     * @param handle is the dependency<br/>
     * @return a collection of the suppliers<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSuppliers</span>(<span class="mv">Object <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MDependency) {<br/>
            return ((MDependency) <span class="mv">handle</span>).getSuppliers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the action belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the action<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAction</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the activator belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the activator<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getActivator</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getActivator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the actual arguments for a given action.<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the actual arguments<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getActualArguments</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getActualArguments();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns an addition for a given inlcude.<br/>
     * There is a bug in NSUML which gets the addition and base<br/>
     * relationships back to front for include relationships. Solve<br/>
     * reversing their accessors in the code<br/>
     *<br/>
     * @param handle is the include<br/>
     * @return the addition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAddition</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInclude) {<br/>
            return ((MInclude) <span class="mv">handle</span>).getBase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the AggregationKind of a given AssociationEnd<br/>
     * @param handle the AssociationEnd<br/>
     * @return the AggregationKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAggregation</span>(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getAggregation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns all associated classes for some given classifier.<br/>
     * Returns an empty collection if the given argument handle is not<br/>
     * a classifier.  The given parameter is included in the returned<br/>
     * collection if it has a self-referencing association.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getAssociatedClasses(<span class="mv">Object handle</span>) {<br/>
        <span class="mv">Collection</span> col = new ArrayList();<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) <span class="mv">handle</span>;<br/>
            <span class="mv">Collection</span> ends = classifier.getAssociationEnds();<br/>
            Iterator it = ends.iterator();<br/>
            Set associations = new HashSet();<br/>
            while (it.hasNext()) {<br/>
                MAssociationEnd ae = (MAssociationEnd) it.next();<br/>
                associations.add(ae.getAssociation());<br/>
            }<br/>
            <span class="mv">Collection</span> otherEnds = new ArrayList();<br/>
            it = associations.iterator();<br/>
            while (it.hasNext()) {<br/>
                otherEnds.addAll(((MAssociation) it.next()).getConnections());<br/>
            }<br/>
            otherEnds.removeAll(ends);<br/>
            it = otherEnds.iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getType());<br/>
            }<br/>
            return col;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Common getters<br/>
<br/>
    <span class="mv">/**<br/>
     * The name of a model element or some diagram part.<br/>
     *<br/>
     * @param handle that points out the object.<br/>
     * @return the name<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getName(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof Diagram) {<br/>
            return ((Diagram) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOrderingKind) {<br/>
            return ((MOrderingKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAggregationKind) {<br/>
            return ((MAggregationKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MVisibilityKind) {<br/>
            return ((MVisibilityKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallConcurrencyKind) {<br/>
            return ((MCallConcurrencyKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the owner of a feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @return classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getOwner(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            return ((MFeature) <span class="mv">handle</span>).getOwner();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tag of a tagged value.<br/>
     *<br/>
     * @param handle The tagged value belongs to this.<br/>
     * @return The found tag as a String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTag(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tagged values iterator of a model element.<br/>
     *<br/>
     * @param handle The tagged values belong to this.<br/>
     * @return The tagged values iterator<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> Iterator getTaggedValues(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTaggedValues().iterator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Returns the TaggedValues of a ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the Collection of TaggedValues<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getTaggedValuesCollection</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTaggedValues();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The found tag, null if not found<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTaggedValue(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>, String name) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = ((MModelElement) <span class="mv">handle</span>);<br/>
            Iterator i = me.getTaggedValues().iterator();<br/>
            while (i.hasNext()) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if (tv.getTag().equals(name)) {<br/>
                    return tv;<br/>
                }<br/>
            }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * Return the value of a tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element that the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The value of the found tag. "" if not found.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTaggedValueValue(<span class="mv">Object handle</span>, String name) {<br/>
        <span class="mv">Object</span> taggedValue = getTaggedValue(<span class="mv">handle</span>, name);<br/>
        if (taggedValue == null) {<br/>
            return "";<br/>
        }<br/>
        return getValueOfTag(taggedValue);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the key (tag) of some tagged value.<br/>
     * <br/>
     * TODO: This does exactly the same as getTag(Object). Remove one of them.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTagOfTag(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the Value of some UML Object<br/>
     * @param handle Object<br/>
     * @return Object the exact type depends on the handle type<br/>
     * (String, Expression, Instance, TaggedValue...)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getValue(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MArgument) {<br/>
            return ((MArgument) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtension) {<br/>
            return ((MExtension) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAggregationKind) {<br/>
            return new Integer(((MAggregationKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOrderingKind) {<br/>
            return new Integer(((MOrderingKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperationDirectionKind) {<br/>
            return new Integer(((MOperationDirectionKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MVisibilityKind) {<br/>
            return new Integer(((MVisibilityKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MScopeKind) {<br/>
            return new Integer(((MScopeKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MMessageDirectionKind) {<br/>
            return new Integer(((MMessageDirectionKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MChangeableKind) {<br/>
            return new Integer(((MChangeableKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MPseudostateKind) {<br/>
            return new Integer(((MPseudostateKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallConcurrencyKind) {<br/>
            return new Integer(((MCallConcurrencyKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the value of some tagged value.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getValueOfTag(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the UUID of this element<br/>
     *<br/>
     * @param base base element (MBase type)<br/>
     * @return UUID<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getUUID(<span class="mv">Object <span class="mv">base</span></span>) {<br/>
        if (isABase(base)) {<br/>
            return ((MBase) base).getUUID();<br/>
        }<br/>
        if (base instanceof CommentEdge) {<br/>
            return (String) ((CommentEdge) base).getUUID();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(base);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     *  Return the visibility of this element<br/>
     *  @param handle an nsuml model element<br/>
     *  @return visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getVisibility(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getVisibility();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Other querying methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns a named object in the given object by calling it's lookup method.<br/>
     *<br/>
     * @param handle the object that we search through<br/>
     * @param name of the model element<br/>
     * @return found object, null otherwise<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> lookupIn(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>, String name) {<br/>
        if (<span class="mv">handle</span> instanceof MModel)<br/>
            return ((MModel) <span class="mv">handle</span>).lookup(name);<br/>
        if (<span class="mv">handle</span> instanceof MNamespace)<br/>
            return ((MNamespace) <span class="mv">handle</span>).lookup(name);<br/>
        if (<span class="mv">handle</span> instanceof MClassifier)<br/>
            return ((MClassifier) <span class="mv">handle</span>).lookup(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Model modifying methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a feature to some classifier.<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addFeature(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">f</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an instance to a classifier role.<br/>
     *<br/>
     * @param classifierRole is the classifier role<br/>
     * @param instance is the instance to add<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addInstance(<span class="mv">Object <span class="mv">classifierRole</span></span>, Object <span class="mv">instance</span>) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if (classifierRole instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; instance instanceof MInstance) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifierRole clr = (MClassifierRole) classifierRole;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    clr.addInstance((MInstance) instance);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(classifierRole, instance);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @author mvw<br/>
     * @param classifierInState the classifierInState<br/>
     * @param state the state that will be linked<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addInState(<span class="mv">Object <span class="mv">classifierInState</span></span>, Object <span class="mv">state</span>) {<br/>
        if (classifierInState instanceof MClassifierInState <br/>
                &amp;&amp; state instanceof MState) {<br/>
            ((MClassifierInState) classifierInState).addInState((MState) state);<br/>
        } else<br/>
            illegalArgument(classifierInState, state);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addFeature(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">int index</span>, Object <span class="mv">f</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, f);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add the given Link to the given Link or Association<br/>
     * @param handle the Link or Association <br/>
     * @param link Link<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addLink(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">link</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAssociation) <span class="mv">handle</span>).addLink((MLink) link);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, link);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add Message to a predecessor Message<br/>
     * @param handle predecessor Message<br/>
     * @param mess Message to be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addMessage3(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">mess</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).addMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mess);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addMethod(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">m</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) <span class="mv">handle</span>).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) <span class="mv">handle</span>).getOwnerScope());<br/>
            ((MOperation) <span class="mv">handle</span>).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, m);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a model element to some namespace.<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addOwnedElement(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">me</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) <span class="mv">handle</span>).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, me);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a Parameter to the given object<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MObjectFlowState, MEvent, MBehavioralFeature, MClassifier<br/>
     * @param parameter Object that will be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addParameter(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">parameter</span>) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) <span class="mv">handle</span>).addParameter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MEvent) {<br/>
                ((MEvent) <span class="mv">handle</span>).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
                ((MClassifier) <span class="mv">handle</span>).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameter);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a Parameter to the given object at given location<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MEvent, MBehavioralFeature<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addParameter(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        <span class="mv">int index</span>,<br/>
        Object <span class="mv">parameter</span>) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (<span class="mv">handle</span> instanceof MEvent) {<br/>
                ((MEvent) <span class="mv">handle</span>).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameter);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a predecessor to a message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param predecessor is the predecessor<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addPredecessor(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">predecessor</span>) {<br/>
        if (<span class="mv">handle</span> != null<br/>
            &amp;&amp; <span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; predecessor != null<br/>
            &amp;&amp; predecessor instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).addPredecessor((MMessage) predecessor);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, predecessor);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a raised Signal to a Message or Operation<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addRaisedSignal(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">sig</span>) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (<span class="mv">handle</span> instanceof MMessage) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MOperation) {<br/>
                ((MOperation) <span class="mv">handle</span>).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, sig);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a stimulus to a action or link<br/>
     *<br/>
     * @param handle the action or link<br/>
     * @param stimulus is the stimulus<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addStimulus(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">stimulus</span>) {<br/>
        if (<span class="mv">handle</span> != null<br/>
            &amp;&amp; stimulus != null<br/>
            &amp;&amp; stimulus instanceof MStimulus) {<br/>
            if (<span class="mv">handle</span> instanceof MAction) {<br/>
                ((MAction) <span class="mv">handle</span>).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MLink) {<br/>
                ((MLink) <span class="mv">handle</span>).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stimulus);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a subvertex to a composite state<br/>
     * @param handle the CompositeState<br/>
     * @param subvertex the StateVertex<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSubvertex(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">subvertex</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).addSubvertex((MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertex);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSupplier(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">element</span>) {<br/>
        if (isADependency(<span class="mv">handle</span>) &amp;&amp; isAModelElement(element)) {<br/>
            ((MDependency) <span class="mv">handle</span>).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a supplier dependency to some modelelement<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSupplierDependency(<br/>
            <span class="mv">Object <span class="mv">supplier</span></span>, <br/>
            Object <span class="mv">dependency</span>) {<br/>
        if (isAModelElement(supplier) &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        illegalArgument(supplier, dependency);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an actual argument to an action<br/>
     * @param handle the action<br/>
     * @param argument the argument<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addActualArgument(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">argument</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) <span class="mv">handle</span>).addActualArgument((MArgument) argument);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, argument);<br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * Adds an annotated element to a comment.<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addAnnotatedElement(<span class="mv">Object <span class="mv">comment</span></span>, <br/>
            Object <span class="mv">annotatedElement</span>) {<br/>
        if (comment instanceof MComment <br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        illegalArgument(comment, annotatedElement);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method adds a classifier to a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addBase(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">c</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) <span class="mv">handle</span>).addBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a Classifier to an Instance<br/>
     * @param handle Instance<br/>
     * @param classifier Classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClassifier(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">classifier</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) <span class="mv">handle</span>).addClassifier((MClassifier) classifier);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClient(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">element</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) <span class="mv">handle</span>).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a client dependency to some modelelement<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClientDependency(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">dependency</span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>)<br/>
                &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, dependency);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a TaggedValue to a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addTaggedValue(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">taggedValue</span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>) &amp;&amp; isATaggedValue(taggedValue)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).addTaggedValue((MTaggedValue) taggedValue);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, taggedValue);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes the actual Argument from an Action<br/>
     * @param handle Action<br/>
     * @param argument Argument<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeActualArgument(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">argument</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) <span class="mv">handle</span>).removeActualArgument((MArgument) argument);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, argument);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a classifier from a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeBase(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">c</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) <span class="mv">handle</span>).removeBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeClientDependency(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">dep</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) <span class="mv">handle</span>).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, dep);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove the given constraint from a given ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeConstraint(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">cons</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement &amp;&amp; <span class="mv"><span class="mv">cons</span> instanceof MConstraint</span>) {<br/>
            ((MModelElement) <span class="mv">handle</span>).removeConstraint(<span class="mv">(MConstraint) <span class="mv">cons</span></span>);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, cons);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove the given context (BehavioralFeature) from a Signal<br/>
     * @param handle Signal<br/>
     * @param context BehavioralFeature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeContext(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">context</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal<br/>
            &amp;&amp; context instanceof MBehavioralFeature) {<br/>
            ((MSignal) <span class="mv">handle</span>).removeContext((MBehavioralFeature) context);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, context);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method classifier from an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param classifier is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeClassifier(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">classifier</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) <span class="mv">handle</span>).removeClassifier((MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param feature to remove<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeFeature(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">feature</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier<br/>
                &amp;&amp; feature instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).removeFeature((MFeature) feature);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, feature);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes an extension point from a use case.<br/>
     *<br/>
     * @param uc is the use case<br/>
     * @param ep is the extension point<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeExtensionPoint(<span class="mv">Object <span class="mv">uc</span></span>, Object <span class="mv">ep</span>) {<br/>
        if (uc instanceof MUseCase<br/>
                &amp;&amp; ep instanceof MExtensionPoint) {<br/>
            ((MUseCase) uc).removeExtensionPoint((MExtensionPoint) ep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(uc, ep);<br/>
    }<br/>
<br/>
    <span class="mv">/**Removes a successor message<br/>
     * @param handle the Message that needs to loose a successor<br/>
     * @param mess the Message that is removed<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeMessage3(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">mess</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).removeMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mess);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeOwnedElement(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) <span class="mv">handle</span>).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param p is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeParameter(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">p</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; p instanceof MParameter) {<br/>
            ((MOperation) <span class="mv">handle</span>).removeParameter((MParameter) p);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, p);<br/>
    }<br/>
<br/>
    <span class="mv">/** <br/>
     * Removes a predecessor message<br/>
     * @param handle the Message that needs to loose a predecessor<br/>
     * @param message the Message that is removed<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removePredecessor(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">message</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; message instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).removePredecessor((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, message);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove a given Reception from a given Signal<br/>
     * @param handle the Signal<br/>
     * @param reception the Reception<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeReception(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">reception</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal &amp;&amp; reception instanceof MReception) {<br/>
            ((MSignal) <span class="mv">handle</span>).removeReception((MReception) reception);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, reception);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove a given subvertex from a given composite state<br/>
     * @param handle the composite state<br/>
     * @param subvertex the StateVertex<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeSubvertex(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">subvertex</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).removeSubvertex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertex);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeTaggedValue(<span class="mv">Object <span class="mv">handle</span></span>, String name) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    me.removeTaggedValue(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the base of some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param base is the base<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBase(<span class="mv">Object handle</span>, Object <span class="mv">base</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(base);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MAssociationRole<br/>
            &amp;&amp; base instanceof MAssociation) {<br/>
            ((MAssociationRole) <span class="mv">handle</span>).setBase((MAssociation) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEndRole<br/>
            &amp;&amp; base instanceof MAssociationEnd) {<br/>
            ((MAssociationEndRole) <span class="mv">handle</span>).setBase((MAssociationEnd) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtend &amp;&amp; base instanceof MUseCase) {<br/>
            ((MExtend) <span class="mv">handle</span>).setBase((MUseCase) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MInclude &amp;&amp; base instanceof MUseCase) {<br/>
            ((MInclude) <span class="mv">handle</span>).setAddition((MUseCase) base);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, base);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the baseclass of some stereotype.<br/>
     *<br/>
     * @param handle the stereotype<br/>
     * @param baseClass the baseclass<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBaseClass(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">baseClass</span>) {<br/>
        if (isAStereotype(<span class="mv">handle</span>) &amp;&amp; baseClass instanceof String) {<br/>
            ((MStereotype) <span class="mv">handle</span>).setBaseClass((String) baseClass);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, baseClass);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a body of a given Method, Constraint or Expression.<br/>
     *<br/>
     * @param handle is the method, expression<br/>
     * @param expr is the body string for the expression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBody(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">expr</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) <span class="mv">handle</span>).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        <span class="del">if (<span class="mv"><span class="mv"><span class="mv">handle</span> instanceof MConstraint</span><br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)</span>) <span class="del">{<br/>
            <span class="del"><span class="del"><span class="del">(<span class="mv">(MConstraint) <span class="mv">handle</span></span>)</span>.<span class="mv">setBody</span>(<span class="mv">(MBooleanExpression) expr</span>)</span>;</span><br/>
            <span class="mv">return;</span><br/>
        }</span></span><br/>
<br/>
        /* TODO: MVW: The next part is fooling the user of setBody()<br/>
         * in thinking that the body of the object is changed.<br/>
         * Instead, a new object is created and as a side-effect <br/>
         * the language is lost.<br/>
         * Maybe we should just copy the language?<br/>
         */<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            MExpressionEditor expressionEditor =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MExpressionEditor) UmlFactory.getFactory().getDataTypes()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .createExpressionEditor(<span class="mv">handle</span>);<br/>
            expressionEditor.setBody((String) expr);<br/>
            <span class="mv">handle</span> = (<span class="mv">Object</span>) expressionEditor.toExpression();<br/>
            // this last step creates a new MExpression<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the language of an expression.<br/>
     *<br/>
     * TODO: This operation is fooling the user<br/>
     * in thinking that the body of the object is changed.<br/>
     * Instead, a new object is created and as a side-effect the body is lost.<br/>
     * There is no other way: a MExpression can not be altered,<br/>
     * once created!<br/>
     * So, this operation should return the created object instead! <br/>
     * Or should it simply copy the body?<br/>
     *<br/>
     * @param handle is the expression<br/>
     * @param language is the lang<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLanguage(<span class="del"><span class="mv">Object</span> <span class="mv">handle</span></span>, String language) {<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            MExpression expression = (MExpression) <span class="mv">handle</span>;<br/>
            MExpressionEditor expressionEditor = (MExpressionEditor)<br/>
                UmlFactory.getFactory().getDataTypes().<br/>
                    createExpressionEditor(<span class="mv">handle</span>);<br/>
            expressionEditor.setLanguage(language);<br/>
            <span class="mv">handle</span> = expressionEditor.toExpression();<br/>
<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, language);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Gets the language attribute of an Expression.<br/>
     *<br/>
     * @param handle is the Expression of which the language is retrieved<br/>
     * @return String the language<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getLanguage(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            return ((MExpression) <span class="mv">handle</span>).getLanguage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDefaultValue(<span class="mv">Object handle</span>, Object <span class="mv">expr</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) <span class="mv">handle</span>).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the guard of a transition.<br/>
     *<br/>
     * @param handle to the transition<br/>
     * @param guard to be set. Can be null.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setGuard(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">guard</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; (guard == null || guard instanceof MGuard)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setGuard((MGuard) guard);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, guard);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Transition of a guard or effect (Action).<br/>
     * @param handle the Guard or Action<br/>
     * @param trans the Transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTransition(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">trans</span>) {<br/>
        if (trans instanceof MTransition) {<br/>
            if (<span class="mv">handle</span> instanceof MGuard) {<br/>
                ((MGuard) <span class="mv">handle</span>).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAction) {<br/>
                ((MAction) <span class="mv">handle</span>).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, trans);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the trigger event of a transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param event is the trigger event<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTrigger(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">event</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; (event == null || event instanceof MEvent)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setTrigger((MEvent) event);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, event);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the icon for a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param icon String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setIcon(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">icon</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStereotype<br/>
                &amp;&amp; (icon == null || icon instanceof String)) {<br/>
            ((MStereotype) <span class="mv">handle</span>).setIcon((String) icon);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, icon);<br/>
    }<br/>
<br/>
    <span class="mv">/** Set the ImplementationLocation of the given ElementResidence <br/>
     * to the given Component.<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setImplementationLocation(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        Object <span class="mv">component</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) <span class="mv">handle</span>).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, component);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of Include relationships for a usecase<br/>
     * @param handle UseCase<br/>
     * @param includes the collection of Include relationships <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setIncludes(<span class="mv">Object <span class="mv">handle</span></span>, <span class="del"><span class="mv">Collection</span> <span class="mv">includes</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MUseCase) {<br/>
            ((MUseCase) <span class="mv">handle</span>).setIncludes(includes);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, includes);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInitialValue(<span class="mv">Object <span class="mv">at</span></span>, Object <span class="mv">expr</span>) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(at, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/** Sets the given Instance to the given LinkEnd or AttributeLink<br/>
     * @param handle LinkEnd or AttributeLink<br/>
     * @param inst null or Instance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInstance(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">inst</span>) {<br/>
        if (inst == null || inst instanceof MInstance) {<br/>
            if (<span class="mv">handle</span> instanceof MLinkEnd) {<br/>
                ((MLinkEnd) <span class="mv">handle</span>).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
                ((MAttributeLink) <span class="mv">handle</span>).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, inst);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle is the target.<br/>
     * @param intTrans is a collection of transitions.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInternalTransitions(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        <span class="mv">Collection <span class="mv">intTrans</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            ((MState) <span class="mv">handle</span>).setInternalTransitions(intTrans);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Message<br/>
     * @param messages Collection of predecessor messages<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setMessages3(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">messages</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).setMessages3(messages);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a location of some extension point.<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @param loc is the location<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLocation(<span class="mv">Object handle</span>, String loc) {<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            ((MExtensionPoint) <span class="mv">handle</span>).setLocation(loc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * &lt;p&gt;Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/b&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/b&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;/p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setModelElementContainer(<br/>
        <span class="mv">Object handle</span>,<br/>
        Object <span class="mv">container</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) <span class="mv">handle</span>).setActivityGraph((MActivityGraph) container);<br/>
        } else if (<span class="mv">handle</span> instanceof MModelElement <br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) <span class="mv">handle</span>);<br/>
        } else if (<br/>
            <span class="mv"><span class="mv">handle</span> instanceof MConstraint</span><br/>
                &amp;&amp; container instanceof MStereotype) <span class="del">{<br/>
            <span class="del"><span class="mv">MConstraint</span> <span class="del"><span class="mv">c</span> = <span class="del">(<span class="mv">MConstraint</span>) <span class="mv">handle</span></span></span>;</span><br/>
            <span class="mv">c.setConstrainedElement2((MStereotype) container);</span><br/>
        }</span> else if (<br/>
            <span class="mv">handle</span> instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) <span class="mv">handle</span>).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) <span class="mv">handle</span>;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setInstance((MInstance) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) <span class="mv">handle</span>).setInteraction((MInteraction) container);<br/>
        } else if (<span class="mv">handle</span> instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) <span class="mv">handle</span>).setLink((MLink) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) <span class="mv">handle</span>).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) <span class="mv">handle</span>).setPackage((MPackage) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) <span class="mv">handle</span>).setState((MState) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) <span class="mv">handle</span>).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) <span class="mv">handle</span>).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) <span class="mv">handle</span>).setTransition((MTransition) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) <span class="mv">handle</span>).setTransition((MTransition) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setNamespace((MNamespace) container);<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    illegalArgument(<span class="mv">handle</span>, container);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setMultiplicity(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">arg</span>) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg instanceof MMultiplicity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MAssociationRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationRole) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MClassifierRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierRole) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, arg);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the classifiers of some instance.<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param v is the classifier vector<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setClassifiers(<span class="mv">Object <span class="mv">handle</span></span>, Vector v) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            ((MInstance) <span class="mv">handle</span>).setClassifiers(v);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setName(<span class="mv">Object handle</span>, String name) {<br/>
        if ((<span class="mv">handle</span> instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setName(name);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, name);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNamespace(<span class="mv">Object handle</span>, Object <span class="mv">ns</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ns);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNavigable(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/** Set the value of a given object<br/>
     * <br/>
     * @param handle the Object of which the value will be set<br/>
     * @param value Object <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setValue(<span class="mv">Object handle</span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MArgument) {<br/>
            ((MArgument) <span class="mv">handle</span>).setValue((MExpression) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setValue((MInstance) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtension) {<br/>
            ((MExtension) <span class="mv">handle</span>).setValue(value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setValue((String) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setVisibility(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">visibility</span>) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
                ((MModelElement) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MElementResidence) {<br/>
                ((MElementResidence) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MElementImport) {<br/>
                ((MElementImport) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, visibility);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param v is the visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setVisibility(<span class="mv">Object <span class="mv">handle</span></span>, short v) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
<br/>
            if (v == ACC_PRIVATE) {<br/>
                me.setVisibility(MVisibilityKind.PRIVATE);<br/>
            } else if (v == ACC_PROTECTED) {<br/>
                me.setVisibility(MVisibilityKind.PROTECTED);<br/>
            } else if (v == ACC_PUBLIC) {<br/>
                me.setVisibility(MVisibilityKind.PUBLIC);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the NodeInstance of a ComponentInstance<br/>
     * @param handle ComponentInstance<br/>
     * @param nodeInstance NodeInstance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNodeInstance(<span class="mv">Object handle</span>, Object <span class="mv">nodeInstance</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; nodeInstance instanceof MNodeInstance) {<br/>
            ((MComponentInstance) <span class="mv">handle</span>).setNodeInstance(<br/>
                (MNodeInstance) nodeInstance);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, nodeInstance);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the owner of a Feature<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwner(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">owner</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) <span class="mv">handle</span>).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, owner);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Operation of a CallAction or CallEvent<br/>
     * @param handle CallAction or CallEvent<br/>
     * @param operation Operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOperation(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">operation</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCallAction) {<br/>
            ((MCallAction) <span class="mv">handle</span>).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallEvent) {<br/>
            ((MCallEvent) <span class="mv">handle</span>).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, operation);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the OrderingKind of a given AssociationEnd <br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOrdering(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">ok</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ok);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the owner scope of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param os is the owner scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwnerScope(<span class="mv">Object <span class="mv">handle</span></span>, short os) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            if (os == CLASSIFIER_SCOPE) {<br/>
                ((MFeature) <span class="mv">handle</span>).setOwnerScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (os == INSTANCE_SCOPE) {<br/>
                ((MFeature) <span class="mv">handle</span>).setOwnerScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwnerScope(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">os</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) <span class="mv">handle</span>).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, os);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param parameters is a Collection of extensionPoints<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setParameters(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">parameters</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) <span class="mv">handle</span>).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            ((MClassifier) <span class="mv">handle</span>).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) <span class="mv">handle</span>).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameters);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the target of some action or transition.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param element the target of the model elemnet<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTarget(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">element</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; element instanceof MObjectSetExpression) {<br/>
            ((MAction) <span class="mv">handle</span>).setTarget((MObjectSetExpression) element);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; element instanceof MStateVertex) {<br/>
            ((MTransition) <span class="mv">handle</span>).setTarget((MStateVertex) element);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
    <span class="mv">/**<br/>
     * Sets the state of an internal transition.<br/>
     *<br/>
     * @param handle the internal transition<br/>
     * @param element the state that contains this transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setState(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">element</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; element instanceof MState) {<br/>
            ((MTransition) <span class="mv">handle</span>).setState((MState) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTargetScope(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">scopeKind</span>) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, scopeKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the target scope of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param ts is the target scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTargetScope(<span class="mv">Object <span class="mv">handle</span></span>, short ts) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd ae = (MAssociationEnd) <span class="mv">handle</span>;<br/>
<br/>
            if (ts == CLASSIFIER_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (ts == INSTANCE_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Instance<br/>
     * @param c ComponentInstance or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setComponentInstance(<span class="mv">Object handle</span>, Object <span class="mv">c</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; (c == null || c instanceof MComponentInstance)) {<br/>
            ((MInstance) <span class="mv">handle</span>).setComponentInstance((MComponentInstance) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the communicationLink between a link c and a stimulus handle.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param c the link<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setCommunicationLink(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">c</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; c instanceof MLink) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setCommunicationLink((MLink) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param c is the concurrency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurrency(<span class="mv">Object <span class="mv">handle</span></span>, short c) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            MOperation oper = (MOperation) <span class="mv">handle</span>;<br/>
<br/>
            if (c == GUARDED) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.GUARDED);<br/>
                return;<br/>
            } else if (c == SEQUENTIAL) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.SEQUENTIAL);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurrency(<br/>
        <span class="mv">Object handle</span>,<br/>
        Object <span class="mv">concurrencyKind</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) <span class="mv">handle</span>).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, concurrencyKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Makes a Composite State concurrent<br/>
     * @param handle the CompositState<br/>
     * @param concurrent boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurent(<span class="mv">Object <span class="mv">handle</span></span>, boolean concurrent) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).setConcurent(concurrent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the condition of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @param booleanExpression is the condition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setCondition(<span class="mv">Object handle</span>, Object <span class="mv">booleanExpression</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MExtend<br/>
            &amp;&amp; booleanExpression instanceof MBooleanExpression) {<br/>
            ((MExtend) <span class="mv">handle</span>).setCondition(<br/>
                (MBooleanExpression) booleanExpression);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, booleanExpression);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the container of a statevertex.<br/>
     *<br/>
     * @param handle is the stateVertex<br/>
     * @param compositeState is the container. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setContainer(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">compositeState</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStateVertex<br/>
            &amp;&amp; (compositeState == null<br/>
                || compositeState instanceof MCompositeState)) {<br/>
            ((MStateVertex) <span class="mv">handle</span>).setContainer(<br/>
                (MCompositeState) compositeState);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, compositeState);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the contexts for a Signal<br/>
     * @param handle the Signal<br/>
     * @param c the collection of contexts<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setContexts(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            ((MSignal) <span class="mv">handle</span>).setContexts(c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the dispatch action for some stimulus.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param value the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDispatchAction(<span class="mv">Object handle</span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setDispatchAction((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the do activity of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value the activity. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDoActivity(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setDoActivity((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param value is the effect. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setEffect(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setEffect((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the entry action of some state.<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setEntry(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setEntry((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the exit action of some state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExit(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setExit((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the Expression of a Guard or ChangeEvent<br/>
     * @param handle Guard or ChangeEvent<br/>
     * @param value BooleanExpression or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExpression(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGuard<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
            ((MGuard) <span class="mv">handle</span>).setExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MChangeEvent<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeEvent ce = (MChangeEvent) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ce.setChangeExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the time-expression for a TimeEvent. <br/>
     * @param handle Object (MTimeEvent)<br/>
     * @param value Object (MTimeExpression)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setWhen(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">value</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTimeEvent<br/>
            &amp;&amp; (value == null || value instanceof MTimeExpression)) {<br/>
            ((MTimeEvent) <span class="mv">handle</span>).setWhen((MTimeExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the extension of a usecase<br/>
     * @param handle Extend<br/>
     * @param ext UseCase or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExtension(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">ext</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(ext);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MExtend<br/>
            &amp;&amp; (ext == null || ext instanceof MUseCase)) {<br/>
            ((MExtend) <span class="mv">handle</span>).setExtension((MUseCase) ext);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ext);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param extensionPoints is the extension points<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExtensionPoints(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        <span class="mv">Collection <span class="mv">extensionPoints</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MUseCase &amp;&amp; extensionPoints instanceof List) {<br/>
            ((MUseCase) <span class="mv">handle</span>).setExtensionPoints(extensionPoints);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extensionPoints);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the list of features<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setFeatures(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">features</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier<br/>
            &amp;&amp; features instanceof List) {<br/>
            ((MClassifier) <span class="mv">handle</span>).setFeatures((List) features);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAggregation(<span class="mv">Object handle</span>, Object <span class="mv">aggregationKind</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, aggregationKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAssociation(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">association</span>) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MLink) {<br/>
                ((MLink) <span class="mv">handle</span>).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, association);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the Changeability of a StructuralFeature or AssociationEnd<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChangeability(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">ck</span>) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ck);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChangeable(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            }<br/>
            else {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
            }<br/>
        } else if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (flag)<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            else<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the child for a generalization<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChild(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">child</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, child);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if of some model element is abstract.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAbstract(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MGeneralizableElement) <span class="mv">handle</span>).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MOperation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MOperation) <span class="mv">handle</span>).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MReception) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MReception) <span class="mv">handle</span>).setAbstarct(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the addition to an include.<br/>
     * There is a bug in NSUML that reverses additions and bases for includes.<br/>
     * @param handle Include <br/>
     * @param useCase UseCase<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAddition(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">useCase</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(useCase);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MInclude) {<br/>
            ((MInclude) <span class="mv">handle</span>).setBase((MUseCase) useCase);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the action to a message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @param action is the action<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAction(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">action</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; (action == null || action instanceof MAction)) {<br/>
            ((MMessage) <span class="mv">handle</span>).setAction((MAction) action);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, action);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Activator message of an message<br/>
     * @param handle Message<br/>
     * @param message Message<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setActivator(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">message</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; (message == null || message instanceof MMessage)) {<br/>
            ((MMessage) <span class="mv">handle</span>).setActivator((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, message);<br/>
    }<br/>
<br/>
    <span class="mv">/**Makes a Class active<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setActive(<span class="mv">Object <span class="mv">handle</span></span>, boolean active) {<br/>
        if (<span class="mv">handle</span> instanceof MClass) {<br/>
            ((MClass) <span class="mv">handle</span>).setActive(active);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the asynchronous property of an action.<br/>
     *<br/>
     * @param handle the action<br/>
     * @param value the value to alter the asynchronous property to<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAsynchronous(<span class="mv">Object handle</span>, boolean value) {<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            ((MAction) <span class="mv">handle</span>).setAsynchronous(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLeaf(<span class="mv">Object handle</span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            ((MOperation) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRaisedSignals(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        <span class="mv">Collection <span class="mv">raisedSignals</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the receiver of some model element.<br/>
     * @param handle model element<br/>
     * @param receiver the receiver<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setReceiver(<span class="mv">Object handle</span>, Object <span class="mv">receiver</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; receiver instanceof MClassifierRole) {<br/>
            ((MMessage) <span class="mv">handle</span>).setReceiver((MClassifierRole) receiver);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; receiver instanceof MInstance) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setReceiver((MInstance) receiver);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, receiver);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the recurrence of an Action<br/>
     * @param handle Action<br/>
     * @param expr IterationExpression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRecurrence(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">expr</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; expr instanceof MIterationExpression) {<br/>
            ((MAction) <span class="mv">handle</span>).setRecurrence((MIterationExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the represented classifier of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param classifier is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRepresentedClassifier(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        Object <span class="mv">classifier</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration<br/>
            &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MCollaboration) <span class="mv">handle</span>).setRepresentedClassifier(<br/>
                (MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the represented operation of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param operation is the operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRepresentedOperation(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        Object <span class="mv">operation</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration<br/>
            &amp;&amp; operation instanceof MOperation) {<br/>
            ((MCollaboration) <span class="mv">handle</span>).setRepresentedOperation(<br/>
                (MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, operation);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setResident(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">resident</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) <span class="mv">handle</span>).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, resident);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setResidents(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">residents</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNodeInstance) {<br/>
            ((MNodeInstance) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance) {<br/>
            ((MComponentInstance) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MNode) {<br/>
            ((MNode) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRoot(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            ((MOperation) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Expression (script) for an Action<br/>
     * @param handle Action<br/>
     * @param expr the script (ActionExpression)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setScript(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">expr</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; (expr == null || expr instanceof MActionExpression)) {<br/>
            ((MAction) <span class="mv">handle</span>).setScript((MActionExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the sender of some model element.&lt;p&gt;<br/>
     *<br/>
     * @param handle model element<br/>
     * @param sender the sender<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSender(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">sender</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; sender instanceof MClassifierRole) {<br/>
            ((MMessage) <span class="mv">handle</span>).setSender((MClassifierRole) sender);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; sender instanceof MInstance) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setSender((MInstance) sender);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, sender);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Signal<br/>
     * @param handle SendAction or Reception or SignalEvent<br/>
     * @param signal Signal or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSignal(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">signal</span>) {<br/>
        if (signal == null || signal instanceof MSignal) {<br/>
            if (<span class="mv">handle</span> instanceof MSendAction) {<br/>
                ((MSendAction) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MReception) {<br/>
                ((MReception) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MSignalEvent) {<br/>
                ((MSignalEvent) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, signal);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the source state of some message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param state the source state<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSource(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">state</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MTransition &amp;&amp; state instanceof MStateVertex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MTransition) <span class="mv">handle</span>).setSource((MStateVertex) state);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, state);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSources(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">specifications</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFlow) {<br/>
            ((MFlow) <span class="mv">handle</span>).setSources(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle a reception<br/>
     * @param specification the specification<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecification(<span class="mv">Object handle</span>, String specification) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Specification flag for a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecification(<span class="mv">Object handle</span>, boolean specification) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecifications(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">specifications</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKind(<span class="mv">Object handle</span>, Object <span class="mv">kind</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) <span class="mv">handle</span>).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) <span class="mv">handle</span>).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, kind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToIn(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.IN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToInOut(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.INOUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToOut(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.OUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToReturn(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.RETURN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setParent(<span class="mv">Object handle</span>, Object <span class="mv">parent</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setParent(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parent);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Generalization <br/>
     * @param pt Classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setPowertype(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">pt</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization &amp;&amp; pt instanceof MClassifier) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, pt);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of predecessing messages<br/>
     * @param handle Message<br/>
     * @param predecessors Collection of Messages<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setPredecessors(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        <span class="mv">Collection <span class="mv">predecessors</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).setPredecessors(predecessors);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, predecessors);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setQuery(<span class="mv">Object handle</span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setQuery(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setType(<span class="mv">Object handle</span>, Object <span class="mv">type</span>) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MObjectFlowState) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MClassifierInState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierInState) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MParameter) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, type);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the UUID of this element<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setUUID(<span class="mv">Object <span class="mv">handle</span></span>, String uuid) {<br/>
        if (isABase(<span class="mv">handle</span>)) {<br/>
            ((MBase) <span class="mv">handle</span>).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Tag of a TaggedValue <br/>
     * @param handle TaggedValue<br/>
     * @param tag String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTag(<span class="mv">Object handle</span>, Object <span class="mv">tag</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue &amp;&amp; tag instanceof String) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setTag((String) tag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, tag);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTaggedValue(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        String tag,<br/>
        String value) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MModelElement) <span class="mv">handle</span>).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the TaggedValues of a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTaggedValues(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">taggedValues</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a value of some taggedValue.<br/>
     *<br/>
     * @param handle is the tagged value<br/>
     * @param value is the value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setValueOfTag(<span class="mv">Object handle</span>, String value) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setValue(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a state machine of some state or transition.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @param stm is the state machine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setStateMachine(<span class="mv">Object handle</span>, Object <span class="mv">stm</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MState) <span class="mv">handle</span>).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stm);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * &lt;p&gt;TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setStereotype(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">stereo</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            if (stereo instanceof MStereotype<br/>
                &amp;&amp; me.getModel() != ((MStereotype) stereo).getModel()) {<br/>
                ((MStereotype) stereo).setNamespace(me.getModel());<br/>
            }<br/>
            if (stereo == null || stereo instanceof MStereotype) {<br/>
                me.setStereotype((MStereotype) stereo);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stereo);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of substates for a CompositeState<br/>
     * @param handle CompositeState<br/>
     * @param subvertices collection of sub-StateVertexes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSubvertices(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">subvertices</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).setSubvertices(subvertices);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertices);<br/>
    }<br/>
<br/>
    <span class="mv">/** Add an End to a connection<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addConnection(<span class="mv">Object handle</span>, Object <span class="mv">connection</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) <span class="mv">handle</span>).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) <span class="mv">handle</span>).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, connection);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addConstraint(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">mc</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement &amp;&amp; <span class="del"><span class="mv">mc</span> instanceof <span class="mv">MConstraint</span></span>) {<br/>
            ((MModelElement) <span class="mv">handle</span>).addConstraint(<span class="mv">(MConstraint) <span class="mv">mc</span></span>);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mc);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addDeploymentLocation(<span class="mv">Object <span class="mv">handle</span></span>, Object <span class="mv">node</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) <span class="mv">handle</span>).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, node);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add an extended element to a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param extendedElement ExtensionPoint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addExtendedElement(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        Object <span class="mv">extendedElement</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStereotype<br/>
            &amp;&amp; extendedElement instanceof MExtensionPoint) {<br/>
            ((MStereotype) <span class="mv">handle</span>).addExtendedElement(<br/>
                (MModelElement) extendedElement);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extendedElement);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an extension point to some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param extensionPoint is the extension point<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addExtensionPoint(<br/>
        <span class="mv">Object <span class="mv">handle</span></span>,<br/>
        Object <span class="mv">extensionPoint</span>) {<br/>
        if (extensionPoint instanceof MExtensionPoint) {<br/>
            if (<span class="mv">handle</span> instanceof MUseCase) {<br/>
                ((MUseCase) <span class="mv">handle</span>).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MExtend) {<br/>
                ((MExtend) <span class="mv">handle</span>).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extensionPoint);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the name of the UML Model class, e.g. it it will return<br/>
     * Class for an object of type MClass.<br/>
     *<br/>
     * @param handle MBase<br/>
     * @return classname of modelelement<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getUMLClassName(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MBase) {<br/>
            return ((MBase) <span class="mv">handle</span>).getUMLClassName();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Convenience methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Tests if an element is marked removed.<br/>
     *<br/>
     * &lt;p&gt;Model specific: NSUML is littered with calls to a function also<br/>
     * named checkExists. That function is however a NOP (it is empty in<br/>
     * MBaseImpl, and it is final so it cannot be overridden anywhere).<br/>
     *<br/>
     * @param obj the element to test.<br/>
     * @throws IllegalStateException iff obj is marked removed.<br/>
     */</span><br/>
    private <span class="mv">static</span> void checkExists(<span class="mv">Object <span class="mv">obj</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((obj instanceof MBase) &amp;&amp; ((MBase) obj).isRemoved()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalStateException("Operation on a removed object ["<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    + obj + "]");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * The empty set.<br/>
     *<br/>
     * @return an empty collection.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Collection</span> emptyCollection() {<br/>
        return Collections.EMPTY_LIST;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get a string representation of the class type. <br/>
     * Purpose: documenting an exception<br/>
     * @param handle the Class or null<br/>
     * @return String <br/>
     */</span><br/>
    protected <span class="mv">static</span> String getClassNull(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[null]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[" + <span class="mv">handle</span> + "/" + <span class="mv">handle</span>.getClass() + "]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     */</span><br/>
    private <span class="mv">static</span> void illegalArgument(<span class="mv">Object <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg));<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return a boolean for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> boolean illegalArgumentBoolean(<span class="mv">Object <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Object for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Object</span> illegalArgumentObject(<span class="del"><span class="mv">Object</span> <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="del"><span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Collection for use in the return statement.<br/>
     */</span><br/>
    <span class="mv">private</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">illegalArgumentCollection</span>(<span class="mv">Object <span class="mv">arg</span></span>) <span class="mv">{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return String for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> String illegalArgumentString(<span class="mv">Object <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Object</span> illegalArgument(<span class="del"><span class="mv">Object</span> <span class="mv">arg1</span></span>, Object <span class="mv">arg2</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg1) + " or "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg2));<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     * @return Object for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Object</span> illegalArgumentObject(<span class="del"><span class="mv">Object</span> <span class="mv">arg1</span></span>, Object <span class="mv">arg2</span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg1, arg2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_ModelFacade_1.210.java</h1>
<div class="code">
<div class="id">
// $Id: ModelFacade.java,v 1.210 2004-08-27 09:48:12 bobtarling Exp $<br/>
// Copyright (c) 2003-2004 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.Collections;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.argouml.model.uml.UmlFactory;<br/>
import org.argouml.model.uml.foundation.core.CoreHelper;<br/>
import org.argouml.model.uml.foundation.extensionmechanisms.ExtensionMechanismsHelper;<br/>
import org.argouml.uml.diagram.static_structure.ui.CommentEdge;<br/>
import org.tigris.gef.base.Diagram;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.MElementListener;<br/>
import ru.novosoft.uml.MExtension;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActionState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MCallState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MSubactivityState;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MActionSequence;<br/>
import ru.novosoft.uml.behavior.common_behavior.MArgument;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCallAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MCreateAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDataValue;<br/>
import ru.novosoft.uml.behavior.common_behavior.MDestroyAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MException;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MObject;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReturnAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSendAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.common_behavior.MStimulus;<br/>
import ru.novosoft.uml.behavior.common_behavior.MTerminateAction;<br/>
import ru.novosoft.uml.behavior.state_machines.MCallEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MChangeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MFinalState;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MSignalEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateImpl;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MSubmachineState;<br/>
import ru.novosoft.uml.behavior.state_machines.MTimeEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtensionPoint;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationClass;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElement;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MPermission;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.core.MUsage;<br/>
import ru.novosoft.uml.foundation.data_types.MActionExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MExpressionEditor;<br/>
import ru.novosoft.uml.foundation.data_types.MIterationExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMessageDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicityRange;<br/>
import ru.novosoft.uml.foundation.data_types.MObjectSetExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MOperationDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MTimeExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MModel;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
import ru.novosoft.uml.model_management.MSubsystem;<br/>
<br/>
/**<br/>
 * Facade object for the Model component in ArgoUML.&lt;p&gt;<br/>
 *<br/>
 * The purpose of this Facade object is to allow for decoupling other modules<br/>
 * from the insides of the model. For this purpose all of the methods in this<br/>
 * class give away and accept handles (of type java.lang.Object) to the<br/>
 * objects within the model.&lt;p&gt;<br/>
 *<br/>
 * This is just getters and recognizers. This is because the Model<br/>
 * component has an extremely complicated internal data structure<br/>
 * with lots of internal dependencies. To manipulate these there is<br/>
 * a whole set of factories and helpers within the Model that is to<br/>
 * be used but to use them you need knowledge of the internals of<br/>
 * the Model, specifically the NS-UML objects.&lt;p&gt;<br/>
 *<br/>
 * All methods in this facade are static.&lt;p&gt;<br/>
 *<br/>
 * Signature for all recognizers in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static boolean isA&lt;TYPE&gt;(Object handle)<br/>
 * &lt;li&gt;public static boolean is&lt;PROPERTY&gt;(Object handle)<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * Signature for all getters in this Facade:<br/>
 * &lt;ul&gt;<br/>
 * &lt;li&gt;public static Object get&lt;TYPE&gt;(Object handle) - 1..1<br/>
 * &lt;li&gt;public static Iterator get&lt;TYPES&gt;(Object handle) - 0..*<br/>
 * &lt;li&gt;public static String getName(Object handle) - Name<br/>
 * &lt;/ul&gt;<br/>
 *<br/>
 * @stereotype utility<br/>
 * @author Linus Tolke<br/>
 */<br/>
public class ModelFacade {<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // constants<br/>
<br/>
    // TODO: deprecate all of these constants in favor of a separate declaration<br/>
<br/>
    public static final short ACC_PUBLIC = 1;<br/>
    public static final short ACC_PRIVATE = 2;<br/>
    public static final short ACC_PROTECTED = 3;<br/>
<br/>
    public static final short CLASSIFIER_SCOPE = 1;<br/>
    public static final short INSTANCE_SCOPE = 2;<br/>
<br/>
    public static final short GUARDED = 1;<br/>
    public static final short SEQUENTIAL = 2;<br/>
<br/>
    // Types of line<br/>
    public static final Object ABSTRACTION = MAbstraction.class;<br/>
    public static final Object ASSOCIATION = MAssociation.class;<br/>
    public static final Object ASSOCIATION_CLASS = MAssociationClass.class;<br/>
    public static final Object ASSOCIATION_ROLE = MAssociationRole.class;<br/>
    public static final Object COLLABORATION = MCollaboration.class;<br/>
    public static final Object DEPENDENCY = MDependency.class;<br/>
    public static final Object EXTEND = MExtend.class;<br/>
    public static final Object GENERALIZATION = MGeneralization.class;<br/>
    public static final Object INCLUDE = MInclude.class;<br/>
    public static final Object LINK = MLink.class;<br/>
    public static final Object MESSAGE = MMessage.class;<br/>
    public static final Object PERMISSION = MPermission.class;<br/>
    public static final Object SIGNAL = MSignal.class;<br/>
    public static final Object USAGE = MUsage.class;<br/>
    public static final Object TRANSITION = MTransition.class;<br/>
<br/>
    // Types of node<br/>
    public static final Object ACTOR = MActor.class;<br/>
    public static final Object CLASS = MClass.class;<br/>
    public static final Object CLASSIFIER = MClassifier.class;<br/>
    public static final Object CLASSIFIER_ROLE = MClassifierRole.class;<br/>
    public static final Object COMMENT = MComment.class;<br/>
    public static final Object COMPONENT = MComponent.class;<br/>
    public static final Object COMPONENT_INSTANCE = MComponentInstance.class;<br/>
    public static final Object EXCEPTION = MException.class;<br/>
    public static final Object INSTANCE = MInstance.class;<br/>
    public static final Object INTERFACE = MInterface.class;<br/>
    public static final Object NODE = MNode.class;<br/>
    public static final Object NODE_INSTANCE = MNodeInstance.class;<br/>
    public static final Object OBJECT = MObject.class;<br/>
    public static final Object PACKAGE = MPackage.class;<br/>
    public static final Object MODEL = MModel.class;<br/>
    public static final Object SUBSYSTEM = MSubsystem.class;<br/>
    public static final Object STATE = MState.class;<br/>
    public static final Object STATEIMPL = MStateImpl.class;<br/>
    public static final Object COMPOSITESTATE = MCompositeState.class;<br/>
    public static final Object STATEVERTEX = MStateVertex.class;<br/>
    public static final Object PSEUDOSTATE = MPseudostate.class;<br/>
    public static final Object FINALSTATE = MFinalState.class;<br/>
    public static final Object USE_CASE = MUseCase.class;<br/>
    public static final Object CALLSTATE = MCallState.class;<br/>
    public static final Object OBJECTFLOWSTATE = MObjectFlowState.class;<br/>
    public static final Object SUBACTIVITYSTATE = MSubactivityState.class;<br/>
<br/>
    // Invisible model elements<br/>
    public static final Object ACTION = MAction.class;<br/>
    public static final Object ACTION_EXPRESSION = MActionExpression.class;<br/>
    public static final Object ACTION_STATE = MActionState.class;<br/>
    public static final Object ASSOCIATION_END = MAssociationEnd.class;<br/>
    public static final Object ASSOCIATION_END_ROLE = MAssociationEndRole.class;<br/>
    public static final Object CALL_ACTION = MCallAction.class;<br/>
    public static final Object CALLCONCURRENCYKIND = MCallConcurrencyKind.class;<br/>
    public static final Object CREATE_ACTION = MCreateAction.class;<br/>
    public static final Object DESTROY_ACTION = MDestroyAction.class;<br/>
    public static final Object TERMINATE_ACTION = MTerminateAction.class;<br/>
    public static final Object NAMESPACE = MNamespace.class;<br/>
    public static final Object RECEPTION = MReception.class;<br/>
    public static final Object RETURN_ACTION = MReturnAction.class;<br/>
    public static final Object SCOPEKIND = MScopeKind.class;<br/>
    public static final Object SEND_ACTION = MSendAction.class;<br/>
    public static final Object STEREOTYPE = MStereotype.class;<br/>
    public static final Object PARTITION = MPartition.class;<br/>
    public static final Object PARAMETER = MParameter.class;<br/>
    public static final Object PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.class;<br/>
    public static final Object GENERALAIZABLE_ELEMENT =<br/>
        MGeneralizableElement.class;<br/>
    public static final Object DATATYPE = MDataType.class;<br/>
    public static final Object STATEMACHINE = MStateMachine.class;<br/>
<br/>
    public static final Object ATTRIBUTE = MAttribute.class;<br/>
    public static final Object OPERATION = MOperation.class;<br/>
<br/>
    public static final Object MULTIPLICITY = MMultiplicity.class;<br/>
<br/>
    public static final Object VISIBILITYKIND = MVisibilityKind.class;<br/>
<br/>
    public static final Object MODELELEMENT = MModelElement.class;<br/>
    public static final Object STIMULUS = MStimulus.class;<br/>
<br/>
    public static final Object AGGREGATIONKIND = MAggregationKind.class;<br/>
    public static final Object BOOLEAN_EXPRESSION = MBooleanExpression.class;<br/>
    public static final Object GUARD = MGuard.class;<br/>
    public static final Object EVENT = MEvent.class;<br/>
<br/>
    public static final Object ADD_ONLY_CHANGEABLEKIND =<br/>
        MChangeableKind.ADD_ONLY;<br/>
    public static final Object CHANGEABLE_CHANGEABLEKIND =<br/>
        MChangeableKind.CHANGEABLE;<br/>
    public static final Object FROZEN_CHANGEABLEKIND = MChangeableKind.FROZEN;<br/>
<br/>
    public static final Object CONCURRENT_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.CONCURRENT;<br/>
<br/>
    public static final Object GUARDED_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.GUARDED;<br/>
<br/>
    public static final Object SEQUENTIAL_CONCURRENCYKIND =<br/>
        MCallConcurrencyKind.SEQUENTIAL;<br/>
<br/>
    public static final Object PSEUDOSTATEKIND = MPseudostateKind.class;<br/>
    public static final Object INITIAL_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.INITIAL;<br/>
    public static final Object DEEPHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.DEEP_HISTORY;<br/>
    public static final Object SHALLOWHISTORY_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.SHALLOW_HISTORY;<br/>
    public static final Object FORK_PSEUDOSTATEKIND = MPseudostateKind.FORK;<br/>
    public static final Object JOIN_PSEUDOSTATEKIND = MPseudostateKind.JOIN;<br/>
    public static final Object JUNCTION_PSEUDOSTATEKIND =<br/>
        MPseudostateKind.JUNCTION;<br/>
    public static final Object BRANCH_PSEUDOSTATEKIND = MPseudostateKind.BRANCH;<br/>
<br/>
    public static final Object PUBLIC_VISIBILITYKIND = MVisibilityKind.PUBLIC;<br/>
    public static final Object PRIVATE_VISIBILITYKIND = MVisibilityKind.PRIVATE;<br/>
    public static final Object PROTECTED_VISIBILITYKIND =<br/>
        MVisibilityKind.PROTECTED;<br/>
<br/>
    public static final Object AGGREGATE_AGGREGATIONKIND =<br/>
        MAggregationKind.AGGREGATE;<br/>
    public static final Object COMPOSITE_AGGREGATIONKIND =<br/>
        MAggregationKind.COMPOSITE;<br/>
    public static final Object NONE_AGGREGATIONKIND = MAggregationKind.NONE;<br/>
<br/>
    public static final Object ORDERED_ORDERINGKIND = MOrderingKind.ORDERED;<br/>
    public static final Object UNORDERED_ORDERINGKIND = MOrderingKind.UNORDERED;<br/>
    public static final Object SORTED_ORDERINGKIND = MOrderingKind.SORTED;<br/>
<br/>
    public static final Object M1_1_MULTIPLICITY = MMultiplicity.M1_1;<br/>
    public static final Object M0_1_MULTIPLICITY = MMultiplicity.M0_1;<br/>
    public static final Object M0_N_MULTIPLICITY = MMultiplicity.M0_N;<br/>
    public static final Object M1_N_MULTIPLICITY = MMultiplicity.M1_N;<br/>
<br/>
    public static final Object CLASSIFIER_SCOPEKIND = MScopeKind.CLASSIFIER;<br/>
    public static final Object INSTANCE_SCOPEKIND = MScopeKind.INSTANCE;<br/>
<br/>
    public static final Object INOUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.INOUT;<br/>
<br/>
    public static final Object IN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.IN;<br/>
<br/>
    public static final Object OUT_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.OUT;<br/>
<br/>
    public static final Object RETURN_PARAMETERDIRECTIONKIND =<br/>
        MParameterDirectionKind.RETURN;<br/>
<br/>
<br/>
    /**<br/>
     * This tag is set on elements that are generated by reference when<br/>
     * importing.<br/>
     * If it is set, then the critics could ignore those objects if they want.<br/>
     */<br/>
    public static final String GENERATED_TAG = "GeneratedFromImport";<br/>
<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Object Creation methods<br/>
<br/>
    /**<br/>
     * Create a model object from the implementation.&lt;P&gt;<br/>
     *<br/>
     * This will allow abstraction of the create mechanism at a single point.<br/>
     *<br/>
     * TODO: Document the intention of this function.<br/>
     * It is not used anywhere in ArgoUML. <br/>
     * BTW: Does it work? I (MVW) once did a test, and it didn't.<br/>
     *<br/>
     * @param entity Class to create -<br/>
     * must implement {@link org.argouml.model.UmlModelEntity}<br/>
     * @return the created object or null if it cannot create the class.<br/>
     */<br/>
    public static Object create(ModelEntity entity) {<br/>
        if (entity instanceof UmlModelEntity) {<br/>
            return UmlFactory.getFactory().create((UmlModelEntity) entity);<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Abstraction.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Abstraction<br/>
     */<br/>
    public static boolean isAAbstraction(Object handle) {<br/>
        return handle instanceof MAbstraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action<br/>
     */<br/>
    public static boolean isAAction(Object handle) {<br/>
        return handle instanceof MAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionExpression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ActionExpression<br/>
     */<br/>
    public static boolean isAActionExpression(Object handle) {<br/>
        return handle instanceof MActionExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ActionSequence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an action sequence<br/>
     */<br/>
    public static boolean isAActionSequence(Object handle) {<br/>
        return handle instanceof MActionSequence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Action state<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Action state<br/>
     */<br/>
    public static boolean isAActionState(Object handle) {<br/>
        return handle instanceof MActionState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an call state<br/>
     */<br/>
    public static boolean isACallState(Object handle) {<br/>
        return handle instanceof MCallState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ObjectFlowState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an objectflow state<br/>
     */<br/>
    public static boolean isAObjectFlowState(Object handle) {<br/>
        return handle instanceof MObjectFlowState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SubactivityState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an subactivity state<br/>
     */<br/>
    public static boolean isASubactivityState(Object handle) {<br/>
        return handle instanceof MSubactivityState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Actor<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Actor<br/>
     */<br/>
    public static boolean isAActor(Object handle) {<br/>
        return handle instanceof MActor;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AggregationKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AggregationKind<br/>
     */<br/>
    public static boolean isAAggregationKind(Object handle) {<br/>
        return handle instanceof MAggregationKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Association.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Association<br/>
     */<br/>
    public static boolean isAAssociation(Object handle) {<br/>
        return handle instanceof MAssociation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEnd.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEnd<br/>
     */<br/>
    public static boolean isAAssociationEnd(Object handle) {<br/>
        return handle instanceof MAssociationEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationRole<br/>
     */<br/>
    public static boolean isAAssociationRole(Object handle) {<br/>
        return handle instanceof MAssociationRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for AssociationEndRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an AssociationEndRole<br/>
     */<br/>
    public static boolean isAAssociationEndRole(Object handle) {<br/>
        return handle instanceof MAssociationEndRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Attribute<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Attribute<br/>
     */<br/>
    public static boolean isAAttribute(Object handle) {<br/>
        return handle instanceof MAttribute;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for asynchronisity of an action<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the argument is asynchronous<br/>
     */<br/>
    public static boolean isAsynchronous(Object handle) {<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).isAsynchronous();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for abstract classes and operations.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is abstract.<br/>
     */<br/>
    public static boolean isAbstract(Object handle) {<br/>
        if (handle instanceof MOperation)<br/>
            return ((MOperation) handle).isAbstract();<br/>
        if (handle instanceof MGeneralizableElement)<br/>
            return ((MGeneralizableElement) handle).isAbstract();<br/>
        if (handle instanceof MAssociation)<br/>
            return ((MAssociation) handle).isAbstract();<br/>
        // isAbstarct() is not a typo! mistake in nsuml!<br/>
        if (handle instanceof MReception)<br/>
            return ((MReception) handle).isAbstarct();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for ActivityGraph<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is ActivityGraph.<br/>
     */<br/>
    public static boolean isAActivityGraph(Object handle) {<br/>
        return handle instanceof MActivityGraph;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for bases. A base is an object that is some form of<br/>
     * an element in the model. MBase in Novosoft terms.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a base.<br/>
     */<br/>
    public static boolean isABase(Object handle) {<br/>
        return handle instanceof MBase;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Recognizer for behavioral features.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a behavioral feature<br/>
     */<br/>
    public static boolean isABehavioralFeature(Object handle) {<br/>
        return handle instanceof MBehavioralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallAction<br/>
     */<br/>
    public static boolean isACallAction(Object handle) {<br/>
        return handle instanceof MCallAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CallEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CallEvent<br/>
     */<br/>
    public static boolean isACallEvent(Object handle) {<br/>
        return handle instanceof MCallEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ChangeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ChangeEvent<br/>
     */<br/>
    public static boolean isAChangeEvent(Object handle) {<br/>
        return handle instanceof MChangeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Class<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Class<br/>
     */<br/>
    public static boolean isAClass(Object handle) {<br/>
        return handle instanceof MClass;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Classifier<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Classifier<br/>
     */<br/>
    public static boolean isAClassifier(Object handle) {<br/>
        return handle instanceof MClassifier;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierInState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierInState<br/>
     */<br/>
    public static boolean isAClassifierInState(Object handle) {<br/>
        return handle instanceof MClassifierInState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ClassifierRole<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ClassifierRole<br/>
     */<br/>
    public static boolean isAClassifierRole(Object handle) {<br/>
        return handle instanceof MClassifierRole;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Comment<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Comment<br/>
     */<br/>
    public static boolean isAComment(Object handle) {<br/>
        return handle instanceof MComment;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Collaboration<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Collaboration<br/>
     */<br/>
    public static boolean isACollaboration(Object handle) {<br/>
        return handle instanceof MCollaboration;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Component<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Component<br/>
     */<br/>
    public static boolean isAComponent(Object handle) {<br/>
        return handle instanceof MComponent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ComponentInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ComponentInstance<br/>
     */<br/>
    public static boolean isAComponentInstance(Object handle) {<br/>
        return handle instanceof MComponentInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Constraint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Constraint<br/>
     */<br/>
    public static boolean isAConstraint(Object handle) {<br/>
        return handle instanceof MConstraint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CreateAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CreateAction<br/>
     */<br/>
    public static boolean isACreateAction(Object handle) {<br/>
        return handle instanceof MCreateAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataType<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataType<br/>
     */<br/>
    public static boolean isADataType(Object handle) {<br/>
        return handle instanceof MDataType;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DataValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DataValue<br/>
     */<br/>
    public static boolean isADataValue(Object handle) {<br/>
        return handle instanceof MDataValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Dependency<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Dependency<br/>
     */<br/>
    public static boolean isADependency(Object handle) {<br/>
        return handle instanceof MDependency;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for DestroyAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a DestroyAction<br/>
     */<br/>
    public static boolean isADestroyAction(Object handle) {<br/>
        return handle instanceof MDestroyAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for CompositeState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a CompositeState<br/>
     */<br/>
    public static boolean isACompositeState(Object handle) {<br/>
        return handle instanceof MCompositeState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Element<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Element<br/>
     */<br/>
    public static boolean isAElement(Object handle) {<br/>
        return handle instanceof MElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementImport<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementImport<br/>
     */<br/>
    public static boolean isAElementImport(Object handle) {<br/>
        return handle instanceof MElementImport;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementListener<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementListener<br/>
     */<br/>
    public static boolean isAElementListener(Object handle) {<br/>
        return handle instanceof MElementListener;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ElementResidence<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ElementResidence<br/>
     */<br/>
    public static boolean isAElementResidence(Object handle) {<br/>
        return handle instanceof MElementResidence;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Event<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Event<br/>
     */<br/>
    public static boolean isAEvent(Object handle) {<br/>
        return handle instanceof MEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Exception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Exception<br/>
     */<br/>
    public static boolean isAException(Object handle) {<br/>
        return handle instanceof MException;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Expression<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Expression<br/>
     */<br/>
    public static boolean isAExpression(Object handle) {<br/>
        return handle instanceof MExpression;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Extend<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Extend<br/>
     */<br/>
    public static boolean isAExtend(Object handle) {<br/>
        return handle instanceof MExtend;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ExtensionPoint<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an ExtensionPoint<br/>
     */<br/>
    public static boolean isAExtensionPoint(Object handle) {<br/>
        return handle instanceof MExtensionPoint;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Feature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Feature<br/>
     */<br/>
    public static boolean isAFeature(Object handle) {<br/>
        return handle instanceof MFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for FinalState<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a FinalState<br/>
     */<br/>
    public static boolean isAFinalState(Object handle) {<br/>
        return handle instanceof MFinalState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Flow<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Flow<br/>
     */<br/>
    public static boolean isAFlow(Object handle) {<br/>
        return handle instanceof MFlow;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Guard<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Guard<br/>
     */<br/>
    public static boolean isAGuard(Object handle) {<br/>
        return handle instanceof MGuard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralizableElement(Object handle) {<br/>
        return handle instanceof MGeneralizableElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for GeneralizableElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a GeneralizableElement<br/>
     */<br/>
    public static boolean isAGeneralization(Object handle) {<br/>
        return handle instanceof MGeneralization;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Include<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Include<br/>
     */<br/>
    public static boolean isAInclude(Object handle) {<br/>
        return handle instanceof MInclude;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Instance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Instance<br/>
     */<br/>
    public static boolean isAInstance(Object handle) {<br/>
        return handle instanceof MInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interaction<br/>
     */<br/>
    public static boolean isAInteraction(Object handle) {<br/>
        return handle instanceof MInteraction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Interface<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Interface<br/>
     */<br/>
    public static boolean isAInterface(Object handle) {<br/>
        return handle instanceof MInterface;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Link<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Link<br/>
     */<br/>
    public static boolean isALink(Object handle) {<br/>
        return handle instanceof MLink;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for LinkEnd<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a LinkEnd<br/>
     */<br/>
    public static boolean isALinkEnd(Object handle) {<br/>
        return handle instanceof MLinkEnd;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Message<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMessage(Object handle) {<br/>
        return handle instanceof MMessage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Method<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Method<br/>
     */<br/>
    public static boolean isAMethod(Object handle) {<br/>
        return handle instanceof MMethod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Model<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Model<br/>
     */<br/>
    public static boolean isAModel(Object handle) {<br/>
        return handle instanceof MModel;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for ModelElement<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a ModelElement<br/>
     */<br/>
    public static boolean isAModelElement(Object handle) {<br/>
        return handle instanceof MModelElement;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Multiplicity<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Multiplicity<br/>
     */<br/>
    public static boolean isAMultiplicity(Object handle) {<br/>
        return handle instanceof MMultiplicity;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MultiplicityRange<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a MultiplicityRange<br/>
     */<br/>
    public static boolean isAMultiplicityRange(Object handle) {<br/>
        return handle instanceof MMultiplicityRange;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Namespace<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Namespace<br/>
     */<br/>
    public static boolean isANamespace(Object handle) {<br/>
        return handle instanceof MNamespace;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Node<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Node<br/>
     */<br/>
    public static boolean isANode(Object handle) {<br/>
        return handle instanceof MNode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a NodeInstance<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a NodeInstance<br/>
     */<br/>
    public static boolean isANodeInstance(Object handle) {<br/>
        return handle instanceof MNodeInstance;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Operation<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Operation<br/>
     */<br/>
    public static boolean isAOperation(Object handle) {<br/>
        return handle instanceof MOperation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Object<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Object<br/>
     */<br/>
    public static boolean isAObject(Object handle) {<br/>
        return handle instanceof MObject;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Parameter<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Parameter<br/>
     */<br/>
    public static boolean isAParameter(Object handle) {<br/>
        return handle instanceof MParameter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Partition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Partition<br/>
     */<br/>
    public static boolean isAPartition(Object handle) {<br/>
        return handle instanceof MPartition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Permission<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is an Permission<br/>
     */<br/>
    public static boolean isAPermission(Object handle) {<br/>
        return handle instanceof MPermission;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Package<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Package<br/>
     */<br/>
    public static boolean isAPackage(Object handle) {<br/>
        return handle instanceof MPackage;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for Pseudostate<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Pseudostate<br/>
     */<br/>
    public static boolean isAPseudostate(Object handle) {<br/>
        return handle instanceof MPseudostate;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for PseudostateKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a PseudostateKind<br/>
     */<br/>
    public static boolean isAPseudostateKind(Object handle) {<br/>
        return handle instanceof MPseudostateKind;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate<br/>
     * <br/>
     * TODO: - Do we need this as well as getKind - I think not<br/>
     * <br/>
     * @param handle the Pseudostate<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getPseudostateKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Kind of a Pseudostate or Parameter<br/>
     * @param handle the Pseudostate or Parameter<br/>
     * @return the Kind<br/>
     */<br/>
    public static Object getKind(Object handle) {<br/>
        if (handle instanceof MPseudostate) {<br/>
            return ((MPseudostate) handle).getKind();<br/>
        }<br/>
        if (handle instanceof MParameter) {<br/>
            return ((MParameter) handle).getKind();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the receiver object of a message or stimulus<br/>
     * @param handle candidate<br/>
     * @return receiver<br/>
     */<br/>
    public static Object getReceiver(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getReceiver();<br/>
        }<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getReceiver();<br/>
        }<br/>
    return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the Link belonging to the given LinkEnd<br/>
     * @param handle the LinkEnd<br/>
     * @return the Link<br/>
     */<br/>
    public static Object getLink(Object handle) {<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getLink();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Check whether two pseudostatekinds are equal/of the same type.<br/>
     *<br/>
     * @return true if the are the same type<br/>
     * @param ps1 one kind<br/>
     * @param ps2 one kind<br/>
     */<br/>
    public static boolean equalsPseudostateKind(Object ps1, Object ps2) {<br/>
        if (isAPseudostateKind(ps1)) {<br/>
            return ((MPseudostateKind) ps1).equals(ps2);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(ps1);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Reception<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Reception<br/>
     */<br/>
    public static boolean isAReception(Object handle) {<br/>
        return handle instanceof MReception;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Returnaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a returnaction<br/>
     */<br/>
    public static boolean isAReturnAction(Object handle) {<br/>
        return handle instanceof MReturnAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Relationship<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Relationship<br/>
     */<br/>
    public static boolean isARelationship(Object handle) {<br/>
        return handle instanceof MRelationship;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SendAction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SendAction<br/>
     */<br/>
    public static boolean isASendAction(Object handle) {<br/>
        return handle instanceof MSendAction;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Signal<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Signal<br/>
     */<br/>
    public static boolean isASignal(Object handle) {<br/>
        return handle instanceof MSignal;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for SignalEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a SignalEvent<br/>
     */<br/>
    public static boolean isASignalEvent(Object handle) {<br/>
        return handle instanceof MSignalEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateMachine<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateMachine<br/>
     */<br/>
    public static boolean isAStateMachine(Object handle) {<br/>
        return handle instanceof MStateMachine;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for stimulus<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a stimulus<br/>
     */<br/>
    public static boolean isAStimulus(Object handle) {<br/>
        return handle instanceof MStimulus;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StateVertex<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StateVertex<br/>
     */<br/>
    public static boolean isAStateVertex(Object handle) {<br/>
        return handle instanceof MStateVertex;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Stereotype<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Stereotype<br/>
     */<br/>
    public static boolean isAStereotype(Object handle) {<br/>
        return handle instanceof MStereotype;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for StructuralFeature<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a StructuralFeature<br/>
     */<br/>
    public static boolean isAStructuralFeature(Object handle) {<br/>
        return handle instanceof MStructuralFeature;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for State<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a State<br/>
     */<br/>
    public static boolean isAState(Object handle) {<br/>
        return handle instanceof MState;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Subsystem<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Subsystem<br/>
     */<br/>
    public static boolean isASubsystem(Object handle) {<br/>
        return handle instanceof MSubsystem;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TaggedValue<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TaggedValue<br/>
     */<br/>
    public static boolean isATaggedValue(Object handle) {<br/>
        return handle instanceof MTaggedValue;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Transition<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isATransition(Object handle) {<br/>
        return handle instanceof MTransition;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for TimeEvent<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a TimeEvent<br/>
     */<br/>
    public static boolean isATimeEvent(Object handle) {<br/>
        return handle instanceof MTimeEvent;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Usage<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Usage<br/>
     */<br/>
    public static boolean isAUsage(Object handle) {<br/>
        return handle instanceof MUsage;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for a Use Case<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a Transition<br/>
     */<br/>
    public static boolean isAUseCase(Object handle) {<br/>
        return handle instanceof MUseCase;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for VisibilityKind<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a VisibilityKind<br/>
     */<br/>
    public static boolean isAVisibilityKind(Object handle) {<br/>
        return handle instanceof MVisibilityKind;<br/>
    }<br/>
<br/>
    /** <br/>
     * Recognizer for Classes that are Active<br/>
     *  <br/>
     * @param handle candidate<br/>
     * @return true if Class is Active<br/>
     */<br/>
    public static boolean isActive(Object handle) {<br/>
        if (handle instanceof MClass) {<br/>
            return ((MClass) handle).isActive();<br/>
        }<br/>
    return illegalArgumentBoolean(handle);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Recognizer for attributes that are changeable<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is changeable<br/>
     */<br/>
    public static boolean isChangeable(Object handle) {<br/>
        if (handle != null &amp;&amp; handle instanceof MStructuralFeature) {<br/>
            MChangeableKind changeability =<br/>
                ((MStructuralFeature) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
<br/>
        } else if (handle != null &amp;&amp; handle instanceof MAssociationEnd) {<br/>
            MChangeableKind changeability =<br/>
                ((MAssociationEnd) handle).getChangeability();<br/>
            return MChangeableKind.CHANGEABLE.equals(changeability);<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with classifier scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has classifier scope.<br/>
     */<br/>
    public static boolean isClassifierScope(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MAttribute a = (MAttribute) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(a.getOwnerScope());<br/>
        }<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature f = (MFeature) handle;<br/>
            return MScopeKind.CLASSIFIER.equals(f.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for concurent composite state.<br/>
     *<br/>
     * @param handle composite state<br/>
     * @return true if concurent.<br/>
     */<br/>
    public static boolean isConcurent(Object handle) {<br/>
        if (handle instanceof MCompositeState) {<br/>
            return ((MCompositeState) handle).isConcurent();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for constructor.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a constructor.<br/>
     */<br/>
    public static boolean isConstructor(Object handle) {<br/>
        Object stereo = null;<br/>
        if (isAOperation(handle)) {<br/>
            if (ModelFacade.getStereotypes(handle).size() &gt; 0) {<br/>
                stereo = ModelFacade.getStereotypes(handle).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
        if (isAMethod(handle)) {<br/>
            Object specification =<br/>
                CoreHelper.getHelper().getSpecification(handle);<br/>
            if (ModelFacade.getStereotypes(specification).size() &gt; 0) {<br/>
                stereo =<br/>
                    ModelFacade.getStereotypes(specification).iterator().next();<br/>
            }<br/>
            if (ExtensionMechanismsHelper.getHelper()<br/>
                    .isStereotypeInh(stereo, "create", "BehavioralFeature")) {<br/>
                return true;<br/>
            }<br/>
            return false;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the given element is Frozen<br/>
     * @param handle candidate<br/>
     * @return boolean true if Frozen<br/>
     */<br/>
    public static boolean isFrozen(Object handle) {<br/>
        if (handle instanceof MChangeableKind) {<br/>
            MChangeableKind ck = (MChangeableKind) handle;<br/>
            return MChangeableKind.FROZEN.equals(ck);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isComposite(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.COMPOSITE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if a given associationend is a composite.<br/>
     * @param handle candidate<br/>
     * @return boolean<br/>
     */<br/>
    public static boolean isAggregate(Object handle) {<br/>
        if (isAAssociationEnd(handle)) {<br/>
            boolean composite = false;<br/>
            MAssociationEnd end = (MAssociationEnd) handle;<br/>
            if (end.getAggregation() != null<br/>
                &amp;&amp; end.getAggregation().equals(MAggregationKind.AGGREGATE))<br/>
                composite = true;<br/>
            return composite;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes that are initialized.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if the attribute is initialized.<br/>
     */<br/>
    public static boolean isInitialized(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            MExpression init = ((MAttribute) handle).getInitialValue();<br/>
<br/>
            if (init != null<br/>
                &amp;&amp; init.getBody() != null<br/>
                &amp;&amp; init.getBody().trim().length() &gt; 0)<br/>
                return true;<br/>
            return false;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with instance scope.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has instance scope.<br/>
     */<br/>
    public static boolean isInstanceScope(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            MFeature a = (MFeature) handle;<br/>
            return MScopeKind.INSTANCE.equals(a.getOwnerScope());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for internal transitions.<br/>
     *<br/>
     * @author mvw<br/>
     * @param handle candidate<br/>
     * @return true if handle is an internal transition.<br/>
     */<br/>
    public static boolean isInternal(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            Object state = getState(handle);<br/>
            Object end0 = getSource(handle);<br/>
            Object end1 = getTarget(handle);<br/>
            if (end0 != null) {<br/>
                return ((state == end0) &amp;&amp; (state == end1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
        }<br/>
        return illegalArgumentBoolean(handle);<br/>
    }<br/>
    /**<br/>
     * Recognizer for leafs<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isLeaf(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isLeaf();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isLeaf();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for roots<br/>
     *<br/>
     * @param handle candidate GeneralizableElement<br/>
     * @return true if handle is a leaf<br/>
     */<br/>
    public static boolean isRoot(Object handle) {<br/>
<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            return ((MGeneralizableElement) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).isRoot();<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            return ((MReception) handle).isRoot();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for specifications<br/>
     *<br/>
     * @param handle candidate ModelElement<br/>
     * @return true if handle is a specification<br/>
     */<br/>
    public static boolean isSpecification(Object handle) {<br/>
<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).isSpecification();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for Navigable elements<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is navigable<br/>
     */<br/>
    public static boolean isNavigable(Object handle) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).isNavigable();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for primary objects.&lt;p&gt;<br/>
     *<br/>
     * A primary object is an object that is created by the parser or<br/>
     * by a user.<br/>
     * Object that are created when importing some other object are not.&lt;p&gt;<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if primary object.<br/>
     */<br/>
    public static boolean isPrimaryObject(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            for (Iterator i = element.getTaggedValues().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.hasNext(); ) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if ((GENERATED_TAG).equals(tv.getTag())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
            return true;<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with private<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has private<br/>
     */<br/>
    public static boolean isPrivate(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PRIVATE.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with public<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has public<br/>
     */<br/>
    public static boolean isPublic(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PUBLIC.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for MBehaviouralFeature's that are queries.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if it is a query<br/>
     */<br/>
    public static boolean isQuery(Object handle) {<br/>
<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MBehavioralFeature) handle).isQuery();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for attributes with protected<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has protected<br/>
     */<br/>
    public static boolean isProtected(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            return MVisibilityKind.PROTECTED.equals(element.getVisibility());<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for realize<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle has a realize stereotype<br/>
     */<br/>
    public static boolean isRealize(Object handle) {<br/>
        return isStereotype(handle, "realize");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for return<br/>
     *<br/>
     * @param handle candidate parameter<br/>
     * @return true if handle is a return parameter.<br/>
     */<br/>
    public static boolean isReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            MParameter p = (MParameter) handle;<br/>
            return MParameterDirectionKind.RETURN.equals(p.getKind());<br/>
<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for singleton.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a singleton.<br/>
     */<br/>
    public static boolean isSingleton(Object handle) {<br/>
        return isStereotype(handle, "singleton");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for model elements with a given stereotype.<br/>
     *<br/>
     * @param handle candidate model element<br/>
     * @param stereotypename a string that is the stereotype name.<br/>
     * @return true if handle is an object that has the given stereotype.<br/>
     */<br/>
    public static boolean isStereotype(Object handle, String stereotypename) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement element = (MModelElement) handle;<br/>
            MStereotype meSt = element.getStereotype();<br/>
<br/>
            if (meSt == null)<br/>
                return false;<br/>
<br/>
            String name = meSt.getName();<br/>
            if (name == null)<br/>
                return false;<br/>
<br/>
            return name.equalsIgnoreCase(stereotypename);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /** Returns true if the given CompositeState is the top state<br/>
     * @param handle CompositeState<br/>
     * @return boolean true if top state<br/>
     */<br/>
    public static boolean isTop(Object handle) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (isACompositeState(handle)) {<br/>
            return ((MCompositeState) handle).getStateMachine() != null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for type.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a type.<br/>
     */<br/>
    public static boolean isType(Object handle) {<br/>
        return isStereotype(handle, "type");<br/>
    }<br/>
<br/>
    /**<br/>
     * Recognizer for utility.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a utility.<br/>
     */<br/>
    public static boolean isUtility(Object handle) {<br/>
        return isStereotype(handle, "utility");<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Recognizer methods for the diagrams (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Recognizer for Diagram.<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return true if handle is a diagram.<br/>
     */<br/>
    public static boolean isADiagram(Object handle) {<br/>
        return handle instanceof Diagram;<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Getters for the UML model (in alphabetic order)<br/>
<br/>
    /**<br/>
     * Returns the association connected to an association end or<br/>
     * the association belonging to the given link.<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociation(Object handle) {<br/>
<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getAssociation();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;return ((MLink) handle).getAssociation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the association end between some classifier and some associaton.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param assoc is the association<br/>
     * @return association end<br/>
     */<br/>
    public static Object getAssociationEnd(Object handle, Object assoc) {<br/>
        if (handle instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; assoc instanceof MAssociation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifier classifier = (MClassifier) handle;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = classifier.getAssociationEnds().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAssociationEnd end = (MAssociationEnd) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((MAssociation) assoc).getConnections().contains(end))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return end;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, assoc);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Association Ends<br/>
     *<br/>
     * @param handle the object that we get the association ends from.<br/>
     * @return Collection with association ends.<br/>
     */<br/>
    public static Collection getAssociationEnds(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            Collection endc = ((MClassifier) handle).getAssociationEnds();<br/>
            return endc;<br/>
        }<br/>
<br/>
        //...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of association roles<br/>
     *<br/>
     * @param handle the object that we get the association roles from.<br/>
     * @return Collection of association roles.<br/>
     */<br/>
    public static Collection getAssociationRoles(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getAssociationRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Attributes.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return iterator with attributes.<br/>
     */<br/>
    public static Collection getAttributes(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) handle;<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            //return getStructuralFeatures(c).iterator();<br/>
            //...But I (thn) got CVS conflicts, so:<br/>
            return getStructuralFeatures(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The baseclass of some stereotype<br/>
     * @param handle the stereotype<br/>
     * @return the baseclass<br/>
     */<br/>
    public static Object getBaseClass(Object handle) {<br/>
        if (isAStereotype(handle)) {<br/>
            return ((MStereotype) handle).getBaseClass();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The base of some model element<br/>
     * There is a bug in NSUML which gets the addition and base <br/>
     * relationships back to front for include relationships. Solve<br/>
     * by reversing their accessors in the code<br/>
     * @param handle the model element<br/>
     * @return the base<br/>
     */<br/>
    public static Object getBase(Object handle) {<br/>
        if (handle instanceof MAssociationEndRole) {<br/>
            return ((MAssociationEndRole) handle).getBase();<br/>
        } else if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getBase();<br/>
        } else if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getBase();<br/>
        } else if (handle instanceof MInclude) {<br/>
            return ((MInclude) handle).getAddition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the bases of a classifier role.<br/>
     *<br/>
     *<br/>
     * @param handle classifier role.<br/>
     * @return the bases.<br/>
     */<br/>
    public static Collection getBases(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getBases();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behaviors of a Modelelement.<br/>
     *<br/>
     *<br/>
     * @param handle modelelement to examine.<br/>
     * @return the behaviors.<br/>
     */<br/>
    public static Collection getBehaviors(Object handle) {<br/>
        if (isAModelElement(handle))<br/>
            return ((MModelElement) handle).getBehaviors();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the behavioral feature of an parameter.<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the behavioral feature.<br/>
     */<br/>
    public static Object getBehavioralFeature(Object handle) {<br/>
        if (handle instanceof MParameter)<br/>
            return ((MParameter) handle).getBehavioralFeature();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the body of an method/constraint/expression.<br/>
     *<br/>
     *<br/>
     * @param handle expression.<br/>
     * @return the body.<br/>
     */<br/>
    public static Object getBody(Object handle) {<br/>
        if (handle instanceof MMethod)<br/>
            return ((MMethod) handle).getBody();<br/>
        if (handle instanceof MConstraint)<br/>
            return ((MConstraint) handle).getBody();<br/>
        if (handle instanceof MExpression)<br/>
            return ((MExpression) handle).getBody();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Return Changeability of a StructuralFeature or a AssociationEnd<br/>
     * @param handle the StructuralFeature or AssociationEnd<br/>
     * @return the Changeability<br/>
     */<br/>
    public static Object getChangeability(Object handle) {<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) handle).getChangeability();<br/>
        }<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) handle).getChangeability();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Get the child of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the child.<br/>
     */<br/>
    public static Object getChild(Object handle) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            return ((MGeneralization) handle).getChild();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the children of some generalizable element<br/>
     *<br/>
     * @param handle to the generalizable element.<br/>
     * @return a collection with all children.<br/>
     */<br/>
    public static Collection getChildren(Object handle) {<br/>
        if (isAGeneralizableElement(handle)) {<br/>
            return ((MGeneralizableElement) handle).getChildren();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers roles of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifiers roles of the instance<br/>
     */<br/>
    public static Collection getClassifierRoles(Object handle) {<br/>
        if (handle instanceof MFeature) {<br/>
            return ((MFeature) handle).getClassifierRoles();<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifierRoles();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifierss of some instance<br/>
     * @param handle the instance<br/>
     * @return the classifierss of the instance<br/>
     */<br/>
    public static Collection getClassifiers(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getClassifiers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the classifiers in state of some model element<br/>
     * @param handle the model element<br/>
     * @return the classifierss in state<br/>
     */<br/>
    public static Collection getClassifiersInState(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getClassifiersInState();<br/>
        }<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getClassifiersInState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the clients of some dependency<br/>
     * @param handle the dependency<br/>
     * @return the clients of the dependency<br/>
     */<br/>
    public static Collection getClients(Object handle) {<br/>
        if (isADependency(handle)) {<br/>
            return ((MDependency) handle).getClients();<br/>
        }<br/>
        return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the client dependencies of some classifier<br/>
     *<br/>
     * @param handle to the classifier.<br/>
     * @return an iterator with all client dependencies.<br/>
     */<br/>
    public static Collection getClientDependencies(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            Collection c = ((MModelElement) handle).getClientDependencies();<br/>
            return c;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the condition of an extend.<br/>
     *<br/>
     * @param handle The extend.<br/>
     * @return the condition<br/>
     */<br/>
    public static Object getCondition(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getCondition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the concurrency of an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @return the concurrency.<br/>
     */<br/>
    public static Object getConcurrency(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getConcurrency();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    //    public static short getConcurrency(Object handle) {<br/>
    //        if (handle != null &amp;&amp; handle instanceof MOperation) {<br/>
    //            return ((MOperation) handle).getConcurrency()<br/>
    //                == MCallConcurrencyKind.GUARDED<br/>
    //                ? GUARDED<br/>
    //                : SEQUENTIAL;<br/>
    //        }<br/>
    //        illegalArgument(handle);<br/>
    //        return (short) 0;<br/>
    //    }<br/>
<br/>
    /**<br/>
     * The list of connections to an association or link.<br/>
     *<br/>
     * @param handle to the association or link<br/>
     * @return a Collection with all connections.<br/>
     */<br/>
    public static Collection getConnections(Object handle) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections();<br/>
        }<br/>
        if (handle instanceof MLink) {<br/>
            return ((MLink) handle).getConnections();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a model element contains a connection.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param connection is the connection that is searched for.<br/>
     * @return true if the model element contains a connection<br/>
     */<br/>
    public boolean containsConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation) {<br/>
            return ((MAssociation) handle).getConnections().contains(<br/>
                connection);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentBoolean(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return the effect<br/>
     */<br/>
    public static Object getEffect(Object handle) {<br/>
        if (handle instanceof MTransition) {<br/>
            return ((MTransition) handle).getEffect();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the residences of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the residences of<br/>
     * @return the residence collection<br/>
     */<br/>
    public static Collection getElementResidences(Object handle) {<br/>
        if (handle instanceof MModelElement)<br/>
            return ((MModelElement) handle).getElementResidences();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the ElementImports of this ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of ElementImports<br/>
     */<br/>
    public static Collection getElementImports2(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getElementImports2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the entry action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the entry<br/>
     */<br/>
    public static Object getEntry(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getEntry();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the exit action to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the exit action<br/>
     */<br/>
    public static Object getExit(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getExit();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Expression belonging to a Guard, ChangeEvent or timeEvent<br/>
     * @param handle the Object to get the Expression from<br/>
     * @return Object the Expression<br/>
     */<br/>
    public static Object getExpression(Object handle) {<br/>
        if (handle instanceof MGuard) {<br/>
            return ((MGuard) handle).getExpression();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MChangeEvent) {<br/>
            return ((MChangeEvent) handle).getChangeExpression();<br/>
        }<br/>
        if (handle instanceof MTimeEvent) {<br/>
            return ((MTimeEvent) handle).getWhen();<br/>
        }       <br/>
        return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case or extension point<br/>
     *<br/>
     * @param handle is the use case or the extension point<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends();<br/>
        }<br/>
        if (handle instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) handle).getExtends();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtends2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtends2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the use case extension of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @return The extension<br/>
     */<br/>
    public static Object getExtension(Object handle) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtension();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Extensionpoint at given index-number<br/>
     * @param handle Extend<br/>
     * @param index int<br/>
     * @return ExtensionPoint<br/>
     */<br/>
    public static Object getExtensionPoint(Object handle, int index) {<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoint(index);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all extends of a use case<br/>
     *<br/>
     * @param handle is the use case or the extend<br/>
     * @return the extends<br/>
     */<br/>
    public static Collection getExtensionPoints(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getExtensionPoints();<br/>
        }<br/>
        if (handle instanceof MExtend) {<br/>
            return ((MExtend) handle).getExtensionPoints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Features from a Classifier.<br/>
     *<br/>
     * @param handle Classifier to retrieve from.<br/>
     * @return Collection with Features<br/>
     */<br/>
    public static Collection getFeatures(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getFeatures();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.<br/>
     *<br/>
     * @param handle is the child<br/>
     * @param parent is the parent<br/>
     * @return The generalization<br/>
     */<br/>
    public static Object getGeneralization(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralizableElement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it = getGeneralizations(handle).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MGeneralization gen = (MGeneralization) it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gen.getParent() == parent) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return gen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle, parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * The list of Generalizations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Generalizations<br/>
     */<br/>
    public static Collection getGeneralizations(Object handle) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) handle;<br/>
            return ge.getGeneralizations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the guard for some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */<br/>
    public static Object getGuard(Object handle) {<br/>
        if (isATransition(handle)) {<br/>
            return ((MTransition) handle).getGuard();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Icon of a Stereotype<br/>
     * @param handle the Stereotype to get the Icon from<br/>
     * @return the Icon<br/>
     */<br/>
    public static Object getIcon(Object handle) {<br/>
        if (handle instanceof MStereotype) {<br/>
            return ((MStereotype) handle).getIcon();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the component of some element residence<br/>
     *<br/>
     * @param handle is an element residence<br/>
     * @return component<br/>
     */<br/>
    public static Object getImplementationLocation(Object handle) {<br/>
        if (handle instanceof MElementResidence) {<br/>
            return ((MElementResidence) handle).getImplementationLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the includes for some use case<br/>
     *<br/>
     * @param handle is the use case<br/>
     * @return the includes as a Collection<br/>
     */<br/>
    public static Collection getIncludes2(Object handle) {<br/>
        if (handle instanceof MUseCase) {<br/>
            return ((MUseCase) handle).getIncludes();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the incoming transitions for some statevertex<br/>
     *<br/>
     * @param handle is the state vertex<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getIncomings(Object handle) {<br/>
        if (isAStateVertex(handle)) {<br/>
            return ((MStateVertex) handle).getIncomings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the initial value for some attribute.<br/>
     *<br/>
     * @param handle is the attribute<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInitialValue(Object handle) {<br/>
        if (handle instanceof MAttribute) {<br/>
            return ((MAttribute) handle).getInitialValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the instance of an AttributeLink or LinkEnd<br/>
     *<br/>
     * @param handle is the attribute link or link end<br/>
     * @return initial value<br/>
     */<br/>
    public static Object getInstance(Object handle) {<br/>
        if (handle instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) handle).getInstance();<br/>
        }<br/>
        if (handle instanceof MLinkEnd) {<br/>
            return ((MLinkEnd) handle).getInstance();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the Instances for some Clasifier<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInstances(Object handle) {<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getInstances();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the collection of States for some ClasifierInState<br/>
     *<br/>
     * @param handle is the classifierInState<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInStates(Object handle) {<br/>
        if (handle instanceof MClassifierInState) {<br/>
            return ((MClassifierInState) handle).getInStates();<br/>
        }<br/>
    return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interaction for some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the interaction<br/>
     */<br/>
    public static Object getInteraction(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getInteraction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the interactions belonging to a collaboration<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInteractions(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getInteractions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the internal transitions belonging to a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getInternalTransitions(Object handle) {<br/>
        if (handle instanceof MState) {<br/>
            return ((MState) handle).getInternalTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some interaction<br/>
     *<br/>
     * @param handle candidate<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages(Object handle) {<br/>
        if (isAInteraction(handle)) {<br/>
            return ((MInteraction) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAssociationRole) {<br/>
            return ((MAssociationRole) handle).getMessages();<br/>
        }<br/>
        if (handle instanceof MAction) {<br/>
            return ((MAction) handle).getMessages();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages belonging to some other message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages3(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the messages that are activated by the given message<br/>
     * @param handle Message<br/>
     * @return the Collection of Messages<br/>
     */<br/>
    public static Collection getMessages4(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getMessages4();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages received by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages1(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages1();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the messages send by the given classifier role<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @return Collection<br/>
     */<br/>
    public static Collection getMessages2(Object handle) {<br/>
        if (handle instanceof MClassifierRole) {<br/>
            return ((MClassifierRole) handle).getMessages2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the model of some model element<br/>
     *<br/>
     * @param handle to the model element.<br/>
     * @return model for the model element.<br/>
     */<br/>
    public static Object getModel(Object handle) {<br/>
        if (isAModelElement(handle)) {<br/>
            MModel m = ((MModelElement) handle).getModel();<br/>
            return m;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle an Element Import.<br/>
     * @return the model element<br/>
     */<br/>
    public static Object getModelElement(Object handle) {<br/>
        if (handle instanceof MElementImport) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return ((MElementImport) handle).getModelElement();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Multiplicity from a model element.<br/>
     *<br/>
     * @param handle model element to retrieve from.<br/>
     * @return multiplicity<br/>
     */<br/>
    public static Object getMultiplicity(Object handle) {<br/>
        if ((handle instanceof MAssociationEnd)) {<br/>
            return ((MAssociationEnd) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MAssociationRole)) {<br/>
            return ((MAssociationRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MClassifierRole)) {<br/>
            return ((MClassifierRole) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if ((handle instanceof MStructuralFeature)) {<br/>
            return ((MStructuralFeature) handle).getMultiplicity();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the Ranges from a Multiplicity.<br/>
     *<br/>
     * @param handle multiplicity to retrieve from.<br/>
     * @return iterator containing ranges<br/>
     */<br/>
    public static Iterator getRanges(Object handle) {<br/>
        if ((handle instanceof MMultiplicity)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection c = ((MMultiplicity) handle).getRanges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (c == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return c.iterator();<br/>
        }<br/>
        illegalArgument(handle);<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the comments of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the comments of<br/>
     * @return the comment (or null)<br/>
     */<br/>
    public static Collection getComments(Object handle) {<br/>
        if (handle instanceof MModelElement) {<br/>
            return ((MModelElement) handle).getComments();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication connection of an message.<br/>
     *<br/>
     * @param handle the message that we are getting the communication<br/>
     * connection<br/>
     * @return the communication connection<br/>
     */<br/>
    public static Object getCommunicationConnection(Object handle) {<br/>
        if (handle instanceof MMessage) {<br/>
            return ((MMessage) handle).getCommunicationConnection();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the communication link of a stimulus.<br/>
     *<br/>
     * @param handle the message that we are getting the communication link<br/>
     * @return the communication link<br/>
     */<br/>
    public static Object getCommunicationLink(Object handle) {<br/>
        if (handle instanceof MStimulus) {<br/>
            return ((MStimulus) handle).getCommunicationLink();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the collaborations of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the<br/>
     * collaborations of.<br/>
     * @return the collaborations<br/>
     */<br/>
    public static Collection getCollaborations(Object handle) {<br/>
        if (handle instanceof MOperation) {<br/>
            return ((MOperation) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (handle instanceof MClassifier) {<br/>
            return ((MClassifier) handle).getCollaborations();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public static void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the component instance of an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @return the component instance<br/>
     */<br/>
    public static Object getComponentInstance(Object handle) {<br/>
        if (handle instanceof MInstance) {<br/>
            return ((MInstance) handle).getComponentInstance();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(handle);<br/>
    }<br/>
<br/>
    /** <br/>
     * Returns the collection of ConstrainingElements of a Collaboration<br/>
     * @param handle the Collaboration<br/>
     * @return the collection of ConstrainingElements<br/>
     */<br/>
    public static Collection getConstrainingElements(Object handle) {<br/>
        if (handle instanceof MCollaboration) {<br/>
            return ((MCollaboration) handle).getConstrainingElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentCollection(handle);<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/** <br/>
     * Returns the collection of ConstrainedElements of a constraint<br/>
     * @param handle the Constraint<br/>
     * @return the collection of ConstrainedElements<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="add">getConstrainedElements</span>(<span class="mv">Object handle</span>) <span class="add">{<br/>
        <span class="add">if (<span class="mv"><span class="mv">handle</span> instanceof MConstraint</span>) <span class="add">{<br/>
            <span class="add">return <span class="add"><span class="add">(<span class="mv">(MConstraint) <span class="mv">handle</span></span>)</span>.<span class="add">getConstrainedElements</span>()</span>;</span><br/>
        }</span></span><br/>
        <span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the collection of all constraints of the given ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the collection of all constraints<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getConstraints</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getConstraints();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the container for the given modelelement. The container is the<br/>
     * owner of the modelelement. It will be null for elements that don't have<br/>
     * an owner. All elements except for the root element in a project should<br/>
     * have an owner. The root element is allways a model.&lt;p&gt;<br/>
     *<br/>
     * In  the future, this function could return the container of Figs too.<br/>
     *<br/>
     * @param handle is the base<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getModelElementContainer</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MBase) {<br/>
            return ((MBase) <span class="mv">handle</span>).getModelElementContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the CompositeState that is the container of the given StateVertex<br/>
     * @param handle the StateVertex<br/>
     * @return the CompositeState that is the container <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getContainer</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateVertex) {<br/>
            return ((MStateVertex) <span class="mv">handle</span>).getContainer();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
    <br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the collection of ModelElements contained in a Partition<br/>
     * @param handle the Partition<br/>
     * @return the contents of the Partition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getContents</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MPartition) {<br/>
            return ((MPartition) <span class="mv">handle</span>).getContents();<br/>
        }<br/>
        <span class="add">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction.<br/>
     *<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getContext(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (isAStateMachine(<span class="mv">handle</span>)) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getContext();<br/>
        }<br/>
        if (<span class="add"><span class="mv">isAInteraction</span>(<span class="mv">handle</span>)</span>) {<br/>
            return ((MInteraction) <span class="mv">handle</span>).getContext();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Return the collection of the Contexts of a given Signal<br/>
     * @param handle the Signal<br/>
     * @return a collection of the Contexts<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getContexts</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            return ((MSignal) <span class="mv">handle</span>).getContexts();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Return the collection of Actions that create/instantiate<br/>
     *  the given Classifier <br/>
     * <br/>
     * @param handle the Classifier<br/>
     * @return a collection containing all the creating actions<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getCreateActions</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getCreateActions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the default value of a parameter<br/>
     *<br/>
     * @param handle the parameter that we are getting the defaultvalue from<br/>
     * @return the default value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDefaultValue</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
            return ((MParameter) <span class="mv">handle</span>).getDefaultValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get deferrable events of a state<br/>
     *<br/>
     * @param handle the state that we are getting the deferrable event from<br/>
     * @return the deferrable events collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getDeferrableEvents</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getDeferrableEvents();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the context of some given statemachine or the context<br/>
     * of some given interaction<br/>
     * @param handle the statemachine or the interaction<br/>
     * @return the context of the statemachine or interaction or null<br/>
     * if the statemachine or interaction doesn't have a context.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getDeploymentLocations</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (isAComponent(<span class="mv">handle</span>)) {<br/>
            return ((MComponent) <span class="mv">handle</span>).getDeploymentLocations();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the discriminator.<br/>
     *<br/>
     * @param handle the Generalization<br/>
     * @return the discriminator a String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDiscriminator</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getDiscriminator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="mv"><span class="mv">illegalArgumentObject</span>(handle)</span>;</span><br/>
    }</span></span><br/>
    <br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDiscriminator(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>, String discriminator) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        <span class="add"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the dispatchaction of a stimulus.<br/>
     *<br/>
     * @param handle the stimulus that we are getting the dispatchaction of<br/>
     * @return the dispatchaction (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDispatchAction</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStimulus) {<br/>
            return ((MStimulus) <span class="mv">handle</span>).getDispatchAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the do activity action of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @return the do activity<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getDoActivity</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getDoActivity();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Return the Links of a given Association<br/>
     * @param handle the Association<br/>
     * @return the collection of Links<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getLinks</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociation) {<br/>
            return ((MAssociation) <span class="mv">handle</span>).getLinks();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Return the LinkEnds of a given Instance or AssociationEnd<br/>
     * @param handle the candidate<br/>
     * @return the collection of LinkEnds<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getLinkEnds(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getLinkEnds();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getLinkEnds();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Gets a location of some extension point.<br/>
     *<br/>
     * @param handle extension point<br/>
     * @return the location<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">String</span> <span class="mv">getLocation</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) <span class="mv">handle</span>).getLocation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentString</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the methods of an operation.<br/>
     *<br/>
     * @param handle the operation that we are getting the methods of<br/>
     * @return methods collection (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getMethods</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MOperation)<br/>
            return ((MOperation) <span class="mv">handle</span>).getMethods();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the namespace of an element.<br/>
     *<br/>
     * @param handle the model element that we are getting the namespace of<br/>
     * @return the namespace (or null)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getNamespace</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement)<br/>
            return ((MModelElement) <span class="mv">handle</span>).getNamespace();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the node instance of a component instance.<br/>
     *<br/>
     * @param handle the model element that we are getting the node instance of<br/>
     * @return the node instance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getNodeInstance</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance)<br/>
            return ((MComponentInstance) <span class="mv">handle</span>).getNodeInstance();<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * The collection of object flow states<br/>
     *<br/>
     * @param handle the classifier<br/>
     * @return collection of object flow states<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getObjectFlowStates</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getObjectFlowStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the operation of a Call Action or Call Event.<br/>
     *<br/>
     * @param handle the model element that we are getting the operation of<br/>
     * @return the Operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getOperation(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCallAction) {<br/>
            return ((MCallAction) <span class="mv">handle</span>).getOperation();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallEvent) {<br/>
            return ((MCallEvent) <span class="mv">handle</span>).getOperation();<br/>
        }<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the list of operations.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Collection with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOperations</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) <span class="mv">handle</span>;<br/>
            return getOperations(c);<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the list of Operations of this classifier and all inherited.<br/>
     *<br/>
     * @param handle classifier to examine.<br/>
     * @return Iterator with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> Iterator getOperationsInh(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier c = (MClassifier) <span class="mv">handle</span>;<br/>
<br/>
            // TODO: We are converting back and forth between collections and<br/>
            // iterators. I (Linus) prefer iterators.<br/>
            return CoreHelper.getHelper().getOperationsInh(c).iterator();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the opposite end of an association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @return Object the opposite end.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOppositeEnd</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getOppositeEnd();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get ordering of an association end<br/>
     *<br/>
     * @param handle association end to retrieve from<br/>
     * @return ordering<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOrdering</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd)<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getOrdering();<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the list of Transitions outgoing from the given stateVertex.<br/>
     *<br/>
     * @param handle statevertex<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOutgoings</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (ModelFacade.isAStateVertex(<span class="mv">handle</span>)) {<br/>
            return ((MStateVertex) <span class="mv">handle</span>).getOutgoings();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the list of Associations Ends connected to this association end.<br/>
     *<br/>
     * @param handle association end to start from<br/>
     * @return Iterator with all connected association ends.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getOtherAssociationEnds(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            MAssociation a = ((MAssociationEnd) <span class="mv">handle</span>).getAssociation();<br/>
<br/>
            if (a == null)<br/>
                return emptyCollection();<br/>
<br/>
            <span class="mv">Collection</span> allEnds = a.getConnections();<br/>
            if (allEnds == null)<br/>
                return emptyCollection();<br/>
<br/>
            // TODO: An Iterator filter would be nice here instead of the<br/>
            // mucking around with the Collection.<br/>
            allEnds = new ArrayList(allEnds);<br/>
            allEnds.remove(<span class="mv">handle</span>);<br/>
            return allEnds;<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * The list of owned elements of the the package.<br/>
     *<br/>
     * @param handle package to retrieve from.<br/>
     * @return Iterator with operations<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getOwnedElements</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MNamespace) {<br/>
            return ((MNamespace) <span class="mv">handle</span>).getOwnedElements();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the owner scope of a feature<br/>
     *<br/>
     * @param handle feature<br/>
     * @return owner scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getOwnerScope</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            return ((MFeature) <span class="mv">handle</span>).getOwnerScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the powertype of a generalization<br/>
     *<br/>
     * @param handle generalization<br/>
     * @return powertype<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getPowertype</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getPowertype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the powertype ranges of a classifier.<br/>
     *<br/>
     * @param handle classifier to retrieve from<br/>
     * @return collection of poertype ranges<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getPowertypeRanges</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getPowertypeRanges();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the predecessors of a message.<br/>
     *<br/>
     * @param handle message to retrieve from<br/>
     * @return collection of predecessors<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getPredecessors</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getPredecessors();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Determine if the passed parameter has a RETURN direction kind<br/>
     *<br/>
     * @return true if it is a return direction kind<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> boolean hasReturnParameterDirectionKind(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MParameter parameter = (MParameter) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameterDirectionKind.RETURN.equals(parameter.getKind()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentBoolean</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the Package that is connected by the given ElementImport <br/>
     * @param handle the ElementImport <br/>
     * @return the Package<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getPackage</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MElementImport) {<br/>
            return ((MElementImport) <span class="mv">handle</span>).getPackage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get a parameter of a behavioral feature.<br/>
     *<br/>
     * @param handle behavioral feature to retrieve from<br/>
     * @param n parameter number<br/>
     * @return parameter.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getParameter(<span class="mv">Object handle</span>, int n) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) <span class="mv">handle</span>).getParameter(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="add"><span class="mv">illegalArgumentObject</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the parameters of a Object Flow State, Behavioral Feature, <br/>
     * Classifier or Event.<br/>
     *<br/>
     * @param handle operation to retrieve from<br/>
     * @return Iterator with operations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getParameters(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            return ((MBehavioralFeature) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MEvent) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            return ((MClassifier) <span class="mv">handle</span>).getParameters();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Get the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization.<br/>
     * @return the parent.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getParent</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            return ((MGeneralization) <span class="mv">handle</span>).getParent();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the raised signals of an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @return raised signals<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getRaisedSignals</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            return ((MOperation) <span class="mv">handle</span>).getRaisedSignals();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the receptions of a signal.<br/>
     *<br/>
     * @param handle is the signal<br/>
     * @return receptions<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getReceptions</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            return ((MSignal) <span class="mv">handle</span>).getReceptions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the recurrence iteration expression of an action.<br/>
     *<br/>
     * @param handle is the action.<br/>
     * @return the recurrence<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRecurrence</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getRecurrence();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the represented classifier of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRepresentedClassifier</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration) {<br/>
            return ((MCollaboration) <span class="mv">handle</span>).getRepresentedClassifier();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the represented operation of a collaboration.<br/>
     *<br/>
     * @param handle is the collaboration<br/>
     * @return represented operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getRepresentedOperation</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration) {<br/>
            return ((MCollaboration) <span class="mv">handle</span>).getRepresentedOperation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the script belonging to a given action<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the script<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getScript</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getScript();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="add"><span class="mv">illegalArgumentObject</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     *<br/>
     * @param handle is the stimulus or message<br/>
     * @return the sender<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getSender(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus) {<br/>
            return ((MStimulus) <span class="mv">handle</span>).getSender();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getSender();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the sender object of a stimulus or a message<br/>
     * TODO: Check if this javadoc comment is really correct?<br/>
     *<br/>
     * @param handle is the object<br/>
     * @return the signal<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getSignal(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSendAction) {<br/>
            return ((MSendAction) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MSignalEvent) {<br/>
            return ((MSignalEvent) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            return ((MReception) <span class="mv">handle</span>).getSignal();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the resident element<br/>
     *<br/>
     * @param handle is the element residence<br/>
     * @return resident element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getResident(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence) {<br/>
            return ((MElementResidence) <span class="mv">handle</span>).getResident();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the collection of elements in a given component<br/>
     * @param handle the component<br/>
     * @return the Collection of ResidentElements<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getResidentElements</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MComponent) {<br/>
            return ((MComponent) <span class="mv">handle</span>).getResidentElements();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns a collection with all residents belonging to the given<br/>
     * node.<br/>
     *<br/>
     * @param handle is the node, nodeinstance, componentinstance<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getResidents(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (isANode(<span class="mv">handle</span>)) {<br/>
            return ((MNode) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isANodeInstance</span>(handle)</span>) {<br/>
            return ((MNodeInstance) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
        if (isAComponentInstance(<span class="mv">handle</span>)) {<br/>
            return ((MComponentInstance) <span class="mv">handle</span>).getResidents();<br/>
        }<br/>
            <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Gets the source for a given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object (MStateVertex)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getSource</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isATransition(<span class="mv">handle</span>)) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getSource();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Gets the source for some given flow.<br/>
     *<br/>
     * @param handle is the flow<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSources</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MFlow) {<br/>
            return ((MFlow) <span class="mv">handle</span>).getSources();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the sourceflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of sourceflows<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSourceFlows</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getSourceFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * The list of Specializations from a GeneralizableElement.<br/>
     *<br/>
     * @param handle GeneralizableElement to retrieve from.<br/>
     * @return Collection of Specializations.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSpecializations</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement ge = (MGeneralizableElement) <span class="mv">handle</span>;<br/>
            return ge.getSpecializations();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the state machine belonging to some given state or transition<br/>
     * If you need to find the StateMachine for an internal transition,<br/>
     * or for ANY state, <br/>
     * use StateMachinesHelper.getStateMachine() instead.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getStateMachine(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            return ((MState) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the state belonging to some given transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getState(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getState();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
    <br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the states from a deferable event<br/>
     *<br/>
     * @param handle is the event<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStates</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MEvent) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the stereotype belonging to some given model element<br/>
     *<br/>
     * @param handle is a model element<br/>
     * @return Object<br/>
     * @deprecated 0.15 in favor of getStereotypes since UML 1.5 supports <br/>
     * multiple stereotypes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getStereoType</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isAModelElement(<span class="mv">handle</span>)) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getStereotype();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the stereotypes belonging to some given model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return stereotype collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getStereotypes(<span class="mv">Object handle</span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>)) {<br/>
            // This returns a collection as we have an eye on the future<br/>
            // and multiple stereotypes in UML1.5<br/>
            ArrayList list = new ArrayList(1);<br/>
            list.add(((MModelElement) <span class="mv">handle</span>).getStereotype());<br/>
            return list;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the stimuli belonging to some given link<br/>
     *<br/>
     * @param handle is the link<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (isALink(<span class="mv">handle</span>)) {<br/>
            return ((MLink) <span class="mv">handle</span>).getStimuli();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the Stimuli that are received by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli2</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getStimuli2();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the Stimuli that are send by the given Instance<br/>
     * <br/>
     * @param handle the Instance<br/>
     * @return the collection of stimuli<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getStimuli3</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            return ((MInstance) <span class="mv">handle</span>).getStimuli3();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns a collection with all subvertices belonging to the given<br/>
     * composite state.<br/>
     *<br/>
     * @param handle is the composite state<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSubvertices</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (isACompositeState(<span class="mv">handle</span>)) {<br/>
            return ((MCompositeState) <span class="mv">handle</span>).getSubvertices();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the submachie of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getSubmachine</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MSubmachineState) {<br/>
            return ((MSubmachineState) <span class="mv">handle</span>).getStateMachine();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the submachine of a submachine state<br/>
     *<br/>
     * @param handle is the submachine state<br/>
     * @return submachine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSubmachineStates</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateMachine) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getSubmachineStates();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * The list of SupplierDependencies from a ModelElement.<br/>
     *<br/>
     * @param handle model element.<br/>
     * @return Iterator with the supplier dependencies.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSupplierDependencies</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            return me.getSupplierDependencies();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * The top of a state machine<br/>
     *<br/>
     * @param handle the state machine<br/>
     * @return the top<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getTop</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MStateMachine) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getTop();<br/>
        }<br/>
<br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="add"><span class="mv">illegalArgumentObject</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Get the transition of a guard or action<br/>
     *<br/>
     * @param handle the guard or action<br/>
     * @return the transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTransition(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGuard) {<br/>
            return ((MGuard) <span class="mv">handle</span>).getTransition();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getTransition();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get the trigger of a transition<br/>
     *<br/>
     * @param handle the transition<br/>
     * @return the trigger<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTrigger(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getTrigger();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * The type of a StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     *<br/>
     * @param handle the StructuralFeature, AssociationEnd, Parameter or<br/>
     *  ObjectFlowState<br/>
     * @return the type<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getType(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            return ((MAttribute) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
            return ((MParameter) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            return ((MObjectFlowState) <span class="mv">handle</span>).getType();<br/>
        }<br/>
        <br/>
        // ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the target of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTarget(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (isATransition(<span class="mv">handle</span>)) {<br/>
            return ((MTransition) <span class="mv">handle</span>).getTarget();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the target scope of some model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTargetScope(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            return ((MStructuralFeature) <span class="mv">handle</span>).getTargetScope();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getTargetScope();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the targetflows of a model element<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return a collection of targetflows<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getTargetFlows</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTargetFlows();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="mv"><span class="mv">illegalArgumentCollection</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> int getUpper(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (isAAssociationEnd(<span class="mv">handle</span>)) {<br/>
            int upper = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (end.getMultiplicity() != null)<br/>
                upper = end.getMultiplicity().getUpper();<br/>
            return upper;<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isAMultiplicity</span>(handle)</span>) {<br/>
            MMultiplicity up = (MMultiplicity) <span class="mv">handle</span>;<br/>
            return up.getUpper();<br/>
        }<br/>
        if (isAMultiplicityRange(<span class="mv">handle</span>)) {<br/>
            MMultiplicityRange up = (MMultiplicityRange) <span class="mv">handle</span>;<br/>
            return up.getUpper();<br/>
        }<br/>
        <span class="add"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the use case of an extension point<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @return a use case<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getUseCase</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            return ((MExtensionPoint) <span class="mv">handle</span>).getUseCase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="mv"><span class="mv">illegalArgumentObject</span>(handle)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the upper bound of the multiplicity of the given handle (an<br/>
     * associationend).<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return int<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> int getLower(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (isAAssociationEnd(<span class="mv">handle</span>)) {<br/>
            int lower = 0;<br/>
            MAssociationEnd end = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (end.getMultiplicity() != null)<br/>
                lower = end.getMultiplicity().getLower();<br/>
            return lower;<br/>
        }<br/>
        if (<span class="mv"><span class="mv">isAMultiplicity</span>(handle)</span>) {<br/>
            MMultiplicity low = (MMultiplicity) <span class="mv">handle</span>;<br/>
            return low.getLower();<br/>
        }<br/>
        if (isAMultiplicityRange(<span class="mv">handle</span>)) {<br/>
            MMultiplicityRange low = (MMultiplicityRange) <span class="mv">handle</span>;<br/>
            return low.getLower();<br/>
        }<br/>
        <span class="add"><span class="mv"><span class="mv">illegalArgument</span>(handle)</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the transitions belonging to the given handle. The handle can be<br/>
     * a statemachine or a composite state or an event. <br/>
     * If it's a statemachine the<br/>
     * transitions will be given back belonging to that statemachine. If it's a<br/>
     * compositestate the internal transitions of that compositestate will be<br/>
     * given back. <br/>
     * If it's an event, all transitions triggered by this event <br/>
     * will be given back.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getTransitions(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (isAStateMachine(<span class="mv">handle</span>)) {<br/>
            return ((MStateMachine) <span class="mv">handle</span>).getTransitions();<br/>
        } else if (<span class="mv"><span class="mv">isACompositeState</span>(handle)</span>) {<br/>
            return ((MCompositeState) <span class="mv">handle</span>).getInternalTransitions();<br/>
        } else if (isAEvent(<span class="mv">handle</span>)) {<br/>
            return ((MEvent) <span class="mv">handle</span>).getTransitions();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param handle is the classifier you want to have the attributes for.<br/>
     * @return a collection of the attributes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getStructuralFeatures(<span class="mv">Object handle</span>) {<br/>
        <span class="mv">Collection</span> result = new ArrayList();<br/>
        if (ModelFacade.isAClassifier(<span class="mv">handle</span>)) {<br/>
            MClassifier mclassifier = (MClassifier) <span class="mv">handle</span>;<br/>
<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (ModelFacade.isAStructuralFeature(feature))<br/>
                    result.add(feature);<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method returns all operations of a given Classifier<br/>
     *<br/>
     * @param mclassifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */</span><br/>
    protected <span class="mv">static</span> <span class="mv">Collection</span> getOperations(MClassifier mclassifier) {<br/>
        <span class="mv">Collection</span> result = new ArrayList();<br/>
        Iterator features = mclassifier.getFeatures().iterator();<br/>
        while (features.hasNext()) {<br/>
            MFeature feature = (MFeature) features.next();<br/>
            if (ModelFacade.isAOperation(feature))<br/>
                result.add(feature);<br/>
        }<br/>
        return result;<br/>
    }<br/>
    <br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the Specification of a given Reception<br/>
     * @param handle the Reception<br/>
     * @return String the Specification<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">String</span> <span class="mv">getSpecification</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            return ((MReception) <span class="mv">handle</span>).getSpecification();<br/>
        }<br/>
        <span class="add">return <span class="add"><span class="mv">illegalArgumentString</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns all Interfaces of which this class is a realization.<br/>
     *<br/>
     * @param handle  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getSpecifications(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        <span class="mv">Collection</span> result = new Vector();<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getSpecifications();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            <span class="mv">Collection</span> deps = ((MClassifier) <span class="mv">handle</span>).getClientDependencies();<br/>
            Iterator depIterator = deps.iterator();<br/>
            while (depIterator.hasNext()) {<br/>
                MDependency dep = (MDependency) depIterator.next();<br/>
                if ((dep instanceof MAbstraction)<br/>
                        &amp;&amp; dep.getStereotype() != null<br/>
                        &amp;&amp; dep.getStereotype().getName() != null<br/>
                        &amp;&amp; dep.getStereotype().getName().equals("realize")) {<br/>
                    MInterface i =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MInterface) dep.getSuppliers().toArray()[0];<br/>
                    result.add(i);<br/>
                }<br/>
            }<br/>
            return result;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(handle);</span><br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the suppliers of a dependency.<br/>
     *<br/>
     * @param handle is the dependency<br/>
     * @return a collection of the suppliers<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getSuppliers</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MDependency) {<br/>
            return ((MDependency) <span class="mv">handle</span>).getSuppliers();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the action belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the action<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAction</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getAction();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the activator belonging to some message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @return the activator<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getActivator</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            return ((MMessage) <span class="mv">handle</span>).getActivator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the actual arguments for a given action.<br/>
     *<br/>
     * @param handle is the action<br/>
     * @return the actual arguments<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getActualArguments</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            return ((MAction) <span class="mv">handle</span>).getActualArguments();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns an addition for a given inlcude.<br/>
     * There is a bug in NSUML which gets the addition and base<br/>
     * relationships back to front for include relationships. Solve<br/>
     * reversing their accessors in the code<br/>
     *<br/>
     * @param handle is the include<br/>
     * @return the addition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAddition</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MInclude) {<br/>
            return ((MInclude) <span class="mv">handle</span>).getBase();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the AggregationKind of a given AssociationEnd<br/>
     * @param handle the AssociationEnd<br/>
     * @return the AggregationKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> <span class="mv">getAggregation</span>(<span class="mv">Object handle</span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) <span class="mv">handle</span>).getAggregation();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentObject</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Returns all associated classes for some given classifier.<br/>
     * Returns an empty collection if the given argument handle is not<br/>
     * a classifier.  The given parameter is included in the returned<br/>
     * collection if it has a self-referencing association.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @return Collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> getAssociatedClasses(<span class="mv">Object handle</span>) {<br/>
        <span class="mv">Collection</span> col = new ArrayList();<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) <span class="mv">handle</span>;<br/>
            <span class="mv">Collection</span> ends = classifier.getAssociationEnds();<br/>
            Iterator it = ends.iterator();<br/>
            Set associations = new HashSet();<br/>
            while (it.hasNext()) {<br/>
                MAssociationEnd ae = (MAssociationEnd) it.next();<br/>
                associations.add(ae.getAssociation());<br/>
            }<br/>
            <span class="mv">Collection</span> otherEnds = new ArrayList();<br/>
            it = associations.iterator();<br/>
            while (it.hasNext()) {<br/>
                otherEnds.addAll(((MAssociation) it.next()).getConnections());<br/>
            }<br/>
            otherEnds.removeAll(ends);<br/>
            it = otherEnds.iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getType());<br/>
            }<br/>
            return col;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return illegalArgumentCollection(<span class="mv">handle</span>);</span><br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Common getters<br/>
<br/>
    <span class="mv">/**<br/>
     * The name of a model element or some diagram part.<br/>
     *<br/>
     * @param handle that points out the object.<br/>
     * @return the name<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getName(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof Diagram) {<br/>
            return ((Diagram) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOrderingKind) {<br/>
            return ((MOrderingKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAggregationKind) {<br/>
            return ((MAggregationKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MVisibilityKind) {<br/>
            return ((MVisibilityKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallConcurrencyKind) {<br/>
            return ((MCallConcurrencyKind) <span class="mv">handle</span>).getName();<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the owner of a feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @return classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getOwner(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            return ((MFeature) <span class="mv">handle</span>).getOwner();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tag of a tagged value.<br/>
     *<br/>
     * @param handle The tagged value belongs to this.<br/>
     * @return The found tag as a String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTag(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tagged values iterator of a model element.<br/>
     *<br/>
     * @param handle The tagged values belong to this.<br/>
     * @return The tagged values iterator<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> Iterator getTaggedValues(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTaggedValues().iterator();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Returns the TaggedValues of a ModelElement<br/>
     * @param handle the ModelElement<br/>
     * @return the Collection of TaggedValues<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Collection</span> <span class="mv">getTaggedValuesCollection</span>(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) <span class="mv">{<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getTaggedValues();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="mv">return <span class="mv">illegalArgumentCollection</span>(handle);</span><br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Return the tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The found tag, null if not found<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getTaggedValue(<span class="mv">Object handle</span>, String name) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = ((MModelElement) <span class="mv">handle</span>);<br/>
            Iterator i = me.getTaggedValues().iterator();<br/>
            while (i.hasNext()) {<br/>
                MTaggedValue tv = (MTaggedValue) i.next();<br/>
                if (tv.getTag().equals(name)) {<br/>
                    return tv;<br/>
                }<br/>
            }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="add">return <span class="add"><span class="mv">illegalArgumentObject</span>(<span class="mv">handle</span>)</span>;</span><br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * Return the value of a tagged value with a specific tag.<br/>
     *<br/>
     * @param handle The model element that the tagged value belongs to.<br/>
     * @param name The tag name.<br/>
     * @return The value of the found tag. "" if not found.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTaggedValueValue(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>, String name) {<br/>
        <span class="mv">Object</span> taggedValue = getTaggedValue(<span class="mv">handle</span>, name);<br/>
        if (taggedValue == null) {<br/>
            return "";<br/>
        }<br/>
        return getValueOfTag(taggedValue);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the key (tag) of some tagged value.<br/>
     * <br/>
     * TODO: This does exactly the same as getTag(Object). Remove one of them.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getTagOfTag(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getTag();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the Value of some UML Object<br/>
     * @param handle Object<br/>
     * @return Object the exact type depends on the handle type<br/>
     * (String, Expression, Instance, TaggedValue...)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getValue(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MArgument) {<br/>
            return ((MArgument) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtension) {<br/>
            return ((MExtension) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
            return ((MAttributeLink) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAggregationKind) {<br/>
            return new Integer(((MAggregationKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOrderingKind) {<br/>
            return new Integer(((MOrderingKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperationDirectionKind) {<br/>
            return new Integer(((MOperationDirectionKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MVisibilityKind) {<br/>
            return new Integer(((MVisibilityKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MScopeKind) {<br/>
            return new Integer(((MScopeKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MMessageDirectionKind) {<br/>
            return new Integer(((MMessageDirectionKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MChangeableKind) {<br/>
            return new Integer(((MChangeableKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MPseudostateKind) {<br/>
            return new Integer(((MPseudostateKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallConcurrencyKind) {<br/>
            return new Integer(((MCallConcurrencyKind) <span class="mv">handle</span>).getValue());<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the value of some tagged value.<br/>
     *<br/>
     * @param handle The tagged value.<br/>
     * @return The found value as String.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getValueOfTag(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            return ((MTaggedValue) <span class="mv">handle</span>).getValue();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Return the UUID of this element<br/>
     *<br/>
     * @param base base element (MBase type)<br/>
     * @return UUID<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getUUID(<span class="add"><span class="mv">Object</span> <span class="mv">base</span></span>) {<br/>
        if (isABase(base)) {<br/>
            return ((MBase) base).getUUID();<br/>
        }<br/>
        if (base instanceof CommentEdge) {<br/>
            return (String) ((CommentEdge) base).getUUID();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(base);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return "";<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     *  Return the visibility of this element<br/>
     *  @param handle an nsuml model element<br/>
     *  @return visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> getVisibility(<span class="add"><span class="mv">Object</span> <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            return ((MModelElement) <span class="mv">handle</span>).getVisibility();<br/>
        }<br/>
        //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Other querying methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns a named object in the given object by calling it's lookup method.<br/>
     *<br/>
     * @param handle the object that we search through<br/>
     * @param name of the model element<br/>
     * @return found object, null otherwise<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> <span class="mv">Object</span> lookupIn(<span class="mv">Object <span class="mv">handle</span></span>, String name) {<br/>
        if (<span class="mv">handle</span> instanceof MModel)<br/>
            return ((MModel) <span class="mv">handle</span>).lookup(name);<br/>
        if (<span class="mv">handle</span> instanceof MNamespace)<br/>
            return ((MNamespace) <span class="mv">handle</span>).lookup(name);<br/>
        if (<span class="mv">handle</span> instanceof MClassifier)<br/>
            return ((MClassifier) <span class="mv">handle</span>).lookup(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentObject(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Model modifying methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a feature to some classifier.<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addFeature(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">f</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an instance to a classifier role.<br/>
     *<br/>
     * @param classifierRole is the classifier role<br/>
     * @param instance is the instance to add<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addInstance(Object <span class="mv">classifierRole</span>, <span class="mv">Object <span class="mv">instance</span></span>) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if (classifierRole instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        &amp;&amp; instance instanceof MInstance) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MClassifierRole clr = (MClassifierRole) classifierRole;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    clr.addInstance((MInstance) instance);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(classifierRole, instance);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @author mvw<br/>
     * @param classifierInState the classifierInState<br/>
     * @param state the state that will be linked<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addInState(Object <span class="mv">classifierInState</span>, <span class="mv">Object <span class="mv">state</span></span>) {<br/>
        if (classifierInState instanceof MClassifierInState <br/>
                &amp;&amp; state instanceof MState) {<br/>
            ((MClassifierInState) classifierInState).addInState((MState) state);<br/>
        } else<br/>
            illegalArgument(classifierInState, state);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addFeature(Object <span class="mv">handle</span>, <span class="mv">int index</span>, <span class="mv">Object <span class="mv">f</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, f);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add the given Link to the given Link or Association<br/>
     * @param handle the Link or Association <br/>
     * @param link Link<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addLink(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">link</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAssociation) <span class="mv">handle</span>).addLink((MLink) link);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, link);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add Message to a predecessor Message<br/>
     * @param handle predecessor Message<br/>
     * @param mess Message to be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addMessage3(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">mess</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).addMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mess);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addMethod(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">m</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) <span class="mv">handle</span>).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) <span class="mv">handle</span>).getOwnerScope());<br/>
            ((MOperation) <span class="mv">handle</span>).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, m);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a model element to some namespace.<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addOwnedElement(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">me</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) <span class="mv">handle</span>).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, me);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a Parameter to the given object<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MObjectFlowState, MEvent, MBehavioralFeature, MClassifier<br/>
     * @param parameter Object that will be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addParameter(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">parameter</span></span>) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) <span class="mv">handle</span>).addParameter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MEvent) {<br/>
                ((MEvent) <span class="mv">handle</span>).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
                ((MClassifier) <span class="mv">handle</span>).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameter);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a Parameter to the given object at given location<br/>
     * @param handle the object that will get the Parameter: <br/>
     * MEvent, MBehavioralFeature<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addParameter(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">int index</span>,<br/>
        <span class="mv">Object <span class="mv">parameter</span></span>) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (<span class="mv">handle</span> instanceof MEvent) {<br/>
                ((MEvent) <span class="mv">handle</span>).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameter);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a predecessor to a message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param predecessor is the predecessor<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addPredecessor(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">predecessor</span></span>) {<br/>
        if (<span class="mv">handle</span> != null<br/>
            &amp;&amp; <span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; predecessor != null<br/>
            &amp;&amp; predecessor instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).addPredecessor((MMessage) predecessor);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, predecessor);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a raised Signal to a Message or Operation<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addRaisedSignal(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">sig</span></span>) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (<span class="mv">handle</span> instanceof MMessage) {<br/>
                ((MBehavioralFeature) <span class="mv">handle</span>).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MOperation) {<br/>
                ((MOperation) <span class="mv">handle</span>).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, sig);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a stimulus to a action or link<br/>
     *<br/>
     * @param handle the action or link<br/>
     * @param stimulus is the stimulus<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addStimulus(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">stimulus</span></span>) {<br/>
        if (<span class="mv">handle</span> != null<br/>
            &amp;&amp; stimulus != null<br/>
            &amp;&amp; stimulus instanceof MStimulus) {<br/>
            if (<span class="mv">handle</span> instanceof MAction) {<br/>
                ((MAction) <span class="mv">handle</span>).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MLink) {<br/>
                ((MLink) <span class="mv">handle</span>).addStimulus((MStimulus) stimulus);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stimulus);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add a subvertex to a composite state<br/>
     * @param handle the CompositeState<br/>
     * @param subvertex the StateVertex<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSubvertex(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">subvertex</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).addSubvertex((MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertex);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSupplier(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">element</span></span>) {<br/>
        if (isADependency(<span class="mv">handle</span>) &amp;&amp; isAModelElement(element)) {<br/>
            ((MDependency) <span class="mv">handle</span>).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a supplier dependency to some modelelement<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addSupplierDependency(<br/>
            Object <span class="mv">supplier</span>, <br/>
            <span class="mv">Object <span class="mv">dependency</span></span>) {<br/>
        if (isAModelElement(supplier) &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        illegalArgument(supplier, dependency);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an actual argument to an action<br/>
     * @param handle the action<br/>
     * @param argument the argument<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addActualArgument(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">argument</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) <span class="mv">handle</span>).addActualArgument((MArgument) argument);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, argument);<br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * Adds an annotated element to a comment.<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addAnnotatedElement(Object <span class="mv">comment</span>, <br/>
            <span class="mv">Object <span class="mv">annotatedElement</span></span>) {<br/>
        if (comment instanceof MComment <br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        illegalArgument(comment, annotatedElement);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method adds a classifier to a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addBase(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) <span class="mv">handle</span>).addBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a Classifier to an Instance<br/>
     * @param handle Instance<br/>
     * @param classifier Classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClassifier(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">classifier</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) <span class="mv">handle</span>).addClassifier((MClassifier) classifier);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClient(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">element</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) <span class="mv">handle</span>).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a client dependency to some modelelement<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addClientDependency(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">dependency</span></span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>)<br/>
                &amp;&amp; isADependency(dependency)) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, dependency);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a TaggedValue to a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addTaggedValue(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">taggedValue</span></span>) {<br/>
        if (isAModelElement(<span class="mv">handle</span>) &amp;&amp; isATaggedValue(taggedValue)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).addTaggedValue((MTaggedValue) taggedValue);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, taggedValue);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes the actual Argument from an Action<br/>
     * @param handle Action<br/>
     * @param argument Argument<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeActualArgument(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">argument</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction &amp;&amp; argument instanceof MArgument) {<br/>
            ((MAction) <span class="mv">handle</span>).removeActualArgument((MArgument) argument);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, argument);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a classifier from a classifier role.<br/>
     *<br/>
     * @param handle is the classifier role<br/>
     * @param c is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeBase(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifierRole<br/>
                &amp;&amp; c instanceof MClassifier) {<br/>
            ((MClassifierRole) <span class="mv">handle</span>).removeBase((MClassifier) c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeClientDependency(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">dep</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) <span class="mv">handle</span>).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, dep);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove the given constraint from a given ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeConstraint(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">cons</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement &amp;&amp; <span class="mv"><span class="mv">cons</span> instanceof MConstraint</span>) {<br/>
            ((MModelElement) <span class="mv">handle</span>).removeConstraint(<span class="mv">(MConstraint) <span class="mv">cons</span></span>);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, cons);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove the given context (BehavioralFeature) from a Signal<br/>
     * @param handle Signal<br/>
     * @param context BehavioralFeature<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeContext(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">context</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal<br/>
            &amp;&amp; context instanceof MBehavioralFeature) {<br/>
            ((MSignal) <span class="mv">handle</span>).removeContext((MBehavioralFeature) context);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, context);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method classifier from an instance<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param classifier is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeClassifier(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">classifier</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MInstance) <span class="mv">handle</span>).removeClassifier((MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param feature to remove<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeFeature(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">feature</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier<br/>
                &amp;&amp; feature instanceof MFeature) {<br/>
            ((MClassifier) <span class="mv">handle</span>).removeFeature((MFeature) feature);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, feature);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes an extension point from a use case.<br/>
     *<br/>
     * @param uc is the use case<br/>
     * @param ep is the extension point<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeExtensionPoint(Object <span class="mv">uc</span>, <span class="mv">Object <span class="mv">ep</span></span>) {<br/>
        if (uc instanceof MUseCase<br/>
                &amp;&amp; ep instanceof MExtensionPoint) {<br/>
            ((MUseCase) uc).removeExtensionPoint((MExtensionPoint) ep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(uc, ep);<br/>
    }<br/>
<br/>
    <span class="mv">/**Removes a successor message<br/>
     * @param handle the Message that needs to loose a successor<br/>
     * @param mess the Message that is removed<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeMessage3(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">mess</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; mess instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).removeMessage3((MMessage) mess);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mess);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeOwnedElement(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) <span class="mv">handle</span>).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param p is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeParameter(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">p</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; p instanceof MParameter) {<br/>
            ((MOperation) <span class="mv">handle</span>).removeParameter((MParameter) p);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, p);<br/>
    }<br/>
<br/>
    <span class="mv">/** <br/>
     * Removes a predecessor message<br/>
     * @param handle the Message that needs to loose a predecessor<br/>
     * @param message the Message that is removed<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removePredecessor(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">message</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; message instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).removePredecessor((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, message);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove a given Reception from a given Signal<br/>
     * @param handle the Signal<br/>
     * @param reception the Reception<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeReception(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">reception</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal &amp;&amp; reception instanceof MReception) {<br/>
            ((MSignal) <span class="mv">handle</span>).removeReception((MReception) reception);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, reception);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Remove a given subvertex from a given composite state<br/>
     * @param handle the composite state<br/>
     * @param subvertex the StateVertex<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeSubvertex(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">subvertex</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState<br/>
            &amp;&amp; subvertex instanceof MStateVertex) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).removeSubvertex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    (MStateVertex) subvertex);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertex);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void removeTaggedValue(<span class="mv">Object handle</span>, String name) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    me.removeTaggedValue(name);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the base of some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param base is the base<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBase(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">base</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(base);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MAssociationRole<br/>
            &amp;&amp; base instanceof MAssociation) {<br/>
            ((MAssociationRole) <span class="mv">handle</span>).setBase((MAssociation) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEndRole<br/>
            &amp;&amp; base instanceof MAssociationEnd) {<br/>
            ((MAssociationEndRole) <span class="mv">handle</span>).setBase((MAssociationEnd) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtend &amp;&amp; base instanceof MUseCase) {<br/>
            ((MExtend) <span class="mv">handle</span>).setBase((MUseCase) base);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MInclude &amp;&amp; base instanceof MUseCase) {<br/>
            ((MInclude) <span class="mv">handle</span>).setAddition((MUseCase) base);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, base);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the baseclass of some stereotype.<br/>
     *<br/>
     * @param handle the stereotype<br/>
     * @param baseClass the baseclass<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBaseClass(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">baseClass</span></span>) {<br/>
        if (isAStereotype(<span class="mv">handle</span>) &amp;&amp; baseClass instanceof String) {<br/>
            ((MStereotype) <span class="mv">handle</span>).setBaseClass((String) baseClass);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, baseClass);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a body of a given Method, Constraint or Expression.<br/>
     *<br/>
     * @param handle is the method, expression<br/>
     * @param expr is the body string for the expression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setBody(Object <span class="mv">handle</span>, <span class="add"><span class="mv">Object</span> <span class="mv">expr</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) <span class="mv">handle</span>).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        <span class="add">if (<span class="mv"><span class="mv"><span class="mv">handle</span> instanceof MConstraint</span><br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)</span>) <span class="add">{<br/>
            <span class="add"><span class="add"><span class="add">(<span class="add">(<span class="mv">MConstraint</span>) <span class="mv">handle</span></span>)</span>.<span class="mv">setBody</span>(<span class="mv">(MBooleanExpression) expr</span>)</span>;</span><br/>
            <span class="mv">return;</span><br/>
        }</span></span><br/>
<br/>
        /* TODO: MVW: The next part is fooling the user of setBody()<br/>
         * in thinking that the body of the object is changed.<br/>
         * Instead, a new object is created and as a side-effect <br/>
         * the language is lost.<br/>
         * Maybe we should just copy the language?<br/>
         */<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            MExpressionEditor expressionEditor =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MExpressionEditor) UmlFactory.getFactory().getDataTypes()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .createExpressionEditor(<span class="mv">handle</span>);<br/>
            expressionEditor.setBody((String) expr);<br/>
            <span class="mv">handle</span> = (<span class="mv">Object</span>) expressionEditor.toExpression();<br/>
            // this last step creates a new MExpression<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the language of an expression.<br/>
     *<br/>
     * TODO: This operation is fooling the user<br/>
     * in thinking that the body of the object is changed.<br/>
     * Instead, a new object is created and as a side-effect the body is lost.<br/>
     * There is no other way: a MExpression can not be altered,<br/>
     * once created!<br/>
     * So, this operation should return the created object instead! <br/>
     * Or should it simply copy the body?<br/>
     *<br/>
     * @param handle is the expression<br/>
     * @param language is the lang<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLanguage(<span class="mv">Object <span class="mv">handle</span></span>, String language) {<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            MExpression expression = (MExpression) <span class="mv">handle</span>;<br/>
            MExpressionEditor expressionEditor = (MExpressionEditor)<br/>
                UmlFactory.getFactory().getDataTypes().<br/>
                    createExpressionEditor(<span class="mv">handle</span>);<br/>
            expressionEditor.setLanguage(language);<br/>
            <span class="mv">handle</span> = expressionEditor.toExpression();<br/>
<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, language);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Gets the language attribute of an Expression.<br/>
     *<br/>
     * @param handle is the Expression of which the language is retrieved<br/>
     * @return String the language<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> String getLanguage(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MExpression) {<br/>
            return ((MExpression) <span class="mv">handle</span>).getLanguage();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDefaultValue(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">expr</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) <span class="mv">handle</span>).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the guard of a transition.<br/>
     *<br/>
     * @param handle to the transition<br/>
     * @param guard to be set. Can be null.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setGuard(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">guard</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; (guard == null || guard instanceof MGuard)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setGuard((MGuard) guard);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, guard);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Transition of a guard or effect (Action).<br/>
     * @param handle the Guard or Action<br/>
     * @param trans the Transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTransition(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">trans</span></span>) {<br/>
        if (trans instanceof MTransition) {<br/>
            if (<span class="mv">handle</span> instanceof MGuard) {<br/>
                ((MGuard) <span class="mv">handle</span>).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAction) {<br/>
                ((MAction) <span class="mv">handle</span>).setTransition((MTransition) trans);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, trans);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the trigger event of a transition.<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param event is the trigger event<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTrigger(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">event</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; (event == null || event instanceof MEvent)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setTrigger((MEvent) event);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, event);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the icon for a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param icon String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setIcon(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">icon</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStereotype<br/>
                &amp;&amp; (icon == null || icon instanceof String)) {<br/>
            ((MStereotype) <span class="mv">handle</span>).setIcon((String) icon);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, icon);<br/>
    }<br/>
<br/>
    <span class="mv">/** Set the ImplementationLocation of the given ElementResidence <br/>
     * to the given Component.<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setImplementationLocation(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">component</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) <span class="mv">handle</span>).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, component);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of Include relationships for a usecase<br/>
     * @param handle UseCase<br/>
     * @param includes the collection of Include relationships <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setIncludes(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">includes</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MUseCase) {<br/>
            ((MUseCase) <span class="mv">handle</span>).setIncludes(includes);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, includes);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInitialValue(Object <span class="mv">at</span>, <span class="mv">Object <span class="mv">expr</span></span>) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(at, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/** Sets the given Instance to the given LinkEnd or AttributeLink<br/>
     * @param handle LinkEnd or AttributeLink<br/>
     * @param inst null or Instance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInstance(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">inst</span></span>) {<br/>
        if (inst == null || inst instanceof MInstance) {<br/>
            if (<span class="mv">handle</span> instanceof MLinkEnd) {<br/>
                ((MLinkEnd) <span class="mv">handle</span>).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
                ((MAttributeLink) <span class="mv">handle</span>).setInstance((MInstance) inst);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, inst);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle is the target.<br/>
     * @param intTrans is a collection of transitions.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setInternalTransitions(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">intTrans</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState) {<br/>
            ((MState) <span class="mv">handle</span>).setInternalTransitions(intTrans);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Message<br/>
     * @param messages Collection of predecessor messages<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setMessages3(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">messages</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).setMessages3(messages);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a location of some extension point.<br/>
     *<br/>
     * @param handle is the extension point<br/>
     * @param loc is the location<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLocation(<span class="mv">Object handle</span>, String loc) {<br/>
        if (<span class="mv">handle</span> instanceof MExtensionPoint) {<br/>
            ((MExtensionPoint) <span class="mv">handle</span>).setLocation(loc);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * &lt;p&gt;Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/b&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;/p&gt;<br/>
     *<br/>
     * &lt;p&gt;&lt;b&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/b&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;/p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setModelElementContainer(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">container</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) <span class="mv">handle</span>).setActivityGraph((MActivityGraph) container);<br/>
        } else if (<span class="mv">handle</span> instanceof MModelElement <br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) <span class="mv">handle</span>);<br/>
        } else if (<br/>
            <span class="add"><span class="mv">handle</span> instanceof <span class="mv">MConstraint</span></span><br/>
                &amp;&amp; container instanceof MStereotype) <span class="add">{<br/>
            <span class="add"><span class="mv">MConstraint</span> <span class="add"><span class="mv">c</span> = <span class="mv">(MConstraint) <span class="mv">handle</span></span></span>;</span><br/>
            <span class="mv">c.setConstrainedElement2((MStereotype) container);</span><br/>
        }</span> else if (<br/>
            <span class="mv">handle</span> instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) <span class="mv">handle</span>).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) <span class="mv">handle</span>;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setInstance((MInstance) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) <span class="mv">handle</span>).setInteraction((MInteraction) container);<br/>
        } else if (<span class="mv">handle</span> instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) <span class="mv">handle</span>).setLink((MLink) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) <span class="mv">handle</span>).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) <span class="mv">handle</span>).setPackage((MPackage) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) <span class="mv">handle</span>).setState((MState) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) <span class="mv">handle</span>).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) <span class="mv">handle</span>).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) <span class="mv">handle</span>).setTransition((MTransition) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) <span class="mv">handle</span>).setTransition((MTransition) container);<br/>
        } else if (<br/>
            <span class="mv">handle</span> instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setNamespace((MNamespace) container);<br/>
        } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    illegalArgument(<span class="mv">handle</span>, container);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setMultiplicity(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">arg</span></span>) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg instanceof MMultiplicity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MAssociationRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationRole) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MClassifierRole) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierRole) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) <span class="mv">handle</span>).setMultiplicity(mult);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, arg);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the classifiers of some instance.<br/>
     *<br/>
     * @param handle is the instance<br/>
     * @param v is the classifier vector<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setClassifiers(<span class="mv">Object handle</span>, Vector v) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance) {<br/>
            ((MInstance) <span class="mv">handle</span>).setClassifiers(v);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setName(<span class="mv">Object handle</span>, String name) {<br/>
        if ((<span class="mv">handle</span> instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setName(name);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, name);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNamespace(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">ns</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ns);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNavigable(<span class="mv">Object handle</span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/** Set the value of a given object<br/>
     * <br/>
     * @param handle the Object of which the value will be set<br/>
     * @param value Object <br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setValue(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MArgument) {<br/>
            ((MArgument) <span class="mv">handle</span>).setValue((MExpression) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MAttributeLink) {<br/>
            ((MAttributeLink) <span class="mv">handle</span>).setValue((MInstance) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MExtension) {<br/>
            ((MExtension) <span class="mv">handle</span>).setValue(value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setValue((String) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setVisibility(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">visibility</span></span>) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
                ((MModelElement) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MElementResidence) {<br/>
                ((MElementResidence) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MElementImport) {<br/>
                ((MElementImport) <span class="mv">handle</span>).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, visibility);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param v is the visibility<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setVisibility(<span class="mv">Object handle</span>, short v) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
<br/>
            if (v == ACC_PRIVATE) {<br/>
                me.setVisibility(MVisibilityKind.PRIVATE);<br/>
            } else if (v == ACC_PROTECTED) {<br/>
                me.setVisibility(MVisibilityKind.PROTECTED);<br/>
            } else if (v == ACC_PUBLIC) {<br/>
                me.setVisibility(MVisibilityKind.PUBLIC);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the NodeInstance of a ComponentInstance<br/>
     * @param handle ComponentInstance<br/>
     * @param nodeInstance NodeInstance<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setNodeInstance(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">nodeInstance</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; nodeInstance instanceof MNodeInstance) {<br/>
            ((MComponentInstance) <span class="mv">handle</span>).setNodeInstance(<br/>
                (MNodeInstance) nodeInstance);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, nodeInstance);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the owner of a Feature<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwner(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">owner</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) <span class="mv">handle</span>).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, owner);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Operation of a CallAction or CallEvent<br/>
     * @param handle CallAction or CallEvent<br/>
     * @param operation Operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOperation(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">operation</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCallAction) {<br/>
            ((MCallAction) <span class="mv">handle</span>).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MCallEvent) {<br/>
            ((MCallEvent) <span class="mv">handle</span>).setOperation((MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, operation);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the OrderingKind of a given AssociationEnd <br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOrdering(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">ok</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ok);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the owner scope of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param os is the owner scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwnerScope(<span class="mv">Object <span class="mv">handle</span></span>, short os) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature) {<br/>
            if (os == CLASSIFIER_SCOPE) {<br/>
                ((MFeature) <span class="mv">handle</span>).setOwnerScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (os == INSTANCE_SCOPE) {<br/>
                ((MFeature) <span class="mv">handle</span>).setOwnerScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setOwnerScope(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">os</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) <span class="mv">handle</span>).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, os);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param parameters is a Collection of extensionPoints<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setParameters(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">parameters</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) <span class="mv">handle</span>).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MClassifier) {<br/>
            ((MClassifier) <span class="mv">handle</span>).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) <span class="mv">handle</span>).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parameters);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the target of some action or transition.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param element the target of the model elemnet<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTarget(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">element</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; element instanceof MObjectSetExpression) {<br/>
            ((MAction) <span class="mv">handle</span>).setTarget((MObjectSetExpression) element);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; element instanceof MStateVertex) {<br/>
            ((MTransition) <span class="mv">handle</span>).setTarget((MStateVertex) element);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
    <span class="mv">/**<br/>
     * Sets the state of an internal transition.<br/>
     *<br/>
     * @param handle the internal transition<br/>
     * @param element the state that contains this transition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setState(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">element</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; element instanceof MState) {<br/>
            ((MTransition) <span class="mv">handle</span>).setState((MState) element);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, element);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTargetScope(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">scopeKind</span></span>) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, scopeKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the target scope of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param ts is the target scope<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTargetScope(<span class="mv">Object handle</span>, short ts) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd ae = (MAssociationEnd) <span class="mv">handle</span>;<br/>
<br/>
            if (ts == CLASSIFIER_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.CLASSIFIER);<br/>
                return;<br/>
            } else if (ts == INSTANCE_SCOPE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ae.setTargetScope(MScopeKind.INSTANCE);<br/>
                return;<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Instance<br/>
     * @param c ComponentInstance or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setComponentInstance(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MInstance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; (c == null || c instanceof MComponentInstance)) {<br/>
            ((MInstance) <span class="mv">handle</span>).setComponentInstance((MComponentInstance) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the communicationLink between a link c and a stimulus handle.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param c the link<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setCommunicationLink(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; c instanceof MLink) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setCommunicationLink((MLink) c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, c);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param c is the concurrency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurrency(<span class="mv">Object handle</span>, short c) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            MOperation oper = (MOperation) <span class="mv">handle</span>;<br/>
<br/>
            if (c == GUARDED) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.GUARDED);<br/>
                return;<br/>
            } else if (c == SEQUENTIAL) {<br/>
                oper.setConcurrency(MCallConcurrencyKind.SEQUENTIAL);<br/>
            }<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurrency(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">concurrencyKind</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) <span class="mv">handle</span>).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, concurrencyKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Makes a Composite State concurrent<br/>
     * @param handle the CompositState<br/>
     * @param concurrent boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setConcurent(<span class="mv">Object handle</span>, boolean concurrent) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).setConcurent(concurrent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the condition of an extend<br/>
     *<br/>
     * @param handle is the extend<br/>
     * @param booleanExpression is the condition<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setCondition(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">booleanExpression</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MExtend<br/>
            &amp;&amp; booleanExpression instanceof MBooleanExpression) {<br/>
            ((MExtend) <span class="mv">handle</span>).setCondition(<br/>
                (MBooleanExpression) booleanExpression);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, booleanExpression);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the container of a statevertex.<br/>
     *<br/>
     * @param handle is the stateVertex<br/>
     * @param compositeState is the container. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setContainer(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">compositeState</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStateVertex<br/>
            &amp;&amp; (compositeState == null<br/>
                || compositeState instanceof MCompositeState)) {<br/>
            ((MStateVertex) <span class="mv">handle</span>).setContainer(<br/>
                (MCompositeState) compositeState);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, compositeState);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the contexts for a Signal<br/>
     * @param handle the Signal<br/>
     * @param c the collection of contexts<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setContexts(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">c</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MSignal) {<br/>
            ((MSignal) <span class="mv">handle</span>).setContexts(c);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the dispatch action for some stimulus.<br/>
     *<br/>
     * @param handle the stimulus<br/>
     * @param value the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDispatchAction(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStimulus<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setDispatchAction((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the do activity of a state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value the activity. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setDoActivity(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setDoActivity((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the effect of some transition<br/>
     *<br/>
     * @param handle is the transition<br/>
     * @param value is the effect. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setEffect(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setEffect((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the entry action of some state.<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setEntry(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setEntry((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the exit action of some state<br/>
     *<br/>
     * @param handle is the state<br/>
     * @param value is the action. Can be &lt;tt&gt;null&lt;/tt&gt;.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExit(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (value == null || value instanceof MAction)) {<br/>
            ((MState) <span class="mv">handle</span>).setExit((MAction) value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the Expression of a Guard or ChangeEvent<br/>
     * @param handle Guard or ChangeEvent<br/>
     * @param value BooleanExpression or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExpression(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGuard<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
            ((MGuard) <span class="mv">handle</span>).setExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MChangeEvent<br/>
            &amp;&amp; (value == null || value instanceof MBooleanExpression)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeEvent ce = (MChangeEvent) <span class="mv">handle</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ce.setChangeExpression((MBooleanExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the time-expression for a TimeEvent. <br/>
     * @param handle Object (MTimeEvent)<br/>
     * @param value Object (MTimeExpression)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setWhen(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">value</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTimeEvent<br/>
            &amp;&amp; (value == null || value instanceof MTimeExpression)) {<br/>
            ((MTimeEvent) <span class="mv">handle</span>).setWhen((MTimeExpression) value);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>, value);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the extension of a usecase<br/>
     * @param handle Extend<br/>
     * @param ext UseCase or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExtension(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">ext</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(ext);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MExtend<br/>
            &amp;&amp; (ext == null || ext instanceof MUseCase)) {<br/>
            ((MExtend) <span class="mv">handle</span>).setExtension((MUseCase) ext);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ext);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the extension points of some use cases.<br/>
     *<br/>
     * @param handle the use case<br/>
     * @param extensionPoints is the extension points<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setExtensionPoints(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">extensionPoints</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MUseCase &amp;&amp; extensionPoints instanceof List) {<br/>
            ((MUseCase) <span class="mv">handle</span>).setExtensionPoints(extensionPoints);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extensionPoints);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the list of features<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setFeatures(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">features</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MClassifier<br/>
            &amp;&amp; features instanceof List) {<br/>
            ((MClassifier) <span class="mv">handle</span>).setFeatures((List) features);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAggregation(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">aggregationKind</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, aggregationKind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAssociation(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">association</span></span>) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MLink) {<br/>
                ((MLink) <span class="mv">handle</span>).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, association);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the Changeability of a StructuralFeature or AssociationEnd<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChangeability(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">ck</span></span>) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) <span class="mv">handle</span>).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, ck);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChangeable(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            }<br/>
            else {<br/>
                ((MStructuralFeature) <span class="mv">handle</span>).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
            }<br/>
        } else if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) <span class="mv">handle</span>;<br/>
            if (flag)<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            else<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**Set the child for a generalization<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setChild(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">child</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, child);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if of some model element is abstract.<br/>
     *<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAbstract(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MGeneralizableElement) <span class="mv">handle</span>).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MOperation) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MOperation) <span class="mv">handle</span>).setAbstract(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MReception) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MReception) <span class="mv">handle</span>).setAbstarct(flag);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the addition to an include.<br/>
     * There is a bug in NSUML that reverses additions and bases for includes.<br/>
     * @param handle Include <br/>
     * @param useCase UseCase<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAddition(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">useCase</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(<span class="mv">handle</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkExists(useCase);<br/>
<br/>
        if (<span class="mv">handle</span> instanceof MInclude) {<br/>
            ((MInclude) <span class="mv">handle</span>).setBase((MUseCase) useCase);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the action to a message<br/>
     *<br/>
     * @param handle is the message<br/>
     * @param action is the action<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAction(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">action</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; (action == null || action instanceof MAction)) {<br/>
            ((MMessage) <span class="mv">handle</span>).setAction((MAction) action);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, action);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Activator message of an message<br/>
     * @param handle Message<br/>
     * @param message Message<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setActivator(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">message</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; (message == null || message instanceof MMessage)) {<br/>
            ((MMessage) <span class="mv">handle</span>).setActivator((MMessage) message);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, message);<br/>
    }<br/>
<br/>
    <span class="mv">/**Makes a Class active<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setActive(<span class="mv">Object handle</span>, boolean active) {<br/>
        if (<span class="mv">handle</span> instanceof MClass) {<br/>
            ((MClass) <span class="mv">handle</span>).setActive(active);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the asynchronous property of an action.<br/>
     *<br/>
     * @param handle the action<br/>
     * @param value the value to alter the asynchronous property to<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setAsynchronous(<span class="mv">Object handle</span>, boolean value) {<br/>
        if (<span class="mv">handle</span> instanceof MAction) {<br/>
            ((MAction) <span class="mv">handle</span>).setAsynchronous(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setLeaf(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            ((MOperation) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) <span class="mv">handle</span>).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRaisedSignals(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">raisedSignals</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the receiver of some model element.<br/>
     * @param handle model element<br/>
     * @param receiver the receiver<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setReceiver(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">receiver</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage<br/>
            &amp;&amp; receiver instanceof MClassifierRole) {<br/>
            ((MMessage) <span class="mv">handle</span>).setReceiver((MClassifierRole) receiver);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; receiver instanceof MInstance) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setReceiver((MInstance) receiver);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, receiver);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the recurrence of an Action<br/>
     * @param handle Action<br/>
     * @param expr IterationExpression<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRecurrence(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">expr</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; expr instanceof MIterationExpression) {<br/>
            ((MAction) <span class="mv">handle</span>).setRecurrence((MIterationExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the represented classifier of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param classifier is the classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRepresentedClassifier(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">classifier</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration<br/>
            &amp;&amp; classifier instanceof MClassifier) {<br/>
            ((MCollaboration) <span class="mv">handle</span>).setRepresentedClassifier(<br/>
                (MClassifier) classifier);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, classifier);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the represented operation of some collaboration<br/>
     *<br/>
     * @param handle the collaboration<br/>
     * @param operation is the operation<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRepresentedOperation(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">operation</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCollaboration<br/>
            &amp;&amp; operation instanceof MOperation) {<br/>
            ((MCollaboration) <span class="mv">handle</span>).setRepresentedOperation(<br/>
                (MOperation) operation);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, operation);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setResident(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">resident</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) <span class="mv">handle</span>).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, resident);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setResidents(<span class="mv">Object <span class="mv">handle</span></span>, <span class="mv">Collection <span class="mv">residents</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MNodeInstance) {<br/>
            ((MNodeInstance) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MComponentInstance) {<br/>
            ((MComponentInstance) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MNode) {<br/>
            ((MNode) <span class="mv">handle</span>).setResidents(residents);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setRoot(<span class="mv">Object <span class="mv">handle</span></span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MOperation) {<br/>
            ((MOperation) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) <span class="mv">handle</span>).setRoot(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Expression (script) for an Action<br/>
     * @param handle Action<br/>
     * @param expr the script (ActionExpression)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setScript(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">expr</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAction<br/>
            &amp;&amp; (expr == null || expr instanceof MActionExpression)) {<br/>
            ((MAction) <span class="mv">handle</span>).setScript((MActionExpression) expr);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, expr);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the sender of some model element.&lt;p&gt;<br/>
     *<br/>
     * @param handle model element<br/>
     * @param sender the sender<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSender(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">sender</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage &amp;&amp; sender instanceof MClassifierRole) {<br/>
            ((MMessage) <span class="mv">handle</span>).setSender((MClassifierRole) sender);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MStimulus &amp;&amp; sender instanceof MInstance) {<br/>
            ((MStimulus) <span class="mv">handle</span>).setSender((MInstance) sender);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, sender);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Signal<br/>
     * @param handle SendAction or Reception or SignalEvent<br/>
     * @param signal Signal or null<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSignal(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">signal</span></span>) {<br/>
        if (signal == null || signal instanceof MSignal) {<br/>
            if (<span class="mv">handle</span> instanceof MSendAction) {<br/>
                ((MSendAction) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MReception) {<br/>
                ((MReception) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MSignalEvent) {<br/>
                ((MSignalEvent) <span class="mv">handle</span>).setSignal((MSignal) signal);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, signal);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the source state of some message.<br/>
     *<br/>
     * @param handle the message<br/>
     * @param state the source state<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSource(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">state</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="mv">handle</span> instanceof MTransition &amp;&amp; state instanceof MStateVertex) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MTransition) <span class="mv">handle</span>).setSource((MStateVertex) state);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, state);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSources(<span class="mv">Object handle</span>, <span class="mv">Collection <span class="mv">specifications</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MFlow) {<br/>
            ((MFlow) <span class="mv">handle</span>).setSources(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
    <br/>
    <span class="mv">/**<br/>
     * <br/>
     * @param handle a reception<br/>
     * @param specification the specification<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecification(<span class="mv">Object handle</span>, String specification) {<br/>
        if (<span class="mv">handle</span> instanceof MReception) {<br/>
            ((MReception) <span class="mv">handle</span>).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
        illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Specification flag for a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecification(<span class="mv">Object handle</span>, boolean specification) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSpecifications(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">specifications</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) <span class="mv">handle</span>).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKind(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">kind</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) <span class="mv">handle</span>).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) <span class="mv">handle</span>).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, kind);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToIn(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.IN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToInOut(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.INOUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToOut(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.OUT);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setKindToReturn(<span class="mv">Object handle</span>) {<br/>
        if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MParameter) <span class="mv">handle</span>).setKind(MParameterDirectionKind.RETURN);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setParent(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">parent</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setParent(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, parent);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Generalization <br/>
     * @param pt Classifier<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setPowertype(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">pt</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MGeneralization &amp;&amp; pt instanceof MClassifier) {<br/>
            ((MGeneralization) <span class="mv">handle</span>).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, pt);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of predecessing messages<br/>
     * @param handle Message<br/>
     * @param predecessors Collection of Messages<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setPredecessors(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">predecessors</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MMessage) {<br/>
            ((MMessage) <span class="mv">handle</span>).setPredecessors(predecessors);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, predecessors);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setQuery(<span class="mv">Object handle</span>, boolean flag) {<br/>
        if (<span class="mv">handle</span> instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) <span class="mv">handle</span>).setQuery(flag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setType(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">type</span></span>) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (<span class="mv">handle</span> instanceof MObjectFlowState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MObjectFlowState) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MClassifierInState) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MClassifierInState) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MParameter) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MParameter) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MAssociationEnd) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MAssociationEnd) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            if (<span class="mv">handle</span> instanceof MStructuralFeature) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((MStructuralFeature) <span class="mv">handle</span>).setType((MClassifier) type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, type);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the UUID of this element<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setUUID(<span class="mv">Object handle</span>, String uuid) {<br/>
        if (isABase(<span class="mv">handle</span>)) {<br/>
            ((MBase) <span class="mv">handle</span>).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the Tag of a TaggedValue <br/>
     * @param handle TaggedValue<br/>
     * @param tag String<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTag(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">tag</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue &amp;&amp; tag instanceof String) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setTag((String) tag);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, tag);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTaggedValue(<br/>
        <span class="mv">Object handle</span>,<br/>
        String tag,<br/>
        String value) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    ((MModelElement) <span class="mv">handle</span>).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the TaggedValues of a ModelElement<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setTaggedValues(<br/>
        <span class="mv">Object handle</span>,<br/>
        <span class="mv">Collection <span class="mv">taggedValues</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            ((MModelElement) <span class="mv">handle</span>).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a value of some taggedValue.<br/>
     *<br/>
     * @param handle is the tagged value<br/>
     * @param value is the value<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setValueOfTag(<span class="mv">Object handle</span>, String value) {<br/>
        if (<span class="mv">handle</span> instanceof MTaggedValue) {<br/>
            ((MTaggedValue) <span class="mv">handle</span>).setValue(value);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets a state machine of some state or transition.<br/>
     *<br/>
     * @param handle is the state or transition<br/>
     * @param stm is the state machine<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setStateMachine(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">stm</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MState<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MState) <span class="mv">handle</span>).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MTransition<br/>
            &amp;&amp; (stm == null || stm instanceof MStateMachine)) {<br/>
            ((MTransition) <span class="mv">handle</span>).setStateMachine((MStateMachine) stm);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stm);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * &lt;p&gt;TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setStereotype(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">stereo</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) <span class="mv">handle</span>;<br/>
            if (stereo instanceof MStereotype<br/>
                &amp;&amp; me.getModel() != ((MStereotype) stereo).getModel()) {<br/>
                ((MStereotype) stereo).setNamespace(me.getModel());<br/>
            }<br/>
            if (stereo == null || stereo instanceof MStereotype) {<br/>
                me.setStereotype((MStereotype) stereo);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, stereo);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Set the collection of substates for a CompositeState<br/>
     * @param handle CompositeState<br/>
     * @param subvertices collection of sub-StateVertexes<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void setSubvertices(<span class="mv">Object handle</span>, <span class="add"><span class="mv">Collection</span> <span class="mv">subvertices</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MCompositeState) {<br/>
            ((MCompositeState) <span class="mv">handle</span>).setSubvertices(subvertices);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, subvertices);<br/>
    }<br/>
<br/>
    <span class="mv">/** Add an End to a connection<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addConnection(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">connection</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) <span class="mv">handle</span>).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (<span class="mv">handle</span> instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) <span class="mv">handle</span>).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, connection);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addConstraint(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">mc</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MModelElement &amp;&amp; <span class="add"><span class="mv">mc</span> instanceof <span class="add"><span class="add">MConstraint</span></span></span>) {<br/>
            ((MModelElement) <span class="mv">handle</span>).addConstraint(<span class="add">(<span class="add"><span class="add">MConstraint</span></span>) <span class="mv">mc</span></span>);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, mc);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addDeploymentLocation(Object <span class="mv">handle</span>, <span class="mv">Object <span class="mv">node</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) <span class="mv">handle</span>).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, node);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Add an extended element to a stereotype<br/>
     * @param handle Stereotype<br/>
     * @param extendedElement ExtensionPoint<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addExtendedElement(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">extendedElement</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MStereotype<br/>
            &amp;&amp; extendedElement instanceof MExtensionPoint) {<br/>
            ((MStereotype) <span class="mv">handle</span>).addExtendedElement(<br/>
                (MModelElement) extendedElement);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extendedElement);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Adds an extension point to some model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param extensionPoint is the extension point<br/>
     */</span><br/>
    <span class="mv">public</span> <span class="mv">static</span> void addExtensionPoint(<br/>
        Object <span class="mv">handle</span>,<br/>
        <span class="mv">Object <span class="mv">extensionPoint</span></span>) {<br/>
        if (extensionPoint instanceof MExtensionPoint) {<br/>
            if (<span class="mv">handle</span> instanceof MUseCase) {<br/>
                ((MUseCase) <span class="mv">handle</span>).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
            if (<span class="mv">handle</span> instanceof MExtend) {<br/>
                ((MExtend) <span class="mv">handle</span>).addExtensionPoint(<br/>
                    (MExtensionPoint) extensionPoint);<br/>
                return;<br/>
            }<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(<span class="mv">handle</span>, extensionPoint);<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Returns the name of the UML Model class, e.g. it it will return<br/>
     * Class for an object of type MClass.<br/>
     *<br/>
     * @param handle MBase<br/>
     * @return classname of modelelement<br/>
     */</span><br/>
    <span class="add">public</span> <span class="mv">static</span> String getUMLClassName(<span class="mv">Object <span class="mv">handle</span></span>) {<br/>
        if (<span class="mv">handle</span> instanceof MBase) {<br/>
            return ((MBase) <span class="mv">handle</span>).getUMLClassName();<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return illegalArgumentString(<span class="mv">handle</span>);<br/>
    }<br/>
<br/>
    ////////////////////////////////////////////////////////////////<br/>
    // Convenience methods<br/>
<br/>
    <span class="mv">/**<br/>
     * Tests if an element is marked removed.<br/>
     *<br/>
     * &lt;p&gt;Model specific: NSUML is littered with calls to a function also<br/>
     * named checkExists. That function is however a NOP (it is empty in<br/>
     * MBaseImpl, and it is final so it cannot be overridden anywhere).<br/>
     *<br/>
     * @param obj the element to test.<br/>
     * @throws IllegalStateException iff obj is marked removed.<br/>
     */</span><br/>
    private <span class="mv">static</span> void checkExists(<span class="mv">Object <span class="mv">obj</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((obj instanceof MBase) &amp;&amp; ((MBase) obj).isRemoved()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalStateException("Operation on a removed object ["<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    + obj + "]");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * The empty set.<br/>
     *<br/>
     * @return an empty collection.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Collection</span> emptyCollection() {<br/>
        return Collections.EMPTY_LIST;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Get a string representation of the class type. <br/>
     * Purpose: documenting an exception<br/>
     * @param handle the Class or null<br/>
     * @return String <br/>
     */</span><br/>
    protected <span class="mv">static</span> String getClassNull(<span class="mv">Object <span class="add">handle</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="add">handle</span> == null) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[null]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return "[" + <span class="add">handle</span> + "/" + <span class="add">handle</span>.getClass() + "]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     */</span><br/>
    private <span class="mv">static</span> void illegalArgument(<span class="mv">Object <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg));<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return a boolean for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> boolean illegalArgumentBoolean(<span class="add"><span class="mv">Object</span> <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Object for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Object</span> illegalArgumentObject(<span class="mv">Object <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="add"><span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return Collection for use in the return statement.<br/>
     */</span><br/>
    <span class="mv">private</span> <span class="mv">static</span> <span class="add"><span class="add">Collection</span></span> <span class="add">illegalArgumentCollection</span>(<span class="mv">Object <span class="mv">arg</span></span>) <span class="mv">{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }</span></span><br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called with<br/>
     * an incorrect argument.&lt;p&gt;<br/>
     *<br/>
     * @param arg is the incorrect argument.<br/>
     * @return String for use in the return statement.<br/>
     */</span><br/>
    private <span class="mv">static</span> String illegalArgumentString(<span class="add"><span class="mv">Object</span> <span class="mv">arg</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
<br/>
    <span class="mv">/**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     */</span><br/>
    private <span class="mv">static</span> <span class="mv">Object</span> illegalArgument(Object <span class="mv">arg1</span>, <span class="add"><span class="mv">Object</span> <span class="mv">arg2</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Unrecognized object "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg1) + " or "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   + getClassNull(arg2));<br/>
    }<br/>
<br/>
    <span class="add">/**<br/>
     * Method that throws an error when a ModelFacade method is called<br/>
     * with an incorrect argument. At least one of the arguments given<br/>
     * is incorrect.&lt;p&gt;<br/>
     *<br/>
     * @param arg1 is one of the argument, possibly incorrect.<br/>
     * @param arg2 is one of the argument, possibly incorrect.<br/>
     * @return Object for use in the return statement.<br/>
     */</span><br/>
    private <span class="add">static</span> <span class="mv">Object</span> illegalArgumentObject(Object <span class="mv">arg1</span>, <span class="add"><span class="add"><span class="add">Object</span></span> <span class="mv">arg2</span></span>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;illegalArgument(arg1, arg2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>